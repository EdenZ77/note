# 基本概念

## API 的层次结构

- API Group：API 组，将 API 分类，如 apps、 batch 等。
- Version：Group 包含多个 Version，用于版本控制。
- Resource/SubResource：资源/子资源。
- Kind：资源类别。
- Verbs：某种资源类型支持的操作方法。
- Object：某种资源类型创建出的实体对象。
- TypeMeta：Object 所属的组、版本、资源类型信息，对应 YAML 资源文件中的 kind 和 apiVersion。
- ObjectMeta：Object 自身的属性信息，对应 YAML 资源文件中的 metadata。

## 版本控制

开源界常用的版本控制一般可分为 3 种，分别是 alpha、 beta、 stable，它们之间的迭代顺序为 alpha → beta → stable，通常用来表示软件测试过程中的 3 个阶段。 alpha 表示第 1 个阶段，一般用于内部测试； beta 表示第 2 个阶段，该版本已经修复了大部分的不完善之处，但仍然可能存在缺陷和漏洞，一般供特定的用户群进行测试； stable 表示第 3 个阶段，此时基本形成了产品并相当成熟，可以稳定运行。

1） alpha 版本

alpha 版本为内部测试版本，供 Kubernetes 开发者内部测试使用。该版本是不稳定的，可能存在很多缺陷和漏洞，开发者随时可能会丢弃对该版本功能的支持。在默认情况下，处于 alpha 版本的功能会被禁用。 alpha 版本的命名格式为 v1alpha1、v1alpha2、v2alpha1。

2） beta 版本

beta 版本为相对稳定版本。 beta 版本经过官方和社区多次测试，后面迭代时会有较小的改变，但该版本不会被删除。 1.24 之前的版本，在默认情况下，处于 beta 版本的 API 是开启状态的，从 1.24 版本开始，在默认情况下，不会在集群中启用新的 beta 版本的 API，现有的 beta 版本的 API 将继续默认启用。 beta 版本的命名格式为 v1beta1、v1beta2、v2beta1。

3） stable 版本

stable 版本为正式发布的版本。 stable 版本基本形成了产品，该版本不会被删除。在默认情况下，处于 stable 版本的功能全部是开启状态的。 stable 版本的命名格式为 v1、v2、v3。  

## 组

核心资源对应的 API 版本通过请求 Kubernetes 的 `/api` 接口来访问，没有组的信息，且只有 `v1` 一个结果；非核心资源对应的 API 版本通过请求 Kubernetes 的 `/apis` 接口来访问，都带有组的信息，组可能包含一个或多个版本。

<img src="image/image-20250723175021341.png" alt="image-20250723175021341" style="zoom:40%;" />

## API 术语

Kubernetes 中有各种 API 术语，包括资源、对象、类别、类型等，在后续内容中会经常提及，尤其是资源一词，在不同的语境下可能代表资源类型（ Resource Type）或资源对象（ Resource Object）。例如，当我们描述：“通过执行 kubectl 命令可以请求 Pod 资源，并检查返回的资源是否正确”这句话时，前者指的是资源类型，而后者指的是资源对象。本节将对这些术语做相关说明，它们的关系如图 3-2 所示。  

<img src="image/image-20250723180002100.png" alt="image-20250723180002100" style="zoom: 80%;" />

访问资源：

- 集群作用域的资源：
  - `GET /apis/GROUP/VERSION/RESOURCETYPE` - 返回指定资源类型的资源集合
  - `GET /apis/GROUP/VERSION/RESOURCETYPE/NAME` - 返回指定资源类型下名称为 NAME 的资源
- 名字空间作用域的资源：
  - `GET /apis/GROUP/VERSION/RESOURCETYPE` - 返回所有名字空间中指定资源类型的全部实例集合
  - `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE` - 返回名字空间 NAMESPACE 内给定资源类型的全部实例集合
  - `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME` - 返回名字空间 NAMESPACE 中给定资源类型的名称为 NAME 的实例

由于名字空间本身是一个集群作用域的资源类型，你可以通过 `GET /api/v1/namespaces/` 检视所有名字空间的列表，使用 `GET /api/v1/namespaces/NAME` 查看特定名字空间的详细信息。

1、资源与动词

在 Kubernetes 中的术语区分如下：

- 资源类型是 URL 中使用的名称（pods、 namespaces、 services），可通过`kubectl api-resources`查看。
- 资源类型的单个实例被称为对象（Object）。
- 对于某些资源类型包含一个或多个子资源，这些子资源被表示为资源下的 URI 路径。  

在 Kubernetes 源码中， GVR（ Group、 Version、 Resource）中的 Resource 正是这里介绍的资源类型。Kubernetes 支持对资源进行 Patch（选择性修改某些字段）和 Watch（流式集合读取数据）操作。  

`kubectl api-resources` 命令实际上列出的不是完整的 API 资源类型。如 `deployments/scale`子资源就没有在结果中被列出。要想列出完整的 API 资源类型，需要先执行 `kubectl get --raw /` 命令，然后根据返回的所有 Path 递归查询 API 组支持的资源类型。

```shell
root@OPS-LVS-172-30-3-240:~# kubectl get --raw /apis/apps/v1
{
    "kind": "APIResourceList",
    "apiVersion": "v1",
    "groupVersion": "apps/v1",
    "resources": [
        {
            "name": "deployments",
            "singularName": "deployment",
            "namespaced": true,
            "kind": "Deployment",
            "verbs": [
                "create",
                "delete",
                "deletecollection",
                "get",
                "list",
                "patch",
                "update",
                "watch"
            ],
            "shortNames": [
                "deploy"
            ],
            "categories": [
                "all"
            ],
            "storageVersionHash": "8aSe+NMegvE="
        },
        {
            "name": "deployments/scale",
            "singularName": "",
            "namespaced": true,
            "group": "autoscaling",
            "version": "v1",
            "kind": "Scale",
            "verbs": [
                "get",
                "patch",
                "update"
            ]
        },
        {
            "name": "deployments/status",
            "singularName": "",
            "namespaced": true,
            "kind": "Deployment",
            "verbs": [
                "get",
                "patch",
                "update"
            ]
        },
        ......
    ]
}
```

2、资源类别

所有资源类型都有一个具体的表示，被称为类别（Kind），也被称为对象模式（ObjectScheme），是指特定的数据结构，即属性和特性的某种组合。资源类别分为以下 3 种：

- Object：资源类型的单个实例，代表系统中的持久对象。
- List：
- Simple：

> 注意区分 Kubernetes 源码中两个相似单词的不同含义。
>
> - Schema：表示对象的模式，由 Group、 Version、 Kind、 Resource 组成的 GVK 或 GVR 等数据结构的包名使用的是 Schema。
> - Scheme：资源类型注册、转换等操作的注册表使用的是 Scheme。  

3、资源对象

从狭义上讲，对象是资源类型的单个实例，代表集群的意图（期望状态）和状态（实际状态）。 API 返回的所有 JSON 资源对象的字段具有以下特点：

（1）必须包含以下字段：

- kind：字符串，标识此对象应具有的模式。
- apiVersion：字符串，标识此对象应具有的架构版本。

这些字段是正确解码对象所必需的。这些字段对应源码中的 TypeMeta 数据结构。

（2）包含 metadata

- metadata.namespace：命名空间的字符串（默认为default）。
- metadata.name：在当前命名空间中唯一标识此对象的字符串。
- metadata.uid：时间和空间上唯一的值，用于区分已删除和重新创建的同名对象。

此外， metadata 还包括 labels 和 annotations 字段，以及一些版本控制和时间戳信息。对应源码中的 ObjectMeta 数据结构。

（3）包含 Spec 和 Status

它们负责管理对象的配置： Spec（规约）和 Status（状态）。对于具有 Spec 的对象，用户必须在创建对象时设置其内容，描述希望对象具有的特征，即期望状态（ Desired State）。Status 描述了对象的当前状态（ Current State），它是由 Kubernetes 系统和组件设置并更新的。在任何时刻，Kubernetes 控制平面都在积极地管理对象的实际状态，以使其达成期望状态。

## API 资源组成

Kubernetes 中的 API 资源主要分为三大类：

- 内置资源： Kubernetes 官方提供的资源。
- 自定义资源： 向 Kubernetes API 中增加新类型， 以扩展 Kubernetes 的功能。
- 聚合资源：与自定义资源（CRD）不同，聚合资源通过 APIService 对象注册新的 API 路径，并将这些路径的请求转发到开发者自己的服务上。

## 版本化资源与未版本化资源

在 Kubernetes 源码中，会出现 Versioned Type、Unversioned Type 字样，其可被翻译为版本化、未版本化。它们之间的区别如下。

- Versioned Type：表示该资源的字段信息会随着时间的变化不断迭代，需要随着版本的变化而演进， 以及控制不同版本的兼容性。如 Deployment 资源， 从 `extensions` 组的 `alpha` 版本逐渐演进到目前的 `apps` 组的 `v1` 版本，不同版本之间可能废弃或新增一些字段，彼此是不兼容的。
- Unversioned Type：表示该资源的字段信息永远保持向后兼容，就好像它们在一个永远不会更新的 API 组和版本中。

除部分资源是 Unversioned 类型的外，其他资源都是 Versioned 类型的。

未版本化类型通常不是业务核心对象。它们是 Kubernetes API 系统内部运作的基础设施元数据和核心通信机制：

- **API 响应结构 (`metav1.Status`)：** 用于表示操作结果（成功/失败、状态码、错误消息）。无论你操作的是哪个版本的对象，表示操作结果的结构 `Status`必须是统一的、客户端始终能理解的。
- **API 发现机制 (`metav1.APIVersions`, `metav1.APIGroupList`, `metav1.APIGroup`, `metav1.APIResourceList`)：** 客户端需要一种标准的方式（即使用这些固定的结构）来“发现”当前服务器上有哪些 API 组、哪些版本、哪些资源可用。这个发现机制本身的输出格式不能变，否则客户端就无法开始查找和理解 API。

 未版本化资源不需要版本转换 (No Version Conversion Needed)：

- 由于它们本身的结构不变，也就不存在 `v1beta1.Status`和 `v1.Status`之说。在任何需要用到这些结构的地方，Kubernetes 代码库中都只有一个版本的定义（尽管它在 `metav1`包下，但这个 `v1`是包内部的版本表示方式，并不是一个会演变的 API 版本）。
- API 服务器在处理这些资源时无需执行复杂的注册到 `scheme`的过程来进行版本转换，它们只有一个格式。

使用未版本化的巨大优势是极大地简化了客户端库、命令行工具（kubectl）、控制器、API 服务器自身以及与其他组件的交互。

### metav1.APIVersions (`/api`响应结构)

- 作用：表示**核心 API 组（Core Group / Legacy Group）** 支持的版本列表。这个组比较特殊，没有显式的组名（路径前缀是 `/api`而不是 `/apis/<group>`），它包含了像 Pod，Service，Node，Namespace 等最基础的核心资源。
- 核心字段：
  - `Versions []string`: 该核心组支持的 API 版本列表 (例如 `["v1"]`)。早期可能有更多。
  - `ServerAddressByClientCIDRs []metav1.ServerAddressByClientCIDR`: (可选) 提供服务器地址信息，主要用于高可用或网络配置复杂的场景。
- 示例输出 (`kubectl get --raw /api`)：

```shell
root@eden:~# kubectl get --raw /api
{
    "kind": "APIVersions",
    "versions": [
        "v1"
    ],
    "serverAddressByClientCIDRs": [
        {
            "clientCIDR": "0.0.0.0/0",
            "serverAddress": "192.168.243.100:6443"
        }
    ]
}
// 位于：staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go
type APIVersions struct {
	TypeMeta `json:",inline"`

	Versions []string `json:"versions" protobuf:"bytes,1,rep,name=versions"`

	ServerAddressByClientCIDRs []ServerAddressByClientCIDR `json:"serverAddressByClientCIDRs" protobuf:"bytes,2,rep,name=serverAddressByClientCIDRs"`
}
```

客户端访问 `/api`时必须能解析其结构才能知道有哪些版本可用。如果这个结构本身还需要版本控制，就陷入了死循环（客户端首先需要知道 `/api`接口自身的版本）

### `metav1.APIGroupList`(`/apis`响应结构)

- 作用：表示所有非核心 API 组（Groups）的列表。这是客户端发现所有 API 组的入口（核心组通过 `/api`单独列出）。

- 核心字段：

  - `Groups []APIGroup`: 一个列表，每个元素是一个 `metav1.APIGroup`对象，描述一个 API 组。

- 示例输出 (`kubectl get --raw /apis`)：

  ```
  
  ```























## 内部版本与外部版本



# K8S API 的数据结构  



