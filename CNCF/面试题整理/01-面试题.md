> 参考资料：
>
> 1、小徐先生的编程世界
>
> 2、极客事件专栏《Go并发编程》
>
> 3、

# 热点题目复习

- [ ] go并发：
  - [x] Mutex：本质是锁标记位，正常模式与饥饿模式，模式切换条件（1毫秒与最后一个waiter），自旋，CAS，不可重入，不可复制（vet检查锁复制：通过实现了Locker接口），unsafe包获取锁信息。
  - [x] RWMutex：本质是针对读多写少的情况、是写优先的读写锁，使用Mutex+信号量，readerCount通过反转实现（当前reader的数量、负数表示有writer竞争锁），不可复制
  - [x] WaitGroup：本质任务编排用来等待一组协程完成任务、通过Add+Done+Wait，state(高32位+低32位)+信号量。
  - [x] Cond：本质是等待/通知机制，通过Broadcast+Signal+Wait，Wait必须加锁校验等待条件（Wait源码中先解锁然后阻塞，最后加锁）。
  - [x] Channel：可用做数据传递、信号通知（无缓冲1：1、1：n的通知机制）、任务编排、锁；底层原理：环形队列、队列的读写index、阻塞的读协程队列waitq、阻塞的写协程队列waitq、写流程（写时存在阻塞读协程、无阻塞读有空间、无空间）、读流程（已关闭无元素、读时有阻塞写协程、读时缓存区无元素）；与Cond的对比。
  - [x] Atomic：主要是Value的底层实现，引出禁止抢占与抢占调度，引出接口实现原理；
  - [x] Unsafe包：核心是提供了直接操作内存地址的能力，其中任何类型的指针可以转换为Pointer，Pointer也可以转换回任何类型的指针；Pointer具有内存保护可以阻止对象被回收，而uintptr无保护GC把它仅仅当成是整数而不是指针。
  - [x] Context：
    - [x] propagateCancel：用以传递父子 context 之间的 cancel 事件。假如 parent 是 cancelCtx 的类型，则加锁，并将子 context 添加到 parent 的 children map 当中；假如 parent 不是 cancelCtx 类型，但又存在 cancel 的能力（比如用户自定义实现的 context），则启动一个协程，通过多路复用的方式监控 parent 状态，倘若其终止，则同时终止子 context，并透传 parent 的 err。
    - [x] 启动 time.Timer，设定一个延时时间，即达到过期时间后会终止该 timerCtx，并返回DeadlineExceeded 的错误。
    - [x] 假如当前 valueCtx 的 key 等于用户传入的 key，则直接返回其 value；假如不等，则从 parent context 中依次向上寻找。
    - [x] 一个 valueCtx 实例只能存一个 kv 对，因此 n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费；基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；
  - [x] Map：
    - [x] 并发读没有问题；读的时候发现其他 goroutine 在并发写，抛出 fatal error；写的时候发现其他 goroutine 在并发写，抛出 fatal error。（引发 fatal error，是一种比 panic 更严重的错误，无法使用 recover 操作捕获）
    - [x] hmap；在map初始化时若容量过大会提前申请号一批溢出桶；bmap 就是 map 中的桶，可以存储 8 组 key-value 对的数据，以及一个指向下一个溢出桶的指针；
      tophash的作用（key的哈希值高8位）：1、加速查找，若tophash!=targetTopHash立刻跳过，无需比较key，若匹配再比较实际key。2、状态标记，tophash=0：当前槽位及其之后的所有槽位（包括当前桶和所有链接的溢出桶）都为空，tophash=1：仅当前槽位为空，后续槽位可能有数据。
    - [x] 当 key-value 总数/桶数组长度 > 6.5 时发生增量扩容，桶数组长度增长为原值的两倍（数据迁移不是一次性完成，而是分散到后续每次map操作中逐步进行，避免瞬时性能抖动）；当总溢出桶数量大于等于 桶数组长度时，发生等量扩容（桶整理），桶数组长度保持为原值（主要针对删除后形成的空槽）；
    - [x] 初始化Map时，根据预分配容量hint求得桶数组长度指数B（不超过6.5这个负载因子的最大值B）
    - [x] 读流程：检查对应的桶是否迁移完成，如果未迁移完则从old桶遍历，如果迁移完了则从new桶遍历
    - [x] 写流程：插入前判断是否达成扩容条件；当每次触发写、删操作时，会为处于扩容流程中的 map 完成两组桶的数据迁移，1、一组桶是当前写、删操作所命中的桶；2、另一组桶是，当前未迁移的桶中，索引最小的那个桶。
  - [ ] sync.Map：
- [x] GMP：
  - [x] 从全局队列取G：   n=min(len(GQ)/GOMAXPROCS + 1, cap(LQ)/2)，
    从其他本地队列取一半：保留一半任务维持局部性，平滑负载减少调度波动
    自旋线程的最大限制=P
  - [x] P取值过大的问题分析
  - [x] 每执行61次本地队列就尝试从全局队列取G：本地队列无锁，同时避免饥饿，61是质数降低锁冲突
- [x] GC：
  - [x] 1.3的标记-清除法，大概几百毫秒。
  - [x] 三色标记法：将对象不断染黑的过程，剩下的白色将被回收。如果开始之前加上STW，再扫描确定黑白对象后再放开STW，很明显GC的性能太低了。
  - [x] 同时满足两个条件，将导致对象误删除，1、白色被挂在黑色下，2、灰色丢了该白色。所以只要破坏了上面两个条件之一就可以避免全局的STW。提出了强-弱三色不变式，1、强三色不变式：不允许黑色引用白色，2、弱三色不变式：所有被黑色引用的白色都处于灰色保护状态。
  - [x] 为了遵循上面两个不变式，演进了两个屏障方式：插入屏障、删除屏障。1、插入屏障：A对象引用B对象时B对象被标记为灰色，2、删除屏障：被删除的对象被标记为灰色。栈不触发插入屏障，导致会对栈重新进行扫描并启动STW。
  - [x] 1.5仅使用了插入屏障，从几百毫秒降到了几十毫秒级别。
  - [x] 1.8使用混合写屏障，1、GC开始栈对象全部标记为黑色，2、栈上新对象标记为黑色，3、删除/添加对象标记为灰色。
  - [x] 1.8 共两次STW，实现亚毫秒停顿。
- [ ] pprof分析，结合ants协程池+pool进行优化：pod隔一段时间重启，发现未释放导致内存不断升高
  - [x] sync.Pool：复用对象，减少内存分配、GC压力，并发安全（private与shared字段）；local与victim（经一轮GC回收后暂存的上一轮local）两个长度为P的poolLocal数组；Get、Put操作，回收机制（最多两轮gc，pool内的对象资源将会全被回收）。可能存在：内存泄漏与内存浪费
  - [x] 为什么使用ants：协程本身就很轻便了，为什么还用池子呢？1、当任务执行成本与协程创建/销毁成本接近时 2、统一控制协程数量以及统一释放协程。
  - [ ] pprof：
- [x] errgroup使用：扩展了WaitGroup的功能，增加上下文取消、限制并发数等功能
- [x] singleflight使用



go基础：

- [x] 反射
- [x] 泛型：
  - [x] 泛型类型、泛型receiver、泛型函数、泛型方法不支持、泛型接口。
  - [x] 接口定义从方法集到类型集。
  - [x] 接口分为两种类型：基本接口（接口定义中只有方法）、一般接口（具有类型，只能用于类型约束，不得用于变量定义）。
- [ ] 



goroutine泄露案例，channel使用不当引发的泄露问题，怎么发现、怎么定位、怎么解决。

内存泄漏因为闭包引起的。

go的gc介绍、什么场景会gc、gc的缺点、如何减少gc

1000个goroutine进行阻塞系统调用会怎么样？（小红书收藏）

讲讲go的内存分配机制（小红书收藏）

改造Once，sync包的Once的Do方法传入的函数为无参数无返回值，改造Once为可传入带error返回值的函数，如果f返回错误则不会更改done字段。



# TODO

- [ ] tcp粘包，http、http2.0与rpc、websocket：https://mp.weixin.qq.com/s/oEDo9-0WPi1-ZMOF-9H9vA，可看网络合集。
- [ ] k8s的网络



# K8S相关

- [ ] 容器网络基本操作
- [ ] 



cgroup和namespace的原理

k8s中request和limit实现原理

k8s pod创建过程中csi、cni在哪里调用的

k8s创建pod的全流程



# 网络相关

网络基础：

- [x] IP地址与硬件地址、ARP协议
  - [x] 主机ARP高速缓存中存放本局域网上的各主机和路由器的IP地址到硬件地址的映射表，并且表还经常动态更新。注意：APR是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。
  - [x] 只要主机或者路由器要和本网络上的另一个已知IP地址的主机或者路由器进行通信，APR协议就会自动地把这个IP地址解析为链路层所需要的硬件地址。
  
- [x] IP数据报格式
  - [x] 首部固定长度20字节，首部最大长度60字节；IP数据报总长度最大65535字节；数据链路层规定了数据帧中数据字段的最大长度MTU；当IP数据报被封装成链路层的帧时，此数据报的总长度一定不能规定的MTU值，过长的数据报需要进行分片处理。IP层无法提供可靠传输。
  - [x] IP层转发分组的流程：查找路由表、用ARP得到硬件地址、把硬件地址写入MAC帧的首部。
  - [x] 使用子网时分组的转发
  
- [x] TCP报文段：

  - [x] TCP特点：1、面向连接的，2、提供可靠交付：无差错、不丢失、不重复、按序到达，3、全双工通信：双方在任何时候都能发送数据，两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。4、面向字节流：TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。
  - [x] 因为TCP是面向字节流的，所以数据之间没有任何边界，这就是所谓的粘包问题。纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些自定义的规则，用于区分消息边界。
  - [x] TCP的连接管理

- [x] UDP用户数据报：UDP是无连接的，是面向报文的；也就是说应用层交给UDP多长的报文，既不合并也不拆分，而是保留这些报文的边界。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。

  

- [ ] HTTP2.0
  - [x] 头部压缩：使用HPACK算法压缩头部，主要包括静态字典、动态字典、Huffman编码。
  - [x] 二进制帧、并发传输、服务器主动推送资源。
  
- [ ] RPC

- [ ] 





## 虚拟网络

- [x] 容器网络基础知识：
  - [x] ip netns add/exec 等操作处理network namespace之间的通信；每个netns都有自己的网卡、路由表、ARP 表、iptables 等。
  - [x] 使用bridge连接不同的namespace。
  - [x] 使用bridge的路由模式连通namespace与host：为vbridge-0增加ip地址后，主机的路由表上自动创建了一条记录，vbridge-0启用了路由模式后，可以看作一个交换机与路由器的合体；对于blue和red而言，可以把vbridge-0作为它们通向外网的gateway。
  - [x] 使用NAT连通namespace与公网：MASQUERADE（SNAT的动态化）、DNAT。
- [x] LVS基本学习



# 中间件

## ETCD

- [ ] 



## Redis

- [ ] 



## Mysql



## Kafka



## ES