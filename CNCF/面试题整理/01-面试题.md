

# 热点题目复习

- [ ] go并发：
  - [x] Mutex：本质是锁标记位，正常模式与饥饿模式，模式切换条件（1毫秒与最后一个waiter），自旋，CAS，不可重入，不可复制（vet检查锁复制：通过实现了Locker接口），unsafe包获取锁信息。
  - [x] RWMutex：本质是针对读多写少的情况、是写优先的读写锁，使用Mutex+信号量，readerCount通过反转实现（当前reader的数量、负数表示有writer竞争锁），不可复制
  - [x] WaitGroup：本质任务编排用来等待一组协程完成任务、通过Add+Done+Wait，state(高32位+低32位)+信号量。
  - [x] Cond：本质是等待/通知机制，通过Broadcast+Signal+Wait，Wait必须加锁校验等待条件（Wait源码中先解锁然后阻塞，最后加锁）。
  - [x] Channel：可用做数据传递、信号通知（无缓冲1：1、1：n的通知机制）、任务编排、锁；底层原理：环形队列、队列的读写index、阻塞的读协程队列waitq、阻塞的写协程队列waitq、写流程（写时存在阻塞读协程、无阻塞读有空间、无空间）、读流程（已关闭无元素、读时有阻塞写协程、读时缓存区无元素）；与Cond的对比。
  - [x] Atomic：主要是Value的底层实现，引出禁止抢占与抢占调度，引出接口实现原理；
  - [x] Unsafe包：核心是提供了直接操作内存地址的能力，其中任何类型的指针可以转换为Pointer，Pointer也可以转换回任何类型的指针；Pointer具有内存保护可以阻止对象被回收，而uintptr无保护GC把它仅仅当成是整数而不是指针。
  - [ ] Context：
- [x] GMP：
  - [x] 从全局队列取G：   n=min(len(GQ)/GOMAXPROCS + 1, cap(LQ)/2)，
    从其他本地队列取一半：保留一半任务维持局部性，平滑负载减少调度波动
    自旋线程的最大限制=P
  - [x] P取值过大的问题分析
  - [x] 每执行61次本地队列就尝试从全局队列取G：本地队列无锁，同时避免饥饿，61是质数降低锁冲突
- [ ] GC：
- [ ] pprof分析，结合ants协程池+pool进行优化：pod隔一段时间重启，发现未释放导致内存不断升高
  - [x] sync.Pool：复用对象，减少内存分配、GC压力，并发安全（private与shared字段）；local与victim（经一轮GC回收后暂存的上一轮local）两个长度为P的poolLocal数组；Get、Put操作，回收机制（最多两轮gc，pool内的对象资源将会全被回收）。可能存在：内存泄漏与内存浪费
  - [x] 为什么使用ants：协程本身就很轻便了，为什么还用池子呢？1、当任务执行成本与协程创建/销毁成本接近时 2、统一控制协程数量以及统一释放协程。
  - [ ] pprof：
- [x] errgroup使用：扩展了WaitGroup的功能，增加上下文取消、限制并发数等功能
- [ ] singleflight使用：



# K8S相关

- [ ] 容器网络基本操作
- [ ] 







cgroup和namespace的原理

k8s中request和limit实现原理

k8s pod创建过程中csi、cni在哪里调用的

k8s创建pod的全流程





# GO相关



go的gc介绍、什么场景会gc、gc的缺点、如何减少gc

1000个goroutine进行阻塞系统调用会怎么样？（小红书收藏）

讲讲go的内存分配机制（小红书收藏）

改造Once，sync包的Once的Do方法传入的函数为无参数无返回值，改造Once为可传入带error返回值的函数，如果f返回错误则不会更改done字段。



# 基础相关

Linux的进程调度算法



