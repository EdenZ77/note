在 Go 语言中，包是组织代码的一种基本方式，用于管理和复用代码。Go 提供了强大的包机制，通过包可以将代码分成若干模块，以提高代码的可读性、可复用性和可维护性。在 Go 项目开发中，经常会用到各种类型的包，其中有一些 Go 包会被频繁使用到，并且在 Go 项目开发中需要进行适配。

高频使用的 Go 包有很多，例如：cobra、viper、pflag、gorm、gin、grpc、zap、logrus、uuid、resty、casbin、jwt-go、validator、lru 等。上述常用的 Go 包，在项目开发中一般不需要做二次适配便可直接使用。但是有些基础的 Go 包需要二次开发或者从零开发才能够满足 Go 项目的需求。最常见的需要二次适配的 Go 包是日志包和错误包。

本节课就来详细介绍下如何定制化开发一个满足项目需求的日志包和错误包。

## 如何记录日志

在开发日志包之前，需要先明白代码中，是如何记录日志的。之后，根据记录日志的需求特点开发满足项目需要的日志包。记录日志通常涉及到以下几个方面：

- 日志记录方式；
- 日志记录规范；
- 日志保存方式。

### 日志记录方式

在 Go 项目开发中，通过日志包来记录日志。所以，在项目开发之前，需要准备一个易用、满足需求的 Go 日志包。准备日志包的方式有以下三种：

- 使用开源日志包：使用开源的日志包，例如 log、glog、logrus、zap 等。Docker、Cilium、Tyk 等项目使用了 logrus，etcd 则使用了 log 和 zap；
- 定制化开源日志包：基于开源日志包封装一个满足特定需求的日志包。例如，Kubernetes 使用的 klog 是基于 glog 开发的。有些项目封装的日志包还会兼容多种类别的 Logger；
- 自研日志包：根据需求，从零开发一个日志包。

#### 使用开源日志包

如果对记录日志没有特殊需求，并且已经有优秀的开源日志包可供选择，那么直接使用原生的开源日志包，无需封装或自行研发。这样不仅可以充分利用开源日志包的功能，还能随开源日志包进行功能升级与迭代。最重要的是，这种方式能够显著提高开发效率，减少日志包维护的工作量。

然而，在以下情景下，可以考虑封装或自研一个新的日志包：

- 需要满足定制化需求，而现有的开源日志包无法满足这些需求；
- 拥有较强的研发能力，能够开发出在性能或功能上优于当前开源日志包的日志包；
- 有定制化的日志记录需求。

目前已有许多开源日志包，社区比较受欢迎的开源日志包有 logrus、zap、zerolog、apex/log 等。其中最受欢迎的两个日志包是 logrus 和 zap。

logrus 功能强大、使用简单，不仅实现了日志包的基本功能，还有很多高级特性，适合一些大型项目，尤其是需要结构化日志记录的项目。因为 logrus 封装了很多能力，性能一般。

zap 提供了很强大的日志功能，性能高，内存分配次数少，适合对日志性能要求很高的项目。另外，zap 包中的子包 zapcore，提供了很多底层的日志接口，适合用来做二次封装。

在企业级 Go 应用开发时，通常会在 logrus、zap 二者之间进行选择，选择建议如下：

- 如果对性能要求不高，更加注重日志包的功能和易用性，可以选择 logrus；
- 如果对性能有较高要求，同时希望日志包更加灵活和可定制化，可以选择 zap。

miniblog 项目选择了 zap，因为 zap 具有较高的性能，同时使用便捷，并易于定制。实际上，zap 也可以作为今后 Go 项目开发的首选日志包。

#### 定制化开源日志包

在实际开发中，基于开源日志包开发定制化日志包的主要原因在于，开源日志包无法完全满足特定需求。例如，kubernetes 团队由于 glog 存在缺陷且已停止维护，基于 glog 重新开发了 klog。此外，一些团队需要在日志中添加固定字段（如用户名、请求 ID 等），因此对开源日志包进行了改造；还有一些团队需要根据日志内容触发回调逻辑，而这类需求通常难以通过现有的开源日志包实现，因此选择定制化开发。

在企业级应用开发过程中，出于多种需求，定制化开发新的日志包是一种常见的现象。然而，在决定定制化开发新的日志包之前，应当认真思考以下问题：是否确实需要定制化开发一个新的日志包？现有的开源日志包是否完全无法满足需求？

#### 自研日志包

如果前两种方式无法满足日志记录需求，可以考虑自主研发一个日志包。然而，自主研发日志包需要较高的研发能力且开发周期较长，因此并不推荐，这里不作详细介绍。

### 日志记录规范

记录日志实际上就是遵循项目制定的日志规范，通过调用日志包提供的方法来记录日志。

miniblog 也制定了相应的日志规范，具体规范内容见 docs/devel/zh-CN/conversions/logging.md。该日志规范可以在后续的开发过程中根据需求不断更新和迭代。在 miniblog 的日志规范中，有以下两点规范需要注意：

- 错误日志应在最初发生错误的位置打印。这样做一方面可以避免上层代码缺失关键的日志信息（因为上层代码可能无法获取错误发生处的详细信息），另一方面可以减少日志漏打的情况（距离错误发生位置越远，越容易忽略错误的存在，从而导致日志未被打印）；
- 当调用第三方包的函数或方法报错时，需要在错误处打印日志，例如：

```go
if err := os.Chdir("/root"); err != nil {
    log.Errorf("change dir failed: %v", err)
}
```

对于嵌套的 Error，可在 Error 产生的最初位置打印 Error 日志，上层如果不需要添加必要的信息，可以直接返回下层的 Error。例如：

```go
package main

import (
    "flag"
    "fmt"
    "github.com/golang/glog"
)

func main() {
    flag.Parse()
    defer glog.Flush()
    if err := loadConfig(); err != nil {
        glog.Error(err)
    }
}

// 正例：直接返回错误
func loadConfig() error {
    return decodeConfig() // 直接返回
}

// 正例：如果需要基于函数返回的错误，封装更多的信息，可以封装返回的 err。否则，建议直接返回 err
func decodeConfig() error {
    if err := readConfig(); err != nil {
        // 添加必要的信息，用户名称
        return fmt.Errorf("could not decode configuration data for user %s: %v", "colin", err) 
    }
    return nil
}

func readConfig() error {
    glog.Errorf("read: end of input.")
    return fmt.Errorf("read: end of input")
}
```

在最初产生错误的位置打印日志，可以很方便地追踪到错误产生的根源，并且错误日志只打印一次，可以减少重复的日志打印，减少排障时重复日志干扰，也可以提高代码的简洁度。当然，在开发中也可以根据需要对错误补充一些有用的信息，以记录错误产生的其他影响。

### 日志保存方式

我们可以将日志保存到任意需要的位置，常见的保存位置包括以下几种：

- **标准输出：**通常用于开发和测试阶段，主要目的是便于调试和查看；
- **日志文件：**这是生产环境中最常见的日志保存方式。保存的日志通常会被 Filebeat、Fluentd 等日志采集组件收集，并存储到 Elasticsearch 等系统中；
- **消息中间件：**例如 Kafka。日志包会调用 API 接口将日志保存到 Kafka 中。这种方式较少被采用。

当前比较受欢迎的日志包（如 zap、logrus 等）都支持将日志同时保存到多个位置。例如，miniblog 项目的日志包底层封装了 zap，zap 支持同时将日志输出到标准输出和日志文件中。

如果应用采用容器化部署，建议优先将日志输出到标准输出。容器平台通常具备采集容器日志的能力，采集日志时可以选择从标准输出采集或从容器内的日志文件中采集。如果选择从日志文件采集，则需要配置日志采集路径；而如果选择从标准输出采集，则无需额外配置，可以直接复用容器平台现有的能力。在 Kubernetes 最新的日志设计方案中，也建议应用直接将日志输出到标准输出。

## miniblog 日志包开发

为了给你详细展示日志包的设计和实现过程，本节会展示如何从零开发一个日志包，本节最终代码位于 [feature/s06](https://github.com/onexstack/miniblog/tree/feature/s06) 分支。

在 Go 项目开发中，通常会因为以下原因，选择从零开发一个日志包：

- 为了方便通过日志进行问题排查，需要在每一行日志中打印一些自定义字段，例如请求 ID、用户名等。虽然目前许多日志包（如 logrus、zap 等）都支持添加日志字段，但使用方式较为繁琐，且代码可读性较差；
- 随着项目功能的不断迭代，未来可能会出现特殊的日志需求。因此，开发一个定制的日志包可以为未来的技术扩展做好准备，预留足够的扩展空间；
- logrus、zap 等日志包功能丰富，但许多功能在项目开发中并不需要。因此，我考虑定制一个精简的日志包。精简的日志包不仅易于使用，同时其有限的功能也有助于规范日志记录（功能过多可能导致难以实现规范化和统一化）。

### 日志包设计方式

在 Go 项目开发中，日志包实现方法有很多，但大都遵循以下设计方式：

- 设计日志接口，通常命名为 Logger，日志接口中定义需要的日志方法；
- 定义日志级别类型，并定义日志级别；
- 定义日志结构体类型，例如：xxxLogger。xxxLogger 中包括需要的字段，例如日志级别。xxxLogger 通常会实现一个打印日志的基础方法。Logger 接口中定义的方法，均通过调用基础方法实现日志打印。xxxLogger 也可以包含其他日志包的日志实例，从而在输出日志时，调用其他日志包的方法进行输出；
- 实现创建 xxxLogger 实例的 New 方法；
- xxxLogger 结构体类型实现 Logger 接口中定义的方法。

遵循上述日志设计方法的代码示例如代码清单 6-1 所示。

```go
package main

import (
    "fmt"
    "strings"
)

// 定义日志级别
const (
    DebugLevel = iota
    InfoLevel
    WarnLevel
    ErrorLevel
)

// Logger 定义日志接口，包含常用日志方法.
type Logger interface {
    Debug(msg string)
    Info(msg string)
    Warn(msg string)
    Error(msg string)
}

// customLogger 是 Logger 接口的具体实现.
type customLogger struct {
    level  int    // 日志级别
    prefix string // 日志前缀
}

// New 创建一个 customLogger 实例.
func New(level int, prefix string) Logger {
    return &customLogger{level: level, prefix: prefix}
}

// logMessage 是内部方法，根据日志级别打印日志.
func (l *customLogger) logMessage(level int, levelStr string, msg string) {
    if level >= l.level { // 只有当日志级别大于等于设定的级别时才打印
        fmt.Printf("[%s] %s: %s\n", strings.ToUpper(levelStr), l.prefix, msg)
    }
}

// Debug 实现 Logger 接口的 Debug 方法.
func (l *customLogger) Debug(msg string) {
    l.logMessage(DebugLevel, "debug", msg)
}

// Info 实现 Logger 接口的 Info 方法.
func (l *customLogger) Info(msg string) {
    l.logMessage(InfoLevel, "info", msg)
}

// Warn 实现 Logger 接口的 Warn 方法.
func (l *customLogger) Warn(msg string) {
    l.logMessage(WarnLevel, "warn", msg)
}

// Error 实现 Logger 接口的 Error 方法.
func (l *customLogger) Error(msg string) {
    l.logMessage(ErrorLevel, "error", msg)
}

func main() {
    // 创建一个日志实例，日志级别为 Info
    logger := New(InfoLevel, "MyApp")

    // 根据不同级别打印日志
    logger.Debug("This is a debug message") // 不会打印（级别低于 Info）
    logger.Info("This is an info message")  // 会打印
}
```

miniblog 项目的日志包也遵循上述日志设计方式。

### miniblog 日志包开发

在定制开发日志包之前，应该先选择一个合适的开源日志包，并在其基础上进行封装。miniblog 项目选择 zap 作为基础日志包。因此，在定制开发之前，需要熟悉 zap 的使用方法，可参考相关的 zap 使用文档进行学习。

定制开发日志包的步骤如下：

1. 定义日志接口；
2. 定义日志类型；
3. 编写创建日志实例函数；
4. 实现日志实例化代码；
5. 实现日志接口。

#### 定义日志接口

在开发日志包之前，需要根据日志记录的需要定义日志接口，接口中包含需要用到的日志记录方法。在设计日志接口时，需要考虑以下两点：

- **日志级别：**在记录日志时，按严重性由低到高通常包括 Debug、Info、Warn、Error、Panic、Fatal 级别。Warn 级别在有些日志包中也叫 Warning 级别；
- **日志记录方法：**每个日志级别，根据记录方式，又包括非格式化记录、格式化记录和结构化记录三种方式。形如 `Info(msg string)` 的方法为非格式化记录方式。形如 `Infof(format string, args ...any)` 的方法为格式化记录方式。形如 `Infow(msg string, kvs ...any)` 的方法为结构化记录方式。Infow 方法名中的 w 代表“with”，即“带有”额外的上下文信息。这些方法允许你在日志消息后面附加额外的键值对（key-value），从而提供更详细的上下文信息。

miniblog 在设计时，为了满足项目不同日志级别的记录需求，实现了 Debug、Info、Warn、Error、Panic、Fatal 级别的记录方法。

在 Go 项目开发中，建议的日志记录方式为结构化记录方式。格式化记录方式可以通过结构化记录方式来替代，例如：`log.Infof("Failed to create user: %s", username)` 可替换为 `log.Infow("Failed to create user", "username", username)`。

另外，结构化记录方式也可以替代非结构化记录方式，例如 `log.Infof("Failed to create user")` 可替换为 `log.Infow("Failed to create user")`。

所以，miniblog 项目为了方便日志记录，降低开发者理解日志记录方法的负担，只实现了结构化记录方法。最终 miniblog 日志接口定义（位于文件 [internal/pkg/log/log.go](https://github.com/onexstack/miniblog/blob/feature/s06/internal/pkg/log/log.go#L19) 中）如代码清单 6-2 所示。

```go
// Logger 定义了 miniblog 项目的日志接口。
// 该接口包含了项目中支持的日志记录方法，提供对不同日志级别的支持。
type Logger interface {
    // Debugw 用于记录调试级别的日志，通常用于开发阶段，包含详细的调试信息。
    Debugw(msg string, kvs ...any)

    // Infow 用于记录信息级别的日志，表示系统的正常运行状态。
    Infow(msg string, kvs ...any)

    // Warnw 用于记录警告级别的日志，表示可能存在问题但不影响系统正常运行。
    Warnw(msg string, kvs ...any)

    // Errorw 用于记录错误级别的日志，表示系统运行中出现的错误，需要开发人员介入处理。
    Errorw(msg string, kvs ...any)

    // Panicw 用于记录严重错误级别的日志，表示系统无法继续运行，记录日志后会触发 panic。
    Panicw(msg string, kvs ...any)

    // Fatalw 用于记录致命错误级别的日志，表示系统无法继续运行，记录日志后会直接退出程序。
    Fatalw(msg string, kvs ...any)

    // Sync 用于刷新日志缓冲区，确保日志被完整写入目标存储。
    Sync()
}
```

将日志包 log 放置在 `internal/pkg` 目录下的原因在于，日志包封装了一些定制化的逻辑，不适合对外暴露，所以不适合放在 `pkg/` 目录下。但是日志包又是项目内的共享包，所以需要放在 `internal/pkg` 目录下。

miniblog 为了降低开发者使用日志时的理解、学习成本，仅实现了核心的日志方法。这种仅实现核心日志功能的设计方式牺牲了一些功能和灵活性，但带来了更高的一致性。

通过定义 Logger 接口，可以体现接口即规范的编程哲学。这意味着，通过 Logger 接口可以清晰地表明 zapLogger 需要实现哪些方法，并明确日志调用者可调用哪些方法。在 Go 项目中，通常将日志接口命名为 Logger。

#### 定义日志类型

在文件 `internal/pkg/log/log.go` 中，通过以下代码定义了一个日志类型：

```go
// zapLogger 是 Logger 接口的具体实现. 它底层封装了 zap.Logger.
type zapLogger struct {
    z *zap.Logger
}
```

将日志类型定义为不可导出的 zapLogger 类型是因为开发者在使用日志包时，不需要关注日志具体的实现细节，只需要调用日志接口包含的方法即可。定义为不可导出的类型，有利于日志类型的封装和维护，屏蔽实现细节。

zapLogger 日志类型包含了 `*zap.Logger` 类型的字段 `z`，是因为 zapLogger 底层会调用 `*zap.Logger` 类型实例 `z` 提供的日志记录方法。

#### 编写创建日志实例函数

一个日志包通常包含两类 zapLogger 对象：一类是全局对象，另一类是局部对象。全局对象便于通过类似 `log.Infow()` 的方式直接调用，而局部对象则方便传入不同参数以创建自定义的 Logger。为了实现这一目标，通常需要实现以下两种函数：

```go
// New 根据提供的 Options 参数创建一个自定义的 zapLogger 对象.
// 如果 Options 参数为空，则会使用默认的 Options 配置.
New(opts *Options) *zapLogger
// Init 初始化全局的日志对象.
Init(opts *Options)
```

Init 函数通过调用 New 函数来创建 `*zapLogger` 类型的实例，并将其赋值给类型为 `*zapLogger` 的全局变量 std。创建一个全局变量的原因将在后文说明。

New 和 Init 函数中的 Options 结构体类型包含了日志的配置项。在开发初期，可以将 Options 定义为空结构体，其字段后面根据需要陆续添加。

此外，根据 Go 代码开发的最佳实践，建议给 Options 结构体添加一个 `NewOptions() *Options` 函数，用于创建带有默认值的 `*Options` 对象。通过这种方式，简化创建日志实例时的配置。

有些代码实现中，会将 Options 命名为 LoggerOptions，建议直接使用简洁的 Options 作为名称。因为通过 `<包名.结构体名>` 的调用方式，已经能够明确 Options 是一个日志配置结构体。

#### 实现日志实例化代码

实例化 `*zapLogger` 类型的日志，其实就是实例化 `*zapLogger` 类型中的各个字段。`*zapLogger` 类型只包含了 `*zap.Logger` 类型的字段。所以，实例化 `*zapLogger` 类型，其实就是实例化 `*zap.Logger` 类型。本节会详细介绍日志实例化代码的开发及思考过程，以使你了解项目开发中，如何去实现一个功能。

有三种方法可以用来调研社区其他开发者的代码实现：阅读 zap 官方文档、GitHub 查找相关示例仓库、GitHub 查找相关实现代码。

......

#### 实现日志接口

New 方法会实例化并返回 `*zapLogger` 类型的实例。接下来就可以给 `*zapLogger` 结构体添加 Logger 接口中定义的方法。`*zapLogger` 结构体类型中包含了 `*zap.Logger` 类型的实例 `z`。可以使用 `z` 实例中提供的各类日志方法来封装需要的 Logger 方法。

```go
// Debugw 输出 debug 级别的日志.
func Debugw(msg string, kvs ...any) {
    std.Debugw(msg, kvs...)
}

func (l *zapLogger) Debugw(msg string, kvs ...any) {
    l.z.Sugar().Debugw(msg, kvs...)
}
```

`func (l *zapLogger) Debugw(msg string, kvs ...any)` 方法调用了 `*zap.Logger` 的 `Sugar().Debugw()` 方法，用于以结构化方式输出 debug 级别的日志。

为了便于通过 `log.Debugw()` 输出日志，代码实现了一个包级别函数 Debugw。该函数通过调用 `*zapLogger` 类型的全局变量 std 的 `Debugw(msg string, kvs ...any)` 方法，输出 debug 级别的日志。这里要注意，Debugw 函数内部应该直接调用 `std.Debugw(msg, kvs...)`，而非 `std.z.Sugar().Debugw(msg, kvs...)`，这样可以复用 `*zapLogger` 类型的 Debugw 方法现在以及未来可能的实现逻辑。

同理，我们可以为 `*zapLogger` 实现 Logger 接口中定义的其他方法。

为了在编译阶段确保 `*zapLogger` 实现了 Logger 接口，可以添加以下变量定义：

```go
var _ Logger = (*zapLogger)(nil)
```

通过上述变量赋值，如果 `*zapLogger` 未实现 Logger 接口，代码将在编译阶段报错。此类编程技巧在 Go 项目开发中被广泛使用。

### miniblog 日志包测试

在开发完 Go 包之后，通过给 log 包添加测试用例，来展示如何使用 log 包。

```go
package log_test

import (
    "testing"
    "time"

    "github.com/onexstack/miniblog/internal/pkg/log"
)

func TestLogger(t *testing.T) {
    // 自定义日志配置
    opts := &log.Options{
        Level:             "debug",            // 设置日志级别为 debug
        Format:            "json",             // 设置日志格式为 JSON
        DisableCaller:     false,              // 显示调用日志的文件和行号
        DisableStacktrace: false,              // 允许打印堆栈信息
        OutputPaths:       []string{"stdout"}, // 将日志输出到标准输出
    }

    // 初始化全局日志对象
    log.Init(opts)

    // 测试不同级别的日志输出
    log.Debugw("This is a debug message", "key1", "value1", "key2", 123)
    log.Infow("This is an info message", "key", "value")
    log.Warnw("This is a warning message", "timestamp", time.Now())
    log.Errorw("This is an error message", "error", "something went wrong")

    // 注意：Panicw 和 Fatalw 会中断程序运行，因此在测试中应小心使用。
    // 可以注释掉以下两行进行测试，或者在单独的环境中运行。
    // log.Panicw("This is a panic message", "reason", "unexpected situation")
    // log.Fatalw("This is a fatal message", "reason", "critical failure")

    // 确保日志缓冲区被刷新
    log.Sync()
}
```

将上述代码保存在 `internal/pkg/log/example_test.go` 文件中，执行以下命令来运行示例测试，并查看日志调用结果：

```shell
$ cd internal/pkg/log/
$ go mod tidy
$ go test -run TestLogger$
{"level":"debug","timestamp":"2025-02-01 12:05:20.299","caller":"log/example_test.go:30","message":"This is a debug message","key1":"value1","key2":123}
{"level":"info","timestamp":"2025-02-01 12:05:20.299","caller":"log/example_test.go:31","message":"This is an info message","key":"value"}
{"level":"warn","timestamp":"2025-02-01 12:05:20.300","caller":"log/example_test.go:32","message":"This is a warning message","timestamp":"2025-02-01 12:05:20.300"}
{"level":"error","timestamp":"2025-02-01 12:05:20.300","caller":"log/example_test.go:33","message":"This is an error message","error":"something went wrong"}
PASS
ok  github.com/onexstack/miniblog/internal/pkg/log0.007s
```

至此，miniblog 项目成功的开发了期望的 log 包，最终代码见 [feature/s06](https://github.com/onexstack/miniblog/tree/feature/s06) 分支。

### miniblog 日志包调用

在开发了基础的 log 包之后，可以使用 log 包在 miniblog 应用中打印日志。添加步骤包括日志包初始化和调用日志包方法打印日志。日志包初始化代码实现如代码清单 6-7 所示。

```go
import (
    ...
    "github.com/onexstack/miniblog/internal/pkg/log"
    ...
)
...
// run 是主运行逻辑，负责初始化日志、解析配置、校验选项并启动服务器。
func run(opts *options.ServerOptions) error {
    // 如果传入 --version，则打印版本信息并退出
    version.PrintAndExitIfRequested()
    
    // 初始化日志
    log.Init(logOptions())
    defer log.Sync() // 确保日志在退出时被刷新到磁盘
    ...
}

// logOptions 从 viper 中读取日志配置，构建 *log.Options 并返回.
// 注意：viper.Get<Type>() 中 key 的名字需要使用 . 分割，以跟 YAML 中保持相同的缩进.
func logOptions() *log.Options {
    opts := log.NewOptions()
    if viper.IsSet("log.disable-caller") {
        opts.DisableCaller = viper.GetBool("log.disable-caller")
    }
    if viper.IsSet("log.disable-stacktrace") {
        opts.DisableStacktrace = viper.GetBool("log.disable-stacktrace")
    }
    if viper.IsSet("log.level") {
        opts.Level = viper.GetString("log.level")
    }
    if viper.IsSet("log.format") {
        opts.Format = viper.GetString("log.format")
    }
    if viper.IsSet("log.output-paths") {
        opts.OutputPaths = viper.GetStringSlice("log.output-paths")
    }
    return opts
}
```

代码清单 6-7，实现了 [logOptions](https://github.com/onexstack/miniblog/blob/feature/s07/cmd/mb-apiserver/app/server.go#L120) 函数，用来从配置文件中读取日志配置，并返回 `*log.Options` 类型的实例。这里要注意只有设置了配置项时，才需要给 opts 变量的字段进行赋值，否则日志初始化时，可能会因为设置了不合法的零值造成日志初始化失败。

在 run 函数中，添加了 `log.Init(logOptions())` 函数调用，用来在应用运行时，初始化日志实例，并在 miniblog 应用退出时，调用 `log.Sync()` 将缓存中的日志写入磁盘中。

修改 `internal/apiserver/server.go` 文件，将其中的配置内容打印，替换成 log 包打印：

```go
// Run 运行应用.
func (s *UnionServer) Run() error {
    log.Infow("ServerMode from ServerOptions", "jwt-key", s.cfg.JWTKey)
    log.Infow("ServerMode from Viper", "jwt-key", viper.GetString("jwt-key"))

    select {}
    return nil
}
```

在 `$HOME/.miniblog/mb-apiserver.yaml` 配置文件中添加日志配置：

```yaml
...
# 日志配置
log:
  # 是否开启 caller，如果开启会在日志中显示调用日志所在的文件和行号
  disable-caller: false
  # 是否禁止在 panic 及以上级别打印堆栈信息
  disable-stacktrace: false
  # 指定日志级别，可选值：debug, info, warn, error, dpanic, panic, fatal
  # 生产环境建议设置为 info
  level: debug
  # 指定日志显示格式，可选值：console, json
  # 生产环境建议设置为 json
  format: json
  # 指定日志输出位置，多个输出，用 `逗号 + 空格` 分开。stdout：标准输出
  output-paths: [/tmp/miniblog.log, stdout]
```

执行以下命令测试 mb-apiserver 日志打印功能是否被正确添加：

```shell
$ make build
$ _output/mb-apiserver -c $HOME/.miniblog/mb-apiserver.yaml
{"level":"info","timestamp":"2025-02-01 12:12:02.943","caller":"apiserver/server.go:37","message":"ServerMode from ServerOptions","jwt-key":"Rtg8BPKNEf2mB4mgvKONGPZZQSaJWNLijxR42qRgq0iBb5"}
{"level":"info","timestamp":"2025-02-01 12:12:02.943","caller":"apiserver/server.go:38","message":"ServerMode from Viper","jwt-key":"Rtg8BPKNEf2mB4mgvKONGPZZQSaJWNLijxR42qRgq0iBb5"}
```

注意，上述是测试代码，在实际开发中，不应该在日志中打印密钥、密码等敏感信息。至此，miniblog 应用成功使用新开发的 log 包打印了日志，完整代码见 [feature/s07](https://github.com/onexstack/miniblog/tree/feature/s05https://github.com/onexstack/miniblog/tree/feature/s07) 分支。