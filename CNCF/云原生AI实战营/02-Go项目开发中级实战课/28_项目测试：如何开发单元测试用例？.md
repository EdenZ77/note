> https://www.liwenzhou.com/posts/Go/unit-test-0/

在包目录内，所有以`_test.go`为后缀名的源代码文件都是`go test`测试的一部分，不会被`go build`编译到最终的可执行文件中。

在`*_test.go`文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。

|   类型   |         格式          |              作用              |
| :------: | :-------------------: | :----------------------------: |
| 测试函数 |   函数名前缀为Test    | 测试程序的一些逻辑行为是否正确 |
| 基准函数 | 函数名前缀为Benchmark |         测试函数的性能         |
| 示例函数 |  函数名前缀为Example  |       为文档提供示例文档       |

`go test`命令会遍历所有的`*_test.go`文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。

# 单元测试函数

每个测试函数必须导入`testing`包，测试函数的基本格式（签名）如下：

```go
func TestName(t *testing.T){
    // ...
}
```

测试函数的名字必须以`Test`开头，可选的后缀名必须以大写字母开头，举几个例子：

```
func TestAdd(t *testing.T){ ... }
func TestSum(t *testing.T){ ... }
func TestLog(t *testing.T){ ... }
```

其中参数`t`用于报告测试失败和附加的日志信息。 `testing.T`的拥有的方法如下：

```go
func (c *T) Cleanup(func())
func (c *T) Error(args ...interface{})
func (c *T) Errorf(format string, args ...interface{})
func (c *T) Fail()
func (c *T) FailNow()
func (c *T) Failed() bool
func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})
func (c *T) Helper()
func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})
func (c *T) Name() string
func (c *T) Skip(args ...interface{})
func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})
func (c *T) Skipped() bool
func (c *T) TempDir() string
```

# go test

现在我们有多个测试用例，为了能更好的在输出结果中看到每个测试用例的执行情况，我们可以为`go test`命令添加`-v`参数，让它输出完整的测试结果。

```shell
root@debian:~/golang/src/github.com/onexstack/miniblog/internal/pkg/log# go test -v
=== RUN   TestLoggerMethods
{"level":"debug","timestamp":"2025-08-27 14:50:13.533","caller":"log/log_test.go:40","message":"debug message","key1":"value1"}
--- PASS: TestLoggerMethods (0.00s)
=== RUN   TestLoggerInitialization
--- PASS: TestLoggerInitialization (0.00s)
=== RUN   TestSync
--- PASS: TestSync (0.00s)
=== RUN   TestNewOptions
--- PASS: TestNewOptions (0.00s)
=== RUN   TestLogger
{"level":"debug","timestamp":"2025-08-27 14:50:13.533","caller":"log/example_test.go:30","message":"This is a debug message","key1":"value1","key2":123}
--- PASS: TestLogger (0.00s)
PASS
ok      github.com/onexstack/miniblog/internal/pkg/log  0.004s
```

在执行`go test`命令的时候可以添加`-run`参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被`go test`命令执行。

```shell
root@debian:~/golang/src/github.com/onexstack/miniblog/internal/pkg/log# go test -v  -run Options
=== RUN   TestNewOptions
--- PASS: TestNewOptions (0.00s)
PASS
ok      github.com/onexstack/miniblog/internal/pkg/log  0.004s
```

为了节省时间支持在单元测试时跳过某些耗时的测试用例。

```go
func TestTimeConsuming(t *testing.T) {
    if testing.Short() {
        t.Skip("short模式下会跳过该测试用例")
    }
    ...
}
```

当执行`go test -short`时就不会执行上面的`TestTimeConsuming`测试用例。

如果要执行测试 N 次可以使用 `-count N` 命令行选项：

```shell
root@debian:~/golang/src/github.com/onexstack/miniblog/internal/pkg/rid# go test -run TestResourceID_String -v
=== RUN   TestResourceID_String
--- PASS: TestResourceID_String (0.00s)
PASS
ok      github.com/onexstack/miniblog/internal/pkg/rid  0.008s
root@debian:~/golang/src/github.com/onexstack/miniblog/internal/pkg/rid# 
root@debian:~/golang/src/github.com/onexstack/miniblog/internal/pkg/rid# go test -run TestResourceID_String -v -count 2
=== RUN   TestResourceID_String
--- PASS: TestResourceID_String (0.00s)
=== RUN   TestResourceID_String
--- PASS: TestResourceID_String (0.00s)
PASS
ok      github.com/onexstack/miniblog/internal/pkg/rid  0.005s
```

## 默认执行

默认情况下，`go test`会执行：当前目录（包）下所有 `*_test.go`文件中的、符合特定命名规则的、且不需要特殊参数（如 `-bench`, `-short`）的函数。

主要包括以下两类：

1、单元测试函数 (Unit Tests)

- 函数命名：必须以 `Test`开头，后接第一个字母为大写的单词（例如 `TestXxx`）。
  - `func TestLogin(t *testing.T)`✅
  - `func TestCreateUser(t *testing.T)`✅
  - `func Testvalidate(t *testing.T)`❌ (开头是 Test，但后接字符不是大写)
- 签名：必须接收一个 `*testing.T`参数。

这些函数是 `go test`默认运行的核心。

2、示例函数 (Example Functions) - 如果它们存在

- 函数命名：必须以 `Example`开头。
  - `func Example()`✅
  - `func ExampleMyFunction()`✅
  - `func ExampleMyType()`✅
  - `func ExampleMyType_Method()`✅
- 作用：主要用于生成文档示例，并且如果示例代码中的 `// Output:`注释与实际输出不匹配，测试也会失败。`go test`会默认执行它们以验证其正确性。









# 子测试

在上面的示例中我们为每一个测试数据编写了一个测试函数，而通常单元测试中需要多组测试数据保证测试的效果。Go1.7+中新增了子测试，支持在测试函数中使用`t.Run`执行一组测试用例，这样就不需要为不同的测试数据定义多个测试函数了。

```go
func TestXXX(t *testing.T){
  t.Run("case1", func(t *testing.T){...})
  t.Run("case2", func(t *testing.T){...})
  t.Run("case3", func(t *testing.T){...})
}
```

假设我们有一个函数 `Add`，用于计算两个整数的和：

```go
// math.go
package math

func Add(a, b int) int {
    return a + b
}
```

现在我们想测试这个函数，包括正常情况和边界情况。使用子测试的方式如下：

```go
// math_test.go
package math

import "testing"

func TestAdd(t *testing.T) {
    // 定义测试用例表格
    tests := []struct {
        name     string   // 子测试名称
        a, b     int      // 输入参数
        expected int      // 期望结果
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, -1, -2},
        {"zero", 0, 0, 0},
        {"mixed", -1, 1, 0},
        {"large numbers", 1000000, 1000000, 2000000},
    }

    // 遍历所有测试用例
    for _, tt := range tests {
        // 使用 t.Run 执行子测试
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; expected %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

# 性能测试

性能测试也叫基准测试，是 Go 项目开发中，非常核心的测试用例类型。Go 开发者也需要掌握如何编写性能测试用例。

在 internal/pkg/rid/rid_test.go 文件中，新增 [BenchmarkResourceID_New](https://github.com/onexstack/miniblog/blob/feature/s27/internal/pkg/rid/rid_test.go#L46) 性能测试用例函数，代码如下：

```go
// 参数 b *testing.B是基准测试的上下文对象，提供了控制基准测试的方法
func BenchmarkResourceID_New(b *testing.B) {
    // 重置基准测试的计时器，ResetTimer()会忽略之前的所有操作耗时，从此刻开始计时
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        userID := rid.UserID
        _ = userID.New(uint64(i))
    }
}
```

`b.N`不是一个固定的数字，而是 Go 测试框架在运行时不断调整的一个变量。 调整的目的是让整个测试循环运行足够长的时间（约 1 秒），从而确保测量出的“每次操作耗时”这个指标是稳定和准确的。

性能测试函数的名称必须以 `Benchmark` 开头，例如 `BenchmarkXxx` 或 `Benchmark_Xxx`。默认情况下，`go test` 不会执行性能测试函数，需通过指定参数 `-test.bench` 来运行，`-test.bench` 后需接正则表达式，例如 `go test -test.bench=".*"` 表示运行所有性能测试函数。

在编写性能测试用例时，如果用例需要进行一些耗时的准备工作以测试目标函数，可以在准备工作完成后调用 `b.ResetTimer()` 方法重置计时器。

在 `internal/pkg/rid` 目录下，执行 `go test -test.bench=".*"` 命令来运行性能测试用例：

```shell
$ go test -test.bench=".*"
goos: linux
goarch: amd64
pkg: github.com/onexstack/miniblog/internal/pkg/rid
cpu: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz
BenchmarkResourceID_New-32      126488      9794 ns/op
PASS
ok  github.com/onexstack/miniblog/internal/pkg/rid1.355s
```

上述测试用例执行结果显示，BenchmarkResourceID_New 用例执行了 126488 次，每次执行的平均时间是 9794 纳秒。1.355s 表示测试用例总的执行时间。

在运行性能测试用例时，还可以通过 `-benchtime` 命令行选项，来指定性能测试用例的运行时间和运行次数，确保性能测试结果更加稳定，Go 会根据指定的运行时间和运行次数动态调整运行次数（`b.N`），以确保测试运行的总时长接近设定值。二者的指定方式如下：

- -benchtime=1x：指定运行次数为 1 次（可改为任意次数，例如 `-benchtime=10x` 表示运行 10 次）;
- -benchtime=5s：指定基准测试运行时间为 5 秒（可改为其他时间，例如 `-benchtime=100ms` 表示运行 100 毫秒）。

运行以下命令，并分别指定性能测试用例的运行时间为 30s、运行次数为 100000 次：

```shell
$ go test -benchtime=30s -test.bench="^BenchmarkResourceID_New$"
goos: linux
goarch: amd64
pkg: github.com/onexstack/miniblog/internal/pkg/rid
cpu: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz
BenchmarkResourceID_New-32     5219535      6910 ns/op
PASS
ok  github.com/onexstack/miniblog/internal/pkg/rid43.048s
$ go test -benchtime=100000x -test.bench="^BenchmarkResourceID_New$"
goos: linux
goarch: amd64
pkg: github.com/onexstack/miniblog/internal/pkg/rid
cpu: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz
BenchmarkResourceID_New-32      100000      7045 ns/op
PASS
ok  github.com/onexstack/miniblog/internal/pkg/rid0.714s
```



# 示例测试

在 Go 中，测试不仅仅是为了验证程序功能是否正确，还可以通过 Example 函数编写示例测试，向开发者展示代码的用法及其行为输出。这些示例代码通常易于理解，既可以作为文档的一部分，又可以作为功能验证的一种手段。Example 类型的测试函数以 Example 为前缀命名。

新建 [internal/pkg/rid/example_test.go](https://github.com/onexstack/miniblog/blob/feature/s27/internal/pkg/rid/example_test.go) 文件，代码如下：

```go
func ExampleResourceID_String() {
    // 定义一个资源标识符，例如用户资源
    userID := rid.UserID

    // 调用String方法，将ResourceID类型转换为字符串类型
    idString := userID.String()

    // 输出结果
    fmt.Println(idString)

    // Output:
    // user
}
```

上述代码是一个针对 ResourceID 类型的 String 方法的 Go 示例测试。`// Output:` 声明了程序的标准输出结果。如果输出结果无法固定，可以省略 `// Output:`，这样示例仅用于展示使用方法而不会验证输出。

# 模糊测试



# testify/assert

[testify](https://github.com/stretchr/testify)是一个社区非常流行的Go单元测试工具包，其中使用最多的功能就是它提供的断言工具——`testify/assert`。

我们在写单元测试的时候，通常需要使用断言来校验测试结果，但是由于Go语言官方没有提供断言，所以我们会写出很多的`if...else...`语句。而`testify/assert`为我们提供了很多常用的断言函数，并且能够输出友好、易于阅读的错误描述信息。



# 测试覆盖率分析

在编写单元测试时，应尽量考虑全面，覆盖所有可能的用例，但有时仍可能遗漏一些用例。Go 提供了 cover 工具用于统计测试覆盖率。测试覆盖率可以通过以下两条命令完成：

- `go test -coverprofile=cover.out`：这个命令会执行所有测试，同时统计哪些代码行被测试覆盖到了；
- `go tool cover -func=cover.out`：分析覆盖率文件。`-func=cover.out` 以函数为单位显示覆盖率统计信息（从 `cover.out`文件读取数据）

进入 `internal/pkg/rid` 目录，执行以下命令，来测试单元测试覆盖率：

```shell
$ cd internal/pkg/rid
$ go test -coverprofile=cover.out
$ go tool cover -func=cover.out
github.com/onexstack/miniblog/internal/pkg/rid/rid.go:25:       String                  100.0%
github.com/onexstack/miniblog/internal/pkg/rid/rid.go:30:       New                     100.0%
github.com/onexstack/miniblog/internal/pkg/rid/salt.go:18:      Salt                    100.0%
github.com/onexstack/miniblog/internal/pkg/rid/salt.go:29:      ReadMachineID           72.7%
github.com/onexstack/miniblog/internal/pkg/rid/salt.go:50:      readPlatformMachineID   75.0%
total:                                                          (statements)            81.8%
```

可以看到 `github.com/onexstack/miniblog/internal/pkg/rid` 包的单元测试覆盖率为 81.8%。

# 添加 Makefile 测试规则

在编写了测试用例之后，可以在项目根目录下通过运行以下命令，来运行所有的测试用例：

```shell
$ go test ./...
# ./ 表示当前目录
# ... 表示递归匹配当前目录下的所有子目录。(包括子目录的子目录，以此类推)
```

更建议的方法是添加一个 test 和 cover [Makefile](https://github.com/onexstack/miniblog/blob/feature/s27/Makefile#L110) 伪目标，分别用来运行整个项目的测试用例和单元测试覆盖率测试，test 和 cover 伪目标如下：

```shell
.PHONY: test
test: # 执行单元测试.
    @echo "===========> Running unit tests"
    @mkdir -p $(OUTPUT_DIR)
    @go test -race -cover \
        -coverprofile=$(OUTPUT_DIR)/coverage.out \
        -timeout=10m -shuffle=on -short \
        -v `go list ./...|egrep -v 'tools|vendor|third_party'`

.PHONY: cover
cover: test ## 执行单元测试，并校验覆盖率阈值.
    @echo "===========> Running code coverage tests"
    @go tool cover -func=$(OUTPUT_DIR)/coverage.out | awk -v target=$(COVERAGE) -f $(PROJ_ROOT_DIR)/scripts/coverage.awk
```



# 测试文件包名

项目结构如下：

```
myproject/
├── internal/
│   └── pkg/
│       └── log/                  # 这是一个目录（包目录）
│           ├── log.go            # 主源码文件，包声明为 `package log`
│           ├── log_test.go       # 测试文件，包声明为 `package log_test`
│   │   └── user/
│   │       ├── user.go           // package user
│   │       └── user_test.go      // package user_test
```

包名 `log_test`的含义：

1. **内部测试**：使用与被测试包相同的包名（如 `package log`）
2. **外部测试**：使用 `包名_test`的格式（如 `package log_test`）

虽然它们位于同一个文件系统目录下，但因为包声明不同，通过不同的包名实现了逻辑上的分离。

**为什么使用 `log_test`而不是 `log`**

1. **避免循环导入**：
   - 使用 `package log_test`意味着测试代码位于一个独立的包中
   - 这样可以避免测试代码与被测试包之间的循环依赖
2. **测试包的公共接口**：
   - 外部测试只能访问被测试包的导出（公共）标识符（以大写字母开头的函数、类型等）
   - 这确保了测试是从用户的角度进行的，只测试包公开的API
   - 有助于发现设计问题，比如哪些应该是公开的，哪些应该是私有的
3. **更真实的测试环境**：
   - 模拟了实际用户使用包的方式（只能访问公开的API）
   - 有助于确保包的公共API是完整且易于使用的



**假设测试文件使用 `package log`（内部测试）**

`internal/pkg/log/log_test.go`的包声明为：

```go
package log // 与被测试包同名

import (
    "testing"
    "time"
    // 测试可以方便地访问 log 包的内部实现
    // 同时，它也可以导入项目中的其他包...
    "github.com/myproject/internal/pkg/user" // 假设测试需要用到 user 包
)
```

现在，假设 `internal/pkg/user/user.go`也需要记录日志，因此它导入了 `log`包：

```go
package user

import "github.com/myproject/internal/pkg/log" // user 包依赖 log 包

func CreateUser() {
    // ...
    log.Infow("user created")
}
```

这就产生了潜在的循环导入问题！

编译路径：

1. 编译器要编译 `log`包。
2. 它发现 `log`包依赖于其测试文件 (`log_test.go`)。
3. 在编译测试文件时，发现 `log_test.go`导入了 `user`包 (`import "github.com/myproject/internal/pkg/user"`)。
4. 编译器接着去编译 `user`包。
5. 在编译 `user`包时，发现它又导入了 `log`包 (`import "github.com/myproject/internal/pkg/log"`)。
6. **停止！** 编译器发现了一个循环：`log`-> `log_test`(属于 `log`包) -> `user`-> `log`。这是一个死循环，Go 编译器会报错并拒绝编译。

**使用 `package log_test`（外部测试）**

`internal/pkg/log/log_test.go`的包声明为：

```go
package log_test // 独立的测试包

import (
    "testing"
    "time"
    // 必须显式导入被测试的 log 包，且只能访问其公共接口
    log "github.com/myproject/internal/pkg/log" 
    // 理论上，这里仍然可以导入 user 包
    "github.com/myproject/internal/pkg/user"
)
```

`log_test`包：是一个独立的包。它单向导入了 `log`包（为了测试它）和 `user`包。此时的依赖链是：`log_test`-> `log`和 `log_test`-> `user`-> `log`。