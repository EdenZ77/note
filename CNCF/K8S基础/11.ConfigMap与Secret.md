前面我们学习了一些常用的资源对象的使用，但是单纯依靠这些资源对象，还不足以满足我们的日常需求，一个重要的需求就是应用的配置管理、敏感信息的存储和使用（如：密码、Token 等）、安全管控、身份认证等等。
# ConfigMap
对于应用可变配置在 Kubernetes 中是通过 ConfigMap 资源对象来实现的，ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。

使用时 Pods 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。ConfigMap 将环境配置信息和容器镜像进行解耦，便于应用配置的修改。不过需要注意 ConfigMap 并不提供保密或者加密功能。如果你想存储的数据是机密的，则可以使用 Secret 对象，或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。

应用经常会有从配置文件、命令行参数或者环境变量中读取一些配置信息的需求，这些配置信息肯定不能直接写死到应用程序中；比如一个应用连接 redis 服务，下一次想更换一个地址，还得重新去修改代码，重新制作一个镜像，这肯定是不可取的，而 ConfigMap 就提供了向容器中注入配置信息的能力，不仅可以用来保存单个属性，还可以用来保存整个配置文件，比如配置一个 redis 服务的访问地址，也可以用来保存整个 redis 的配置文件。

值得注意的是 ConfigMap 虽然也是一个 K8s 资源对象，但是和其他 Kubernetes 对象都有一个 `spec` 属性不同的是，ConfigMap 使用 `data` 和 `binaryData` 字段，这些字段能够接收键值对作为其值。`data` 和 `binaryData` 字段都是可选的，`data` 字段设计用来保存 UTF-8 编码的字符串，而 `binaryData` 则被设计用来保存二进制数据经过 `base64` 编码后的字符串。`data` 或 `binaryData` 字段下面的每个键的名称都必须由字母数字字符或者 `-`、`_` 或 `.` 组成，在 `data` 下保存的键名不可以与在 `binaryData` 下出现的键名有重叠。此外从 v1.19 版本开始，我们还可以添加一个 `immutable` 字段到 ConfigMap 对象中，用于创建不可变更的 ConfigMap。

## 创建

ConfigMap 资源对象使用 key-value 形式的键值对来配置数据，这些数据可以在 Pod 里面使用，如下所示的资源清单：
```yaml
kind: ConfigMap
apiVersion: v1
metadata:
  name: cm-demo
  namespace: default
data:
  data.1: hello
  data.2: world
  config: |
    property.1=value-1
    property.2=value-2
    property.3=value-3
```
其中配置数据在 `data` 属性下面进行配置，前两个被用来保存单个属性，后面一个被用来保存一个配置片段。

关于 yaml 使用可以参考阮一峰的文章：[https://www.ruanyifeng.com/blog/2016/07/yaml.html](https://www.ruanyifeng.com/blog/2016/07/yaml.html)，可看“六、字符串”这部分的内容。`yaml` 与 `js` 相互转换网址：[https://nodeca.github.io/js-yaml/](https://nodeca.github.io/js-yaml/)

当然同样使用 `kubectl apply -f xx.yaml` 来创建上面的 ConfigMap 对象。如果不知道怎么创建 ConfigMap 的话，不要忘记 kubectl 工具是我们最好的帮手，可以使用 `kubectl create configmap -h` 来查看关于创建 ConfigMap 的帮助信息：
```sh
Examples:
  # Create a new config map named my-config based on folder bar
  kubectl create configmap my-config --from-file=path/to/bar

  # Create a new config map named my-config with specified keys instead of file basenames on disk
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt

  # Create a new config map named my-config with key1=config1 and key2=config2
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2

  # Create a new config map named my-config from the key=value pairs in the file
  kubectl create configmap my-config --from-file=path/to/bar

  # Create a new config map named my-config from an env file
  kubectl create configmap my-config --from-env-file=path/to/foo.env --from-env-file=path/to/bar.env
```
看到可以从一个指定的目录来创建一个 ConfigMap 对象，比如我们有一个 `testcm` 的目录，该目录下面包含一些配置文件，`redis` 和 `mysql` 的连接信息，如下：
```sh
[root@master yamlDir]# ls testcm/
mysql.conf  redis.conf
[root@master yamlDir]# cat testcm/redis.conf
host=127.0.0.1
port=6379
[root@master yamlDir]# cat testcm/mysql.conf
host=127.0.0.1
port=3306
```
然后我们就可以使用 `from-file` 关键字来创建包含这个目录下面所有配置文件的 ConfigMap：
```sh
[root@master yamlDir]# kubectl create configmap cm-demo1 --from-file=testcm
configmap/cm-demo1 created
```
其中 `from-file` 参数指定在该目录下面的所有文件都会被用在 ConfigMap 里面创建一个键值对，键的名字就是文件名，值就是文件的内容。创建完成后，同样可以使用如下命令来查看 ConfigMap 列表：
```sh
[root@master yamlDir]# kubectl get cm
NAME               DATA   AGE
cm-demo1           2      67s
```
可以看到已经创建了一个 `cm-demo1` 的 ConfigMap 对象，然后可以使用 `describe` 命令查看详细信息：
```sh
[root@master yamlDir]# kubectl describe cm cm-demo1
Name:         cm-demo1
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
mysql.conf:
----
host=127.0.0.1
port=3306

redis.conf:
----
host=127.0.0.1
port=6379


BinaryData
====

Events:  <none>
```
可以看到两个 `key` 是 `testcm` 目录下面的文件名称，对应的 `value` 值就是文件内容，这里值得注意的是如果文件里面的配置信息很大的话，`describe` 的时候可能不会显示对应的值，要查看完整的键值，可以使用如下命令：
```sh
[root@master yamlDir]# kubectl get configmap cm-demo1 -o yaml
apiVersion: v1
data:
  mysql.conf: |
    host=127.0.0.1
    port=3306
  redis.conf: |
    host=127.0.0.1
    port=6379
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-28T10:25:36Z"
  name: cm-demo1
  namespace: default
  resourceVersion: "1108216"
  uid: c4fa38bc-fb9a-4b9d-a6e2-74d65f01d352
```
除了通过文件目录进行创建，我们也可以使用指定的文件进行创建 ConfigMap，同样的，以上面的配置文件为例，我们创建一个 `redis` 的配置的一个单独 ConfigMap 对象：
```sh
[root@master yamlDir]# kubectl create configmap cm-demo2 --from-file=testcm/redis.conf
configmap/cm-demo2 created
[root@master yamlDir]# kubectl get cm cm-demo2 -oyaml
apiVersion: v1
data:
  redis.conf: |
    host=127.0.0.1
    port=6379
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-29T01:49:30Z"
  name: cm-demo2
  namespace: default
  resourceVersion: "1186002"
  uid: 36b44650-4638-4a93-83c9-40699b6b4965
```
我们可以看到一个关联 `redis.conf` 文件配置信息的 ConfigMap 对象创建成功了，另外值得注意的是 `--from-file` 这个参数可以使用多次，比如我们这里使用两次分别指定 `redis.conf` 和 `mysql.conf` 文件，就和直接指定整个目录是一样的效果了。

另外，通过帮助文档看到还可以直接使用字符串进行创建，通过 `--from-literal` 参数传递配置信息，同样的，这个参数可以使用多次，格式如下：
```sh
[root@master yamlDir]# kubectl create configmap cm-demo3 --from-literal=db.host=localhost --from-literal=db.port=3306
configmap/cm-demo3 created
[root@master yamlDir]# kubectl get configmap cm-demo3 -o yaml
apiVersion: v1
data:
  db.host: localhost
  db.port: "3306"
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-29T01:54:16Z"
  name: cm-demo3
  namespace: default
  resourceVersion: "1186403"
  uid: ae9185eb-362c-4716-bf56-7850d64fe57b
```

## 使用
ConfigMap 创建成功了，那么我们应该怎么在 Pod 中来使用呢？可以使用四种方式来使用 ConfigMap 配置 Pod 中的容器：
- 容器命令行参数
- 容器的环境变量
- 数据卷挂载
- 编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap

这些不同的方法适用于不同的数据使用方式，对前三个方法，`kubelet` 会使用 ConfigMap 中的数据在 Pod 中启动容器。第四种方法需要编写代码才能读取 ConfigMap 数据。

首先，我们使用 ConfigMap 来填充环境变量，如下所示的 Pod 资源对象：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: testcm1-pod
spec:
  containers:
    - name: testcm1
      image: busybox
      command: ["/bin/sh", "-c", "env"]
      env:
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: cm-demo3
              key: db.host
        - name: DB_PORT
          valueFrom:
            configMapKeyRef:
              name: cm-demo3
              key: db.port
      envFrom:
        - configMapRef:
            name: cm-demo1
```
这个 Pod 运行后会输出如下所示的信息：
```sh
[root@master yamlDir]# kubectl get pod
NAME          READY   STATUS      RESTARTS   AGE
testcm1-pod   0/1     Completed   0          10s
[root@master yamlDir]# kubectl logs -f testcm1-pod
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT=tcp://10.96.0.1:443
HOSTNAME=testcm1-pod
DB_PORT=3306 # 正确输出环境变量
SHLVL=1
HOME=/root
mysql.conf=host=127.0.0.1 # 这是cm-demo1 输出的环境变量
port=3306

redis.conf=host=127.0.0.1 # 这是cm-demo1 输出的环境变量
port=6379

KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_SERVICE_HOST=10.96.0.1
PWD=/
DB_HOST=localhost # 正确输出环境变量
```
可以看到 `DB_HOST` 和 `DB_PORT` 都已经正常输出了，另外的环境变量是因为我们直接把 `cm-demo1` 给注入进来了，所以把他们的整个键值给输出了，这也是符合预期的。

另外也可以使用 ConfigMap 来设置命令行参数，如下Pod:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: testcm2-pod
spec:
  containers:
    - name: testcm2
      image: busybox
      command: ["/bin/sh", "-c", "echo $(DB_HOST) $(DB_PORT)"]
      env:
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: cm-demo3
              key: db.host
        - name: DB_PORT
          valueFrom:
            configMapKeyRef:
              name: cm-demo3
              key: db.port
```
运行这个 Pod 后会输出如下信息：
```sh
[root@master yamlDir]# kubectl logs testcm2-pod
localhost 3306
```
另外一种常见的使用 ConfigMap 方式：通过数据卷使用，在数据卷里面使用 ConfigMap，键就是文件名，键值就是文件内容，如下资源对象所示：
```yaml
[root@master ~]# kubectl get cm cm-demo2 -oyaml
apiVersion: v1
data:
  redis.conf: |
    host=127.0.0.1
    port=6379
kind: ConfigMap

# ================
apiVersion: v1
kind: Pod
metadata:
  name: testcm3-pod
spec:
  volumes:
    - name: config-volume
      configMap:
        name: cm-demo2
  containers:
    - name: testcm3
      image: busybox
      command: ["/bin/sh", "-c", "cat /etc/config/redis.conf"]
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
```
运行这个 Pod ，查看日志：
```sh
[root@master yamlDir]# kubectl logs testcm3-pod
host=127.0.0.1
port=6379
```
当然也可以在 ConfigMap 值被映射的数据卷里去控制路径，如下 Pod 定义：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: testcm4-pod
spec:
  volumes:
    - name: config-volume
      configMap:
        name: cm-demo1
        items:
          - key: mysql.conf
            path: path/to/mysql.conf # 相对于卷根目录的文件路径，用来映射 ConfigMap 中的键
            # 路径可以是多级目录结构，但这些目录会在挂载时自动创建。
  containers:
    - name: testcm4
      image: busybox
      command: ["/bin/sh", "-c", "cat /etc/config/path/to/mysql.conf"]
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
```
运行这个 Pod 的，查看日志：
```sh
[root@master yamlDir]# kubectl logs testcm4-pod
host=127.0.0.1
port=3306
```
### ConfigMap 作为数据卷挂载时的行为

1. **热更新机制**：
   - 当 ConfigMap 以数据卷的形式挂载到 Pod 中时，如果 ConfigMap 发生了更新（例如，添加、删除或修改了键值对），kubelet 会在其周期性的同步过程中检查挂载点上的 ConfigMap 是否是最新的。
   - 如果检测到 ConfigMap 已经更新，kubelet 会自动更新挂载点上的文件内容，而无需重启 Pod。这种行为称为“热更新”。
2. **监测配置文件变更**：
   - 为了利用这一特性，可以在 Pod 中运行一个监测配置文件变更的脚本。一旦检测到配置文件发生变化，可以触发服务的重新加载或重启，从而实现应用的动态配置更新。
   - 例如，可以使用 `inotify-tools` 或者其他文件系统监控工具来监听配置文件的变化。
3. **环境变量方式使用的 ConfigMap 数据**：
   - 如果 ConfigMap 是通过环境变量的方式注入到 Pod 中的，那么 ConfigMap 的更新不会自动反映到环境中。
   - 这是因为环境变量是在容器启动时初始化的，之后不会动态更新。因此，要使新的 ConfigMap 数据生效，通常需要重新启动 Pod。



## 使用 subPath
上面我们介绍了可以将 ConfigMap 以数据卷的形式挂载到容器中去，但是如果原本容器目录下已经有一些文件或者数据，将数据挂载进去后便会覆盖容器目录下的数据，这个时候我们可以指定 `volumeMounts.subPath` 属性来指定卷内的子路径，而不是其根路径。

比如我们将一个 Nginx 容器的配置放置到一个 ConfigMap 对象中来进行管理：
```yaml
# nginx-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf: |
    user nginx;
    worker_processes 1;

    error_log   /var/log/nginx/error.log warn;
    pid         /var/run/nginx.pid;

    events {
      worker_connections 1024;
    }

    http {
      include       /etc/nginx/mime.types;
      default_type  application/octet-stream;

      log_format main   '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';

      access_log /var/log/nginx/access.log main;

      sendfile            on;
      keepalive_timeout   65;
      include             /etc/nginx/conf.d/*.conf;
    }
```
然后将上面的配置文件挂载到容器中去使用，创建如下所示的一个资源对象：
```yaml
# nginx-deploy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: web
          image: nginx:1.7.9
          ports:
            - containerPort: 80
          volumeMounts:
            - name: config
              mountPath: /etc/nginx
      volumes:
        - name: config
          configMap:
            name: nginx-config
            items:
              - key: nginx.conf
                path: nginx.conf
```
按照我们的想法是将 ConfigMap 中的 `nginx.conf` 挂载到容器的 `/etc/nginx` 目录下面去，但是该目录下面原本已经有很多文件了，所以用上面的方式会将该目录中的数据覆盖掉，这样就会导致 Nginx 应用启动失败。
```sh
[root@master yamlDir]# kubectl apply -f nginx-config.yaml
configmap/nginx-config created
[root@master yamlDir]# kubectl apply -f nginx-deploy.yaml
deployment.apps/nginx created
[root@master yamlDir]# kubectl get pods -l app=nginx
NAME                     READY   STATUS             RESTARTS      AGE
nginx-5456544546-sw6wg   0/1     CrashLoopBackOff   1 (10s ago)   12s
[root@master yamlDir]# kubectl logs -f nginx-5456544546-sw6wg
2024/02/29 07:57:27 [emerg] 1#0: open() "/etc/nginx/mime.types" failed (2: No such file or directory) in /etc/nginx/nginx.conf:12
nginx: [emerg] open() "/etc/nginx/mime.types" failed (2: No such file or directory) in /etc/nginx/nginx.conf:12
```
挂载的位置是对的，但是覆盖了`/etc/nginx`目录下面的其它文件：

```shell
[root@master 03-subpath]# kubectl exec -it nginx-79d4d6c4c7-jbk2h -- sh
/ # cd /etc/nginx/
/etc/nginx # ls
nginx.conf
/etc/nginx # cat nginx.conf
user nginx;
worker_processes 1;

error_log   /var/log/nginx/error.log warn;
pid         /var/run/nginx.pid;
......
```

我们只需要在容器的 `volumeMounts` 中通过 `subPath` 指定下子路径即可（items还是原来的样子）：

```yaml
volumeMounts:
  - name: config
    mountPath: /etc/nginx/nginx.conf
    subPath: nginx.conf
```
更新后容器就可以正常启动了：
```sh
[root@master yamlDir]# kubectl get pods -l app=nginx
NAME                     READY   STATUS    RESTARTS   AGE
nginx-7498977d8c-qz7t9   1/1     Running   0          5s
```



如果改为下面的：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: web
          image: busybox:latest
          imagePullPolicy: IfNotPresent
          command: ["/bin/sh", "-c", "while true; do sleep 3600; done"]
          ports:
            - containerPort: 80
          volumeMounts:
            - name: config
              mountPath: /etc/nginx/nginx.conf
      volumes:
        - name: config
          configMap:
            name: nginx-config
```

最后容器的挂载情况如下：

```shell
[root@master 03-subpath]# kubectl exec -it nginx-75499bfd6b-69jp4 -- sh
/ # cd /etc/nginx/
/etc/nginx # ls
nginx.conf
/etc/nginx # cd nginx.conf/
/etc/nginx/nginx.conf # ls
nginx.conf
/etc/nginx/nginx.conf # cat nginx.conf
user nginx;
worker_processes 1;

error_log   /var/log/nginx/error.log warn;
pid         /var/run/nginx.pid;
......
```

缺少 `subPath`：没有 `subPath`，整个卷的内容会被挂载到 `/etc/nginx/nginx.conf`，这会导致 `/etc/nginx/nginx.conf` 成为一个目录，而不是一个文件，从而导致 Nginx 启动失败。



如果改为下面的：

```yaml
          volumeMounts:
            - name: config
              mountPath: /etc/nginx/nginx.conf
      volumes:
        - name: config
          configMap:
            name: nginx-config
            items:
              - key: nginx.conf
                path: nginx.conf
```

最后容器的挂载情况如下：

```shell
[root@master 03-subpath]# kubectl exec -it nginx-75499bfd6b-5k45t -- sh
/ # cd /etc/nginx/
/etc/nginx # ls -la
total 0
drwxr-xr-x    3 root     root            24 Oct 27 02:56 .
drwxr-xr-x    1 root     root            67 Oct 27 02:56 ..
drwxrwxrwx    3 root     root            78 Oct 27 02:56 nginx.conf
/etc/nginx # cd nginx.conf/
/etc/nginx/nginx.conf # ls
nginx.conf
/etc/nginx/nginx.conf # cat nginx.conf
user nginx;
worker_processes 1;

error_log   /var/log/nginx/error.log warn;
pid         /var/run/nginx.pid;
......
```



### 总结

目录路径：在 `subPath` 中指定的路径可以包含多级目录。这些目录路径必须在卷中存在，否则挂载将会失败。

卷中的存在性：Kubernetes 在挂载时会检查卷中是否存在指定的目录路径。如果路径不存在，挂载操作将无法完成，Pod 也会启动失败。

### 示例

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-app-container
          image: my-app-image:latest
          volumeMounts:
            - name: shared-volume
              mountPath: /data/gatorcloud/original
              subPath: original
            - name: shared-volume
              mountPath: /data/gatorcloud/client
              subPath: client
      volumes:
        - name: shared-volume
          persistentVolumeClaim:
            claimName: shared-download
```

第一个挂载点：

```yaml
- name: shared-volume
  mountPath: /data/gatorcloud/original
  subPath: original
```

- **`name: shared-volume`**：引用的是 `volumes` 部分定义的卷 `shared-volume`。
- **`mountPath: /data/gatorcloud/original`**：将卷中的 `original` 目录挂载到容器内的 `/data/gatorcloud/original` 路径。
- **`subPath: original`**：指定卷中的 `original` 目录。

第二个挂载点：

```yaml
- name: shared-volume
  mountPath: /data/gatorcloud/client
  subPath: client
```

- **`name: shared-volume`**：引用的是 `volumes` 部分定义的卷 `shared-volume`。
- **`mountPath: /data/gatorcloud/client`**：将卷中的 `client` 目录挂载到容器内的 `/data/gatorcloud/client` 路径。
- **`subPath: client`**：指定卷中的 `client` 目录。

假设 PVC `shared-download` 中的目录结构如下：

```shell
/shared-download/
├── original/
│   ├── file1.txt
│   └── file2.txt
└── client/
    ├── file3.txt
    └── file4.txt
```

挂载结果：

- 第一个挂载点：

  - 容器内的 `/data/gatorcloud/original` 目录将包含 `shared-download` 卷中的 `original` 目录内容。

  - 结果：

    ```shell
    /data/gatorcloud/original/
    ├── file1.txt
    └── file2.txt
    ```

- 第二个挂载点：

  - 容器内的 `/data/gatorcloud/client` 目录将包含 `shared-download` 卷中的 `client` 目录内容。

  - 结果：

    ```shell
    /data/gatorcloud/client/
    ├── file3.txt
    └── file4.txt
    ```



### 防止mountPath被覆盖

使用 `subPath` 的一个重要原因是防止挂载点 (`mountPath`) 目录被整个卷的内容覆盖。通过使用 `subPath`，你可以精确地控制挂载到容器内的具体文件或目录，而不是整个卷的内容。

**没有 `subPath` 的情况**

假设你有一个 PersistentVolumeClaim (PVC) 名为 `shared-download`，其目录结构如下：

```
/shared-download/
├── original/
│   ├── file1.txt
│   └── file2.txt
└── client/
    ├── file3.txt
    └── file4.txt
```

如果你在 Deployment 中直接挂载整个卷，而不使用 `subPath`，如下所示：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-app-container
          image: my-app-image:latest
          volumeMounts:
            - name: shared-volume
              mountPath: /data/gatorcloud
      volumes:
        - name: shared-volume
          persistentVolumeClaim:
            claimName: shared-download
```

在这种情况下，容器内的 `/data/gatorcloud` 目录将被 PVC `shared-download` 的根目录内容完全覆盖。结果如下：

```shell
/data/gatorcloud/
├── original/
│   ├── file1.txt
│   └── file2.txt
└── client/
    ├── file3.txt
    └── file4.txt
```

任何原本存在于容器内的 `/data/gatorcloud` 目录下的文件或子目录都会被删除或覆盖。

**使用 `subPath` 的情况**

通过使用 `subPath`，你可以精确地控制挂载到容器内的具体文件或目录，而不是整个卷的内容。例如：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-app-container
          image: my-app-image:latest
          volumeMounts:
            - name: shared-volume
              mountPath: /data/gatorcloud/original
              subPath: original
            - name: shared-volume
              mountPath: /data/gatorcloud/client
              subPath: client
      volumes:
        - name: shared-volume
          persistentVolumeClaim:
            claimName: shared-download
```

在这种情况下，容器内的 `/data/gatorcloud` 目录不会被完全覆盖，而是只挂载 PVC 中的特定子目录：

- 第一个挂载点：

  - 容器内的 `/data/gatorcloud/original` 目录将包含 `shared-download` 卷中的 `original` 目录内容。

  - 结果：

    ```shell
    /data/gatorcloud/
    └── original/
        ├── file1.txt
        └── file2.txt
    ```

- 第二个挂载点：

  - 容器内的 `/data/gatorcloud/client` 目录将包含 `shared-download` 卷中的 `client` 目录内容。

  - 结果：

    ```shell
    /data/gatorcloud/
    └── client/
        ├── file3.txt
        └── file4.txt
    ```







除此之外我们还可以使用带有扩展环境变量的 subPath ，该功能在 v1.17 版本已经进行稳定状态了，通过使用subPathExpr 字段可以基于 downward API 环境变量来构造 subPath 目录名，不过需要注意 subPath 和subPathExpr 属性是互斥的。

我们经常有在容器中创建以 Pod 名为路径的目录来保存日志数据，我们就可以使用该特性来实现。比如我们在 Pod 中使用subPathExpr 在 hostPath 卷的 /var/log 中创建目录 pod1 ， hostPath 卷采用来自 downward API 的Pod 名称生成目录名，然后宿主机目录 /var/log/pod1 被挂载到容器的 /logs 中。如下资源对象所示：
```yaml
...
```
当我们创建上面的资源对象后会通过 downward api 获取到 POD_NAME 环境变量的值为 pod1 ，然后通过subPathExpr 会在宿主机的 /var/log 目录下面创建 pod1 子目录，然后和容器中的 /logs 目录进行映射，所以最终日志数据会出现在宿主机的 /var/log/pod1 目录下面。
```sh
...
```

## 不可变更的 ConfigMap
Kubernetes 特性 Immutable Secret 和 ConfigMaps 提供了一种将各个 Secret 和 ConfigMap 设置为不可变更的选项。对于大量使用 ConfigMap 的集群（至少有数万个各不相同的 ConfigMap 给 Pod 挂载）而言，禁止更改ConfigMap 的数据有以下好处：
- 保护应用，使之免受意外更新所带来的负面影响。
- 通过大幅降低 kube-apiserver 的压力提升集群性能，因为系统会关闭对已标记为不可变更的 ConfigMap的 watch 操作。

此功能在 v1.21 版本就已经是稳定的特性了，可以通过 ImmutableEphemeralVolumes 特性门控来控制，我们只需要通过将 immutable 字段设置为 true 即可创建不可变更的 ConfigMap，例如：
```yaml
# immu-cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: immu-cm
data:
  mysql.conf: |-
    host=127.0.0.1
    port=3306
immutable: true
```
一旦某 ConfigMap 被标记为不可变更，则无法逆转这一变化，也无法更改 data 或 binaryData 字段的内容，只能删除并重建 ConfigMap 。因为现有的 Pod 会维护一个已被删除的 ConfigMap 的挂载点，建议重新创建这些 Pods。

当我们修改上面的 ConfigMap 数据内容后，重新更新该对象就会出现如下所示的错误信息：
```sh
☸ ➜ kubectl apply -f immu-cm.yaml
The ConfigMap "immu-cm" is invalid: data: Forbidden: field is immutable when `immutable` is set
```

# Secret
ConfigMap 这个资源对象是 Kubernetes 当中非常重要的一个资源对象，一般情况下 ConfigMap 是用来存储一些非安全的配置信息，如果涉及到一些安全相关的数据的话用 ConfigMap 就非常不妥了，因为 ConfigMap 是明文存储的这时就需要用到另外一个资源对象了： Secret ， Secret 用来保存敏感信息。

创建 Secret 时，你可以使用 Secret 资源的 type 字段，或者与其等价的 kubectl 命令行参数（如果有的话）为其设置类型。 Secret 类型有助于对 Secret 数据进行编程处理。Kubernetes 提供若干种内置的类型，用于一些常见的使用场景。 针对这些类型，Kubernetes 所执行的合法性检查操作以及对其所实施的限制各不相同。

Secret 主要使用的有以下几种类型：
- Opaque：用户定义的任意数据
- kubernetes.io/dockercfg：~/.dockercfg 文件的序列化形式
- kubernetes.io/dockerconfigjson：~/.docker/config.json 文件的序列化形式
- kubernetes.io/service-account-token：服务账号令牌
- kubernetes.io/ssh-auth：用于 SSH 身份认证的凭据
- kubernetes.io/basic-auth：用于基本身份认证的凭据
- bootstrap.kubernetes.io/token：启动引导令牌数据
- kubernetes.io/tls: 用于 TLS 客户端或者服务器端的数据

上面是 Secret 对象内置支持的几种类型，通过为 Secret 对象的 type 字段设置一个非空的字符串值，也可以定义并使用自己 Secret 类型，如果 type 值为空字符串，则被视为 Opaque 类型。Kubernetes 并不对类型的名称作任何限制。不过，如果你要使用内置类型之一， 则你必须满足为该类型所定义的所有要求。

需要注意的是默认情况下，Kubernetes Secret 未加密存储在 APIServer 的底层数据存储 etcd 中，任何拥有 API访问权限的人都可以检索或修改 Secret，任何有权访问 etcd 的人也可以。此外，任何有权限在命名空间中创建 Pod 的人都可以使用该访问权限读取该命名空间中的任何 Secret。为了更安全地使用 Secret，我们可以执行以下步骤来加强安全：
- 为 Secret 启用静态加密。
- 以最小特权访问 Secret 并启用或配置 RBAC 规则。
- 限制 Secret 对特定容器的访问。
- 考虑使用外部 Secret 存储驱动。

在后续课程中我们也会陆续接触到这些方案。

## Opaque Secret
Secret 资源包含2个键值对： data 和 stringData，data 字段用来存储 base64 编码的任意数据，提供 stringData 字段是为了方便，它允许 Secret 使用未编码的字符串。 data 和 stringData 的键必须由字母、数字、-，_ 或 . 组成。

比如我们来创建一个用户名为 admin，密码为 admin321 的 Secret 对象，首先我们需要先把用户名和密码做 base64 编码：
```sh
[root@master yamlDir]#  echo -n "admin" | base64
YWRtaW4=
[root@master yamlDir]# echo -n "admin321" | base64
YWRtaW4zMjE=
```
然后我们就可以利用上面编码过后的数据来编写一个 YAML 文件：(secret-demo.yaml)
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: YWRtaW4zMjE=
```
然后我们就可以使用 kubectl 命令来创建，并查看描述
```sh
[root@master yamlDir]# kubectl apply -f secret-demo.yaml
secret/mysecret created
[root@master yamlDir]# kubectl get secret
NAME       TYPE     DATA   AGE
mysecret   Opaque   2      10s
[root@master yamlDir]# kubectl describe secret mysecret
Name:         mysecret
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  Opaque

Data
====
password:  8 bytes
username:  5 bytes
```
可以看到利用 describe 命令查看到的 Data 没有直接显示出来，如果想看 Data 里面的详细信息，同样我们可以输出成 YAML 文件进行查看：
```sh
[root@master yamlDir]# kubectl get secret mysecret -oyaml
apiVersion: v1
data:
  password: YWRtaW4zMjE=
  username: YWRtaW4=
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","data":{"password":"YWRtaW4zMjE=","username":"YWRtaW4="},"kind":"Secret","metadata":{"annotations":{},"name":"mysecret","namespace":"default"},"type":"Opaque"}
  creationTimestamp: "2024-02-29T10:02:27Z"
  name: mysecret
  namespace: default
  resourceVersion: "1228355"
  uid: c42f0208-018b-449e-afa9-523317730cbf
type: Opaque
```
对于某些场景，你可能希望使用 stringData 字段，这字段可以将一个非 base64 编码的字符串直接放入 Secret 中， 当创建或更新该 Secret 时，此字段将被编码。

比如当我们部署应用时，使用 Secret 存储配置文件，你希望在部署过程中，填入部分内容到该配置文件。例如，如果应用程序使用以下配置文件:
```yaml
apiUrl: "https://my.api.com/api/v1"
username: "<user>"
password: "<password>"
```
那就可以使用以下定义将其存储在 Secret 中:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
stringData:
  config.yaml: |
    apiUrl: "https://my.api.com/api/v1"
    username: <user>
    password: <password>
```
比如我们直接创建上面的对象后重新获取对象的话 config.yaml 的值会被编码：
```sh
➜  ~ kubectl get secret mysecret -o yaml
apiVersion: v1
data:
  config.yaml: YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IDx1c2VyPgpwYXNzd29yZDogPHBhc3N3b3JkPgo=
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"Secret","metadata":{"annotations":{},"name":"mysecret","namespace":"default"},"stringData":{"config.yaml":"apiUrl: \"https://my.api.com/api/v1\"\nusername: \u003cuser\u003e\npassword: \u003cpassword\u003e\n"},"type":"Opaque"}
  creationTimestamp: "2021-11-21T10:42:25Z"
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:config.yaml: {}
      f:metadata:
        f:annotations:
          .: {}
          f:kubectl.kubernetes.io/last-applied-configuration: {}
      f:type: {}
    manager: kubectl
    operation: Update
    time: "2021-11-21T10:42:25Z"
  name: mysecret
  namespace: default
  resourceVersion: "857340"
  uid: 5a28d296-5f53-4e4c-92f3-c1d7c952ace2
type: Opaque
```
创建好 Secret对象后，有两种方式来使用它：

- 以环境变量的形式
- 以Volume的形式挂载

### 环境变量
首先我们来测试下环境变量的方式，同样的，使用一个简单的 busybox 镜像来测试下:(secret1-pod.yaml)
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret1-pod
spec:
  containers:
  - name: secret1
    image: busybox
    command: [ "/bin/sh", "-c", "env" ]
    env:
    - name: USERNAME
      valueFrom:
        secretKeyRef:
          name: mysecret
          key: username
    - name: PASSWORD
      valueFrom:
        secretKeyRef:
          name: mysecret
          key: password
```
需要注意的是上面环境变量中定义的 secretKeyRef 字段，和我们前文的 configMapKeyRef 类似，一个是从 Secret 对象中获取，一个是从 ConfigMap 对象中获取，创建上面的Pod并查看Pod日志输出：
```sh
[root@master yamlDir]# kubectl apply -f secret1-pod.yaml
pod/secret1-pod created
[root@master yamlDir]# kubectl logs secret1-pod
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT=tcp://10.96.0.1:443
HOSTNAME=secret1-pod
SHLVL=1
HOME=/root
USERNAME=admin
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_SERVICE_HOST=10.96.0.1
PWD=/
PASSWORD=admin321
```
可以看到有 USERNAME 和 PASSWORD 两个环境变量输出出来。

### Volume 挂载
同样的我们用一个 Pod 来验证下 Volume 挂载，创建一个 Pod 文件：(secret2-pod.yaml)
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret2-pod
spec:
  containers:
  - name: secret2
    image: busybox
    command: ["/bin/sh", "-c", "ls /etc/secrets"]
    volumeMounts:
    - name: secrets
      mountPath: /etc/secrets
  volumes:
  - name: secrets
    secret:
     secretName: mysecret
```
创建Pod并查看输出日志：
```sh
[root@master yamlDir]# kubectl apply -f secret2-pod.yaml
pod/secret2-pod created
[root@master yamlDir]# kubectl logs secret2-pod
password
username
```
可以看到 Secret 把两个 key 挂载成了两个对应的文件。当然如果想要挂载到指定的文件上面，可以使用上一节课的方法：在 secretName 下面添加 items 指定 key 和 path，这个大家可以参考上节课 ConfigMap 中的方法去测试下。

## kubernetes.io/dockerconfigjson
除了上面的 Opaque 这种类型外，我们还可以来创建用户 docker registry 认证的 Secret，直接使用``kubectl create` 命令创建即可，如下：
```sh
➜  ~ kubectl create secret docker-registry myregistry --docker-server=DOCKER_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL
secret "myregistry" created
```
除了上面这种方法之外，我们也可以通过指定文件的方式来创建镜像仓库认证信息，需要注意对应的 KEY 和 TYPE：
```sh
kubectl create secret generic myregistry --from-file=.dockerconfigjson=/root/.docker/config.json --type=kubernetes.io/dockerconfigjson
```
然后查看 Secret 列表：
```sh
➜  ~ kubectl get secret
NAME                  TYPE                                  DATA      AGE
default-token-n9w2d   kubernetes.io/service-account-token   3         33d
myregistry            kubernetes.io/dockerconfigjson        1         15s
mysecret              Opaque                                2         34m
```
注意看上面的 TYPE 类型，myregistry 对应的是 kubernetes.io/dockerconfigjson，同样的可以使用 describe 命令来查看详细信息：
```sh
➜  ~ kubectl describe secret myregistry
Name:         myregistry
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  kubernetes.io/dockerconfigjson

Data
====
.dockerconfigjson:  152 bytes
```
同样的可以看到 Data 区域没有直接展示出来，如果想查看的话可以使用 -o yaml 来输出展示出来：
```sh
[root@master yamlDir]# kubectl get secret myregistry -oyaml
apiVersion: v1
data:
  .dockerconfigjson: eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0=
kind: Secret
metadata:
  creationTimestamp: "2024-03-01T01:57:39Z"
  name: myregistry
  namespace: default
  resourceVersion: "1311592"
  uid: 4bcb485b-0a98-4fc7-b53f-f969808b2791
type: kubernetes.io/dockerconfigjson
```
可以把上面的 data.dockerconfigjson 下面的数据做一个 base64 解码，看看里面的数据是怎样的呢？
```sh
[root@master yamlDir]# echo eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= | base64 -d
{"auths":{"DOCKER_SERVER":{"username":"DOCKER_USER","password":"DOCKER_PASSWORD","email":"DOCKER_EMAIL","auth":"RE9DS0VSX1VTRVI6RE9DS0VSX1BBU1NXT1JE"}}}
```
如果我们需要拉取私有仓库中的 Docker 镜像的话就需要使用到上面的 myregistry 这个 Secret ：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo
spec:
  containers:
  - name: foo
    image: 192.168.1.100:5000/test:v1
  imagePullSecrets:
  - name: myregistry
```
我们需要拉取私有仓库镜像 192.168.1.100:5000/test:v1，我们就需要针对该私有仓库来创建一个如上的 Secret，然后在 Pod 中指定 imagePullSecrets。

除了设置 Pod.spec.imagePullSecrets 这种方式来获取私有镜像之外，我们还可以通过在 ServiceAccount 中设置 imagePullSecrets，然后就会自动为使用该 SA 的 Pod 注入 imagePullSecrets 信息：
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: "2019-11-08T12:00:04Z"
  name: default
  namespace: default
  resourceVersion: "332"
  selfLink: /api/v1/namespaces/default/serviceaccounts/default
  uid: cc37a719-c4fe-4ebf-92da-e92c3e24d5d0
secrets:
  - name: default-token-5tsh4
imagePullSecrets:
  - name: myregistry
```

## kubernetes.io/basic-auth
该类型用来存放用于基本身份认证所需的凭据信息，使用这种 Secret 类型时，Secret 的 data 字段（不一定）必须包含以下两个键（相当于是约定俗成的一个规定）：
- username: 用于身份认证的用户名
- password: 用于身份认证的密码或令牌

以上两个键的键值都是 base64 编码的字符串。当然也可以在创建 Secret 时使用 stringData 字段来提供明文形式的内容。下面的 YAML 是基本身份认证 Secret 的一个示例清单：
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: secret-basic-auth
type: kubernetes.io/basic-auth
stringData:
  username: admin
  password: admin321
```
提供基本身份认证类型的 Secret 仅仅是出于用户方便性考虑，我们也可以使用 Opaque 类型来保存用于基本身份认证的凭据，不过使用内置的 Secret 类型的有助于对凭据格式进行统一处理。

## kubernetes.io/ssh-auth
该类型用来存放 SSH 身份认证中所需要的凭据，使用这种 Secret 类型时，你就不一定必须在其 data（或 stringData）字段中提供一个 ssh-privatekey 键值对，作为要使用的 SSH 凭据。

如下所示是一个 SSH 身份认证 Secret 的配置示例：
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: secret-ssh-auth
type: kubernetes.io/ssh-auth
data:
  ssh-privatekey: |
    MIIEpQIBAAKCAQEAulqb/Y ...
```
同样提供 SSH 身份认证类型的 Secret 也仅仅是出于用户方便性考虑，我们也可以使用 Opaque 类型来保存用于 SSH 身份认证的凭据，只是使用内置的 Secret 类型的有助于对凭据格式进行统一处理。

## kubernetes.io/tls
该类型用来存放证书及其相关密钥（通常用在 TLS 场合）。此类数据主要提供给 Ingress 资源，用以校验 TLS 链接，当使用此类型的 Secret 时，Secret 配置中的 data （或 stringData）字段必须包含 tls.key 和 tls.crt主键。下面的 YAML 包含一个 TLS Secret 的配置示例：
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: secret-tls
type: kubernetes.io/tls
data:
  tls.crt: |
    MIIC2DCCAcCgAwIBAgIBATANBgkqh ...
  tls.key: |
    MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...
```
提供 TLS 类型的 Secret 仅仅是出于用户方便性考虑，我们也可以使用 Opaque 类型来保存用于 TLS 服务器与/或客户端的凭据。不过，使用内置的 Secret 类型的有助于对凭据格式进行统一化处理。当使用 kubectl 来创建 TLS Secret 时，我们可以像下面的例子一样使用 tls 子命令：
```sh
➜  ~ kubectl create secret tls my-tls-secret \
  --cert=path/to/cert/file \
  --key=path/to/key/file
```
需要注意的是用于 --cert 的公钥证书必须是 .PEM 编码的 （Base64 编码的 DER 格式），且与 --key 所给定的私钥匹配，私钥必须是通常所说的 PEM 私钥格式，且未加密。对这两个文件而言，PEM 格式数据的第一行和最后一行（例如，证书所对应的 --------BEGIN CERTIFICATE----- 和 -------END CERTIFICATE----）都不会包含在其中。

... 暂时不深究，后期将证书相关内容补充一下再来仔细学习

## kubernetes.io/service-account-token
另外一种 Secret 类型就是 kubernetes.io/service-account-token ，用于被 ServiceAccount 引用。

从 v1.22 版本开始，这种类型的 Secret 不再被用来向 Pod 中加载凭据数据，现在可以通过 TokenRequest API 来获得令牌，而不是使用服务账号令牌 Secret 对象。 通过 TokenRequest API 获得的令牌比保存在 Secret 对象中的令牌更加安全，因为这些令牌有着被限定的生命期，并且不会被其他 API 客户端读取，我们可以使用 kubectl create token 命令调用 TokenRequest API 获得令牌。

...暂时跳过

# Secret vs ConfigMap
最后我们来对比下 Secret 和 ConfigMap 这两种资源对象的异同点

## 相同点
- key/value的形式
- 属于某个特定的命名空间
- 可以导出到环境变量
- 可以通过目录/文件形式挂载
- 通过 volume 挂载的配置信息均可热更新

## 不同点
- Secret 可以被 ServerAccount 关联
- Secret 可以存储 docker register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像
- Secret 支持 Base64 加密
- Secret 分为多种类型，而 Configmap 不区分类型

> 同样 Secret 文件大小限制为 1MB（ETCD 的要求）；Secret 虽然采用 Base64 编码，但是我们还是可以很方便解码获取到原始信息，所以对于非常重要的数据还是需要慎重考虑，可以考虑使用 Vault 来进行加密管理。