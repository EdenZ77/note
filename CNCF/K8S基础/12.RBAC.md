# RBAC 权限控制
前面已经学习一些常用的资源对象的使用，对于资源对象的操作都是通过 APIServer 进行的，那么集群是怎样知道我们的请求就是合法的请求呢？这个就需要了解 Kubernetes 中另外一个非常重要的知识点了：RBAC（基于角色的权限控制）。

管理员可以通过 Kubernetes API 动态配置策略来启用 RBAC，需要在 `kube-apiserver` 中添加参数 `--authorization-mode=RBAC`，如果使用的 kubeadm 安装的集群那么是默认开启了 RBAC 的，可以通过查看 Master 节点上 `apiserver` 的静态 Pod 定义文件：
```sh
➜  ~ cat /etc/kubernetes/manifests/kube-apiserver.yaml
...
    - --authorization-mode=Node,RBAC
...
```
# API 对象
在学习 RBAC 之前，需要先去理解下 Kubernetes 集群中的对象。在 Kubernetes 集群中，Kubernetes 对象是持久化的实体，就是最终存入 `etcd` 中的数据，集群中通过这些实体来表示整个集群的状态。前面我们都直接编写的 YAML 文件，通过 `kubectl` 来提交的资源清单文件，然后创建对应的资源对象，那么它究竟是如何将我们的 YAML 文件转换成集群中的一个 API 对象的呢？

这就需要去了解下声明式 API 的设计，Kubernetes API 是一个以 JSON 为主要序列化方式的 HTTP 服务，除此之外也支持 Protocol Buffers 序列化方式，主要用于集群内部组件间的通信。

## K8S API 术语

> 参考资料：https://kubernetes.io/zh-cn/docs/reference/using-api/api-concepts/#standard-api-terminology

Kubernetes 通常使用常见的 RESTful 术语来描述 API 概念：

- **资源类型（Resource Type）** 是 URL 中使用的名称（`pods`、`namespaces`、`services`）
- 所有资源类型都有一个具体的表示（它们的对象模式），称为 **类别（Kind）**
- 资源类型的实例的列表称为 **集合（Collection）**
- 资源类型的单个实例称为 **资源（Resource）**，通常也表示一个 **对象（Object）**
- 对于某些资源类型，API 包含一个或多个 **子资源（sub-resources）**，这些子资源表示为资源下的 URI 路径

大多数 Kubernetes API 资源类型都是对象（Object）： 它们代表集群上某个概念的具体实例，例如 Pod 或名字空间。 少数 API 资源类型是“虚拟的”，因为它们通常表示对对象的操作而不是对象， 例如权限检查（使用带有 JSON 编码的 `SubjectAccessReview` body 来 POST 到 `subjectaccessreviews` 资源）， 或 Pod 的子资源 `eviction`（用于触发 [API 发起的驱逐](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/api-eviction/)）。

### 对象名字

通过 API 创建的所有对象都有一个唯一的[名字](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/)（客户端提供的字符串，引用资源 URL 中的对象，如`/api/v1/pods/somename`）， 以允许幂等创建和检索， 但如果虚拟资源类型不可检索或不依赖幂等性，则它们可能没有唯一名称。 在[名字空间](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/)内， 同一时刻只能有一个给定类别的对象具有给定名称。 但是，如果你删除该对象，你可以创建一个具有相同名称的新对象。 有些对象没有名字空间（例如：节点），因此它们的名称在整个集群中必须是唯一的。

### API 动作

几乎所有对象资源类型都支持标准 HTTP 动词 - GET、POST、PUT、PATCH 和 DELETE。 Kubernetes 也使用自己的动词，这些动词通常写成小写，以区别于 HTTP 动词。

Kubernetes 使用术语 **list** 来描述返回资源[集合](https://kubernetes.io/zh-cn/docs/reference/using-api/api-concepts/#collections)， 以区别于通常称为 **get** 的单个资源检索。 如果你发送带有 `?watch` 查询参数的 HTTP GET 请求， Kubernetes 将其称为 **watch** 而不是 **get**（有关详细信息，请参阅[快速检测更改](https://kubernetes.io/zh-cn/docs/reference/using-api/api-concepts/#efficient-detection-of-changes)）。

对于 PUT 请求，Kubernetes 在内部根据现有对象的状态将它们分类为 **create** 或 **update**。 **update** 不同于 **patch**；**patch** 的 HTTP 动词是 PATCH。

### 资源URI

所有资源类型要么是集群作用域的（`/apis/GROUP/VERSION/*`）， 要么是名字空间作用域的（`/apis/GROUP/VERSION/namespaces/NAMESPACE/*`）。 名字空间作用域的资源类型会在其名字空间被删除时也被删除， 并且对该资源类型的访问是由定义在名字空间域中的授权检查来控制的。

注意： 核心资源使用 `/api` 而不是 `/apis`，并且不包含 GROUP 路径段。

例如：

- `/api/v1/namespaces`
- `/api/v1/pods`
- `/api/v1/namespaces/my-namespace/pods`
- `/apis/apps/v1/deployments`
- `/apis/apps/v1/namespaces/my-namespace/deployments`
- `/apis/apps/v1/namespaces/my-namespace/deployments/my-deployment`

你还可以访问资源集合（例如：列出所有 Node）。以下路径用于检索集合和资源：

- 集群作用域的资源：
  - `GET /apis/GROUP/VERSION/RESOURCETYPE` - 返回指定资源类型的资源的集合
  - `GET /apis/GROUP/VERSION/RESOURCETYPE/NAME` - 返回指定资源类型下名称为 NAME 的资源
- 名字空间作用域的资源：
  - `GET /apis/GROUP/VERSION/RESOURCETYPE` - 返回所有名字空间中指定资源类型的全部实例的集合
  - `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE` - 返回名字空间 NAMESPACE 内给定资源类型的全部实例的集合
  - `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME` - 返回名字空间 NAMESPACE 中给定资源类型的名称为 NAME 的实例

由于名字空间本身是一个集群作用域的资源类型，你可以通过 `GET /api/v1/namespaces/` 检视所有名字空间的列表（“集合”），使用 `GET /api/v1/namespaces/NAME` 查看特定名字空间的详细信息。

- 集群作用域的子资源：`GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE`
- 名字空间作用域的子资源：`GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE`

每个子资源所支持的动词有所不同，取决于对象是什么 - 参见 [API 文档](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/)以了解更多信息。



为了可扩展性，Kubernetes 在不同的 API 路径（比如 `/api/v1` 或者 `/apis/batch`）下面支持了多个 API 版本，不同的 API 版本意味着不同级别的稳定性和支持：

- Alpha 级别，例如 `v1alpha1` 默认情况下是被禁用的，可以随时删除对功能的支持，所以要慎用。
- Beta 级别，例如 `v2beta1` 默认情况下是启用的，表示代码已经经过了很好的测试，但是对象的语义可能会在随后的版本中以不兼容的方式更改。
- 稳定级别，比如 `v1` 表示已经是稳定版本了，也会出现在后续的很多版本中。

在 Kubernetes 集群中，一个 API 对象在 Etcd 里的完整资源路径，是由：Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的。通过这样的结构，整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：

![](image/2024-03-01-11-19-01.png)

从上图中我们也可以看出 Kubernetes 的 API 对象的组织方式，在顶层，我们可以看到有一个核心资源（路径`/api/xxx`）和非核心资源（路径 `/apis/xxx`）和系统范围内的资源，比如 `/metrics`。也可以用下面的命令来查看集群中的 API 组织形式：
```sh
[root@master yamlDir]# kubectl get --raw /
{
  "paths": [
    "/.well-known/openid-configuration",
    "/api",
    "/api/v1",
    "/apis",
    "/apis/",
    "/apis/admissionregistration.k8s.io",
    "/apis/admissionregistration.k8s.io/v1",
    "/apis/apiextensions.k8s.io",
    "/apis/apiextensions.k8s.io/v1",
    "/apis/apiregistration.k8s.io",
    "/apis/apiregistration.k8s.io/v1",
    "/apis/apps",
...
```


## GVK
要通过 YAML 表达一个资源对象需要指定 `group`、`kind` 和 `version`，这个在 Kubernetes 的 API Server 中简称为 GVK，GVK 是定位一种类型的方式。

我们回顾下定义的 daemonsets 的资源清单文件：
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: node-exporter
  namespace: kube-system
spec:
# ......
```
这里声明的 `apiVersion` 是 `apps/v1`，其实就是隐含了 Group 是 `apps`，Version 是 `v1`，Kind 就是定义的 `DaemonSet`。而 `kubectl` 接收到这个清单之后，通过下面的映射关系就可以组装URL:  `/apis/apps/v1/daemonsets`，然后 API Server 调用该 URL 去创建对象。

```shell
[root@master ~]# kubectl api-resources | grep 'apps/v1'
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
controllerrevisions                            apps/v1                                true         ControllerRevision
daemonsets                        ds           apps/v1                                true         DaemonSet
deployments                       deploy       apps/v1                                true         Deployment
replicasets                       rs           apps/v1                                true         ReplicaSet
statefulsets                      sts          apps/v1                                true         StatefulSet
```

接下来看看 API Server 中的第二个概念：GVR。

## GVR
理解了 GVK 之后再理解 GVR 就很容易了，这就是面向对象编程里面的类和对象的概念是一样的：

<img src="image/2024-03-01-11-35-05.png" style="zoom: 33%;" />

Kind 其实就是一个类，用于描述对象的；而 Resource 就是具体的 Kind，可以理解成类已经实例化成对象了。通常情况下，Kind 和 Resource 之间有一个一对一的映射。例如，`pods` 资源对应于 `Pod` 种类，但是有时，同一类型可能由多个资源返回。例如 Scale Kind 是由所有 `scale` 子资源返回的，如 `deployments/scale` 、`replicasets/scale`。

```shell
# 下面的输出是GPT给出，我本地测试没有Scale kind 输出
NAME                              SHORTNAMES   APIGROUP                     NAMESPACED   KIND
deployments/scale                 ds/scale     apps/v1                      true         Scale
replicasets/scale                 rs/scale     apps/v1                      true         Scale
statefulsets/scale                sts/scale    apps/v1                      true         Scale
```

`kubectl` 是如何从 YAML 资源清单文件中知道请求哪个 GVR 的呢？这就是 REST Mapping 的功能。在代码中，其实就对应于这个接口：

![](image/2024-03-01-11-35-39.png)

这样，就把 GVK 和 GVR 联系起来了。

现在我们知道 API Server 可以通过 URI 的形式访问到资源，我们可以通过 `kubectl proxy` 来代理一个本地的 API Server 端口，这样就可以绕过认证了，直接可以以 `http` 的形式访问：
```sh
[root@master yamlDir]# kubectl proxy
Starting to serve on 127.0.0.1:8001
```
然后就可以直接访问 API Server 了：
```sh
[root@master ~]# curl http://127.0.0.1:8001/apis/apps/v1/daemonsets
{
  "kind": "DaemonSetList",
  "apiVersion": "apps/v1",
  "metadata": {
    "resourceVersion": "1332469"
  },
  "items": [
    {
      "metadata": {
        "name": "kube-flannel-ds",
        "namespace": "kube-flannel",
        "uid": "73f42832-356e-4842-b9bd-7e058b40a36b",
        "resourceVersion": "6433",
        "generation": 2,
        "creationTimestamp": "2024-02-19T08:58:11Z",
        "labels": {
          "app": "flannel",
          "k8s-app": "flannel",
          "tier": "node"
        },
        ...
      },
      ...
    },
    {
      "metadata": {
        "name": "kube-proxy",
        "namespace": "kube-system",
        "uid": "ac3cc2aa-4b9a-4b75-8897-2288514f5908",
        "resourceVersion": "6084",
        "generation": 1,
        "creationTimestamp": "2024-02-19T08:25:16Z",
        "labels": {
          "k8s-app": "kube-proxy"
        },
        ...
      },
      ...
    }
  ]
}
```
结果返回了当前集群所有的 daemonset 对象，看看当前集群的 daemonsets，对比一下两者的输出：
```sh
[root@master ~]# kubectl get daemonsets -A
NAMESPACE      NAME              DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE
kube-flannel   kube-flannel-ds   3         3         3       3            3           <none>                   10d
kube-system    kube-proxy        3         3         3       3            3           kubernetes.io/os=linux   10d
```
# RBAC
现在要在 Kubernetes 中通过 RBAC 来对资源进行权限管理，还需要了解另外几个概念：
- Rule：规则，规则是对资源的一组操作的集合。
- Role 和 ClusterRole：角色和集群角色，这两个对象都包含上面的 Rule 元素；二者的区别在于，在 Role 中定义的规则只适用于单个命名空间，也就是和 namespace 关联的，而 ClusterRole 是集群范围内的，因此定义的规则不受命名空间的约束。另外 Role 和 ClusterRole 在 Kubernetes 中都被定义为集群内部的 API 资源，和前面学习过的 Pod、Deployment 这些对象类似，都是集群的资源对象，所以同样的可以使用 YAML 文件来描述，用 `kubectl` 工具来管理。
- Subject：主题，对应集群中尝试操作的对象，集群中定义了 3 种类型的主题资源：
    - User Account：用户，这是由外部独立服务进行管理的，管理员进行私钥的分配，用户可以使用 KeyStone 或者 Goolge 帐号，甚至一个用户名和密码的文件列表也可以。对于用户的管理，集群内部没有一个关联的资源对象，所以用户不能通过集群内部的 API 来进行管理。
    - Group：组，这是用来关联多个账户的，集群中有一些默认创建的组，比如 `cluster-admin`。
    - Service Account：服务帐号，通过 Kubernetes API 来管理的一些用户帐号，和 `namespace` 进行关联的，适用于集群内部运行的应用程序，需要通过 API 来完成权限认证；所以在集群内部进行权限操作，我们都需要使用到 ServiceAccount，这也是这节课的重点。
- RoleBinding 和 ClusterRoleBinding：角色绑定和集群角色绑定，简单来说就是把声明的 Subject 和 Role 进行绑定的过程（给某个用户绑定上操作的权限），二者的区别也是作用范围的区别：RoleBinding 只会影响到当前 `namespace` 下面的资源操作权限，而 ClusterRoleBinding 会影响到所有的 `namespace`。

接下来通过几个简单的示例，来学习下在 Kubernetes 集群中如何使用 RBAC。

## 只能访问某个 namespace 的普通用户
想要创建一个 User Account，只能访问 `kube-system` 这个命名空间，对应的用户信息如下所示：
```yaml
username: cnych
group: youdianzhishi
```
### 创建用户凭证
给用户 `cnych` 创建一个私钥，命名成 `cnych.key`：
```sh
[root@master rbac]# openssl genrsa -out cnych.key 2048
Generating RSA private key, 2048 bit long modulus (2 primes)
.................+++++
....................................................+++++
e is 65537 (0x010001)
[root@master rbac]# ll
total 4
-rw------- 1 root root 1675 Mar  1 02:21 cnych.key
```
使用刚刚创建的私钥创建一个证书签名请求文件：`cnych.csr`，要注意需要确保在 `-subj` 参数中指定通用名称和组织(CN表示通用名称，O表示组织)：
```sh
➜  ~ openssl req -new -key cnych.key -out cnych.csr -subj "/CN=cnych/O=youdianzhishi"
```
然后找到 Kubernetes 集群的 CA 证书，我们使用的是 `kubeadm` 安装集群，CA 相关证书位于 `/etc/kubernetes/pki/` 目录下面，如果你是二进制方式搭建的，应该在最开始搭建集群的时候就已经指定好了 CA 的目录，我们会利用该目录下面的 `ca.crt` 和 `ca.key` 两个文件来批准上面的证书请求，用以生成最终的证书文件，这里设置证书的有效期为 500 天：
```sh
[root@master rbac]# openssl x509 -req -in cnych.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out cnych.crt -days 500
Signature ok
subject=CN = cnych, O = youdianzhishi
Getting CA Private Key

# 完成后，可以看到/etc/kubernetes/pki/ca.srl文件增加一
[root@master pki]# pwd
/etc/kubernetes/pki
[root@master pki]# cat ca.srl
3E87612727DF9CB2079E0F6334B744A42F80767F
# 签发证书之后，序列号文件加一
[root@master pki]# cat ca.srl
3E87612727DF9CB2079E0F6334B744A42F807680
```
现在查看当前文件夹下面是否生成了一个证书文件：
```sh
[root@master rbac]# ls
cnych.crt  cnych.csr  cnych.key
```
现在可以使用刚刚创建的证书文件和私钥文件在集群中创建新的凭证和上下文：
```sh
[root@master rbac]# kubectl config set-credentials cnych --client-certificate=cnych.crt --client-key=cnych.key
User "cnych" set.

# get-users         Display users defined in the kubeconfig
[root@master rbac]# kubectl config get-users
NAME
cnych
kubernetes-admin

# get-clusters      Display clusters defined in the kubeconfig
[root@master rbac]# kubectl config get-clusters
NAME
kubernetes
```
可以看到一个用户 `cnych` 创建了，然后为这个用户设置新的 `context`，这里指定特定的一个 `namespace`：
```sh
[root@master rbac]# kubectl config get-clusters
NAME
kubernetes
[root@master rbac]# kubectl config set-context cnych-context --cluster=kubernetes --namespace=kube-system --user=cnych
Context "cnych-context" created.
[root@master rbac]# kubectl config get-contexts
CURRENT   NAME                          CLUSTER      AUTHINFO           NAMESPACE
          cnych-context                 kubernetes   cnych              kube-system
*         kubernetes-admin@kubernetes   kubernetes   kubernetes-admin
```
到这里，用户 `cnych` 就已经创建成功了，现在使用当前的这个上下文来操作 `kubectl` 命令的时候，应该会出现错误，因为还没有为该用户定义任何操作的权限呢：
```sh
[root@master rbac]# kubectl get pods --context=cnych-context
Error from server (Forbidden): pods is forbidden: User "cnych" cannot list resource "pods" in API group "" in the namespace "kube-system"
```
### .kube/config 集群配置

Kubernetes 的 `kubeconfig` 文件用于配置客户端访问 Kubernetes 集群的认证信息和集群信息。这个文件通常位于用户的主目录下，名为 `.kube/config`，也可以通过环境变量 `KUBECONFIG` 指定不同的位置。

```yaml
apiVersion: v1
clusters: # 定义了集群的列表
- cluster: # 每个集群的详细信息
    certificate-authority-data: LS0tLS1CRUdJTiBDRVJ...... # 集群的 CA 证书的 Base64 编码字符串，用于验证集群的 TLS 证书
    server: https://192.168.220.146:6443 # 集群的 API 服务器地址
  name: kubernetes # 集群的名称，这里是 kubernetes
contexts: # 定义了上下文的列表，上下文是集群、命名空间和用户的一个组合
- context:
    cluster: kubernetes
    namespace: kube-system # 指定使用的命名空间，如果省略，默认是 default
    user: cnych
  name: cnych-context
- context:
    cluster: kubernetes
    user: kubernetes-admin
  name: kubernetes-admin@kubernetes
# 当前使用的上下文名称，这里是 kubernetes-admin@kubernetes。这意味着在使用 kubectl 命令时，默认会使用这个上下文的配置。
current-context: kubernetes-admin@kubernetes
kind: Config
preferences: {}
users: # 定义了用户的列表
- name: cnych
  user:
    client-certificate: /root/yamlDir/rbac/cnych.crt # 用户的客户端证书路径
    client-key: /root/yamlDir/rbac/cnych.key # 用户的客户端私钥路径
- name: kubernetes-admin
  user:
    client-certificate-data: LS0tLS1CRUdJTiBDRVJ...... # 用户的客户端证书的 Base64 编码字符串
    client-key-data: LS0tLS1CRUdJTiBSU0...... # 用户的客户端私钥的 Base64 编码字符串
```



### 创建角色

用户创建完成后，接下来就需要给该用户添加操作权限，我们来定义一个 YAML 文件，创建一个允许用户操作 `deployments`、`pods`、`replicasets` 的角色，如下定义：
```yaml
# cnych-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: cnych-role
  namespace: kube-system
rules:
  - apiGroups: ["", "apps"]
    resources: ["deployments", "replicasets", "pods"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"] # 也可以使用['*']
```
其中 `pods` 属于 `core` 这个 API Group，在 YAML 中用空字符就可以；而 `deployments` 和 `replicasets` 现在都属于 `apps` 这个 API Group，所以 `rules` 下面的 `apiGroups` 就综合了这几个资源的 `apiGroups：["", "apps"]`；其中 `verbs` 就是上面提到的可以对这些资源对象执行的操作，这里需要所有的操作方法，所以也可以使用`['*']`来代替，然后直接创建这个 Role：
```sh
[root@master rbac]# kubectl apply -f cnych-role.yaml
role.rbac.authorization.k8s.io/cnych-role created
[root@master rbac]# kubectl get role -n kube-system
NAME                                             CREATED AT
cnych-role                                       2024-03-02T06:22:56Z
extension-apiserver-authentication-reader        2024-02-19T08:25:14Z
kube-proxy                                       2024-02-19T08:25:16Z
kubeadm:kubelet-config                           2024-02-19T08:25:14Z
kubeadm:nodes-kubeadm-config                     2024-02-19T08:25:14Z
system::leader-locking-kube-controller-manager   2024-02-19T08:25:14Z
system::leader-locking-kube-scheduler            2024-02-19T08:25:14Z
system:controller:bootstrap-signer               2024-02-19T08:25:14Z
system:controller:cloud-provider                 2024-02-19T08:25:14Z
system:controller:token-cleaner                  2024-02-19T08:25:14Z
```


### 创建角色权限绑定
Role 创建完成了，但是很明显现在这个 Role 和用户 `cnych` 还没有任何关系，这里就需要创建一个 `RoleBinding` 对象，在 `kube-system` 这个命名空间下将上面的 `cnych-role` 角色和用户 `cnych` 进行绑定：
```yaml
# cnych-rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: cnych-rolebinding
  namespace: kube-system
subjects:
  - kind: User
    name: cnych
roleRef:
  kind: Role # 引用的角色类型，可以是 Role 或 ClusterRole
  name: cnych-role # 引用的角色的名称
  apiGroup: rbac.authorization.k8s.io
  
# 说明一下subjects.namespace属性
引用的主体所在的命名空间。
ServiceAccount: 必须指定命名空间，因为 ServiceAccount 是命名空间范围的资源。
User 和 Group: 不需要指定命名空间，因为 User 和 Group 是全局范围的资源。如果为这些对象指定了命名空间，Kubernetes 授权器会报告错误。

```
让我们详细分析一下 `RoleBinding` 中的两个 `apiGroup` 属性，分别在 `subjects` 和 `roleRef` 中各自的含义。

1、subjects.apiGroup

`subjects.apiGroup` 字段用于指定引用的主体（Subject）所属的 API 组。这个字段主要用于区分不同类型的主体，特别是当主体不是标准的 Kubernetes 对象时。

- ServiceAccount: 默认为空（`""`），因为 `ServiceAccount` 是核心 API 组的一部分。
- User 和 Group: 默认为 `rbac.authorization.k8s.io`，因为这些主体类型属于 RBAC API 组。

```yaml
subjects:
- kind: ServiceAccount
  name: my-service-account
  namespace: default
  apiGroup: ""  # 默认为空，因为 ServiceAccount 属于核心 API 组

- kind: User
  name: alice
  apiGroup: rbac.authorization.k8s.io  # 默认为 rbac.authorization.k8s.io

- kind: Group
  name: developers
  apiGroup: rbac.authorization.k8s.io  # 默认为 rbac.authorization.k8s.io
```

2、roleRef.apiGroup

`roleRef.apiGroup` 字段用于指定引用的角色（Role 或 ClusterRole）所属的 API 组。这个字段确保 Kubernetes 能够正确解析和引用角色。

- 对于 `Role` 和 `ClusterRole`，默认值为 `rbac.authorization.k8s.io`。

```yaml
roleRef:
  apiGroup: rbac.authorization.k8s.io  # 默认为 rbac.authorization.k8s.io
  kind: Role
  name: pod-reader
```

上面的 YAML 文件中 `subjects` 字段就是用来尝试操作集群的对象，这里对应上面的 User 帐号 `cnych`，使用 `kubectl` 创建上面的资源对象：

```sh
[root@master rbac]# kubectl apply -f cnych-rolebinding.yaml
rolebinding.rbac.authorization.k8s.io/cnych-rolebinding created
```

### 测试
现在我们应该可以上面的 `cnych-context` 上下文来操作集群了：
```sh
# 可以看到，我们没有指定命名空间，但是默认输出的就是kube-system名称空间下面的资源
[root@master rbac]# kubectl get pods --context=cnych-context
NAME                              READY   STATUS    RESTARTS      AGE
coredns-7b884d5cb7-lrl72          1/1     Running   2 (29h ago)   11d
coredns-7b884d5cb7-nw9hl          1/1     Running   2 (29h ago)   11d
etcd-master                       1/1     Running   3 (29h ago)   11d
kube-apiserver-master             1/1     Running   3 (29h ago)   11d
kube-controller-manager-master    1/1     Running   4 (29h ago)   11d
kube-proxy-8cs2d                  1/1     Running   2 (29h ago)   11d
kube-proxy-h8wm7                  1/1     Running   3 (29h ago)   11d
kube-proxy-m2wcz                  1/1     Running   2 (29h ago)   11d
kube-scheduler-master             1/1     Running   4 (29h ago)   11d
metrics-server-7c5487d558-sr5vp   1/1     Running   1 (29h ago)   4d20h
[root@master rbac]# kubectl --context=cnych-context get rs,deploy
NAME                                        DESIRED   CURRENT   READY   AGE
replicaset.apps/coredns-7b884d5cb7          2         2         2       11d
replicaset.apps/metrics-server-7c5487d558   1         1         1       4d20h
replicaset.apps/metrics-server-df98fb78f    0         0         0       4d21h

NAME                             READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/coredns          2/2     2            2           11d
deployment.apps/metrics-server   1/1     1            1           4d21h
```
可以看到使用 `kubectl` 的使用并没有指定 `namespace`，这是因为上面创建这个 `context` 的时候就绑定在了 `kube-system` 这个命名空间下面，如果我们在后面加上一个`-n default`试看看呢？
```sh
[root@master rbac]# kubectl --context=cnych-context get pods --namespace=default
Error from server (Forbidden): pods is forbidden: User "cnych" cannot list resource "pods" in API group "" in the namespace "default"
```
如果去获取其他的资源对象呢：
```sh
[root@master rbac]# kubectl --context=cnych-context get svc
Error from server (Forbidden): services is forbidden: User "cnych" cannot list resource "services" in API group "" in the namespace "kube-system"
```
可以看到没有权限获取，因为我们并没有为当前操作用户指定其他对象资源的访问权限，是符合我们的预期的。这样就创建了一个只有单个命名空间访问权限的普通 User 。

## 只能访问某个 namespace 的 ServiceAccount
首先我们需要对 ServiceAccount 了解下。

### ServiceAccount
ServiceAccount 为 Pod 中运行的进程提供了一个身份，Pod 内的进程可以使用其关联服务账号的身份，向集群的APIServer 进行身份认证。

当创建 Pod 的时候规范下面有一个 `spec.serviceAccount` 的属性用来指定该 Pod 使用哪个 ServiceAccount，如果没有指定的话则默认使用 `default` 这个 `sa`（每个 `namespace`下面都有一个 `default` 这个 `sa`），然后通过投射卷，在容器的目录 `/var/run/secrets/kubernetes.io/serviceaccount/` 下有一个 `token` 令牌文件。我们通过 RBAC 对该 `sa` 授予了什么权限，那么容器里的应用拿着这个 `token` 后，就具备了对应的权限。

但是需要注意的是不同的 K8s 版本对该 `token` 文件的使用是不一样的，所以可以分几个版本来分别讨论下。
#### <= 1.20 版本
使用 kind 快速创建一个小于等于 v1.20 版本的集群：
```sh
[root@localhost ~]#  kind create cluster --name kind120 --image kindest/node:v1.20.15
Creating cluster "kind120" ...
 ✓ Ensuring node image (kindest/node:v1.20.15) 🖼
 ✓ Preparing nodes 📦
 ✓ Writing configuration 📜
 ✓ Starting control-plane 🕹️
 ✓ Installing CNI 🔌
 ✓ Installing StorageClass 💾
Set kubectl context to "kind-kind120"
You can now use your cluster with:

kubectl cluster-info --context kind-kind120

Thanks for using kind! 😊
[root@localhost ~]# kubectl get nodes
NAME                    STATUS     ROLES                  AGE   VERSION
kind120-control-plane   NotReady   control-plane,master   12s   v1.20.15
```
先创建一个名为 `sa-demo` 的 ServiceAccount 对象：
```sh
[root@localhost ~]# kubectl create sa sa-demo
serviceaccount/sa-demo created
[root@localhost ~]# kubectl get sa
NAME      SECRETS   AGE
default   1         38m
sa-demo   1         5s
[root@localhost ~]# kubectl get secret
NAME                  TYPE                                  DATA   AGE
default-token-44bb9   kubernetes.io/service-account-token   3      38m
sa-demo-token-69txr   kubernetes.io/service-account-token   3      15s
```
可以看到创建 `sa` 后自动生成了一个 `secret`，格式为 `<saname>-token-xxxx` ；比如我们创建了一个名字为 `sa-demo` 的 `sa` 之后，系统自动创建了一个名字为 `sa-demo-token-69txr` 的 `secret`，这个 `secret` 里就包含了一个`token`。
```sh
[root@localhost ~]# kubectl describe secrets sa-demo-token-69txr
Name:         sa-demo-token-69txr
Namespace:    default
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: sa-demo
              kubernetes.io/service-account.uid: 0cfc1037-6acd-4f05-8fe1-3be87d21aa1a

Type:  kubernetes.io/service-account-token

Data
==== # 包含三个键值对
ca.crt:     1066 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6Il81VGI3bDBRX0lwMVUyNFh0YUY1Sld1c1JwbUFEYzRmRFFCamlGbWxLS0UifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6InNhLWRlbW8tdG9rZW4tNjl0eHIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoic2EtZGVtbyIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjBjZmMxMDM3LTZhY2QtNGYwNS04ZmUxLTNiZTg3ZDIxYWExYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OnNhLWRlbW8ifQ.Xco0O5xTHqvLVgwUzfbVCxbDNqKsKcxPO1UccP5zvPKjg18x5Dnnz2yR3pLKUMVbxdiJRJf6w1FLEoGtrvurmc6VRDgNEL0NIxBzHH_sz-XXEMxJAOq_5IUpzO1T2wJqb4nzLBk6TEU2EVUb0g0tRy_rCVs2eMw1xSyFr_J3_iO5XAHGk-Kb5w1iGWNzYAlzm4KoJsZ-3bslHzZ5UsS3uwXnlJnsuVFRnuugzmAOXIDql5WgqEYK4LRQg_lWh6DnVBDToTtZZygxxspUruiSlF86hV0oFyoRd1EE0XpY79tTUW-PnUHppHW2d8mWXMOOv-42aKlX1VUHoaybIh_zHw
```
可以看到自动生成的这个 `secret` 对象里面包含一个 `token`，也可以通过下面的命令来获取：
```sh
[root@localhost ~]# kubectl get secrets sa-demo-token-69txr  -o jsonpath='{.data.token}' | base64 -d
eyJhbGciOiJSUzI1NiIsImtpZCI6Il81VGI3bDBRX0lwMVUyNFh0YUY1Sld1c1JwbUFEYzRmRFFCamlGbWxLS0UifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6InNhLWRlbW8tdG9rZW4tNjl0eHIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoic2EtZGVtbyIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjBjZmMxMDM3LTZhY2QtNGYwNS04ZmUxLTNiZTg3ZDIxYWExYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OnNhLWRlbW8ifQ.Xco0O5xTHqvLVgwUzfbVCxbDNqKsKcxPO1UccP5zvPKjg18x5Dnnz2yR3pLKUMVbxdiJRJf6w1FLEoGtrvurmc6VRDgNEL0NIxBzHH_sz-XXEMxJAOq_5IUpzO1T2wJqb4nzLBk6TEU2EVUb0g0tRy_rCVs2eMw1xSyFr_J3_iO5XAHGk-Kb5w1iGWNzYAlzm4KoJsZ-3bslHzZ5UsS3uwXnlJnsuVFRnuugzmAOXIDql5WgqEYK4LRQg_lWh6DnVBDToTtZZygxxspUruiSlF86hV0oFyoRd1EE0XpY79tTUW-PnUHppHW2d8mWXMOOv-42aKlX1VUHoaybIh_zHw
```
这个 `token` 是 JWT 结构的，我们可以把这个 `token` 复制到 jwt.io 网站进行解码。
![](image/2024-03-02-19-58-36.png)

右侧部分显示了 `token` 被解码之后的内容，其中 PAYLOAD 部分是 `token` 里包含的 `sa-demo` 的信息，可以看到里面没有过期时间，也说明了该 `token` 是永不过期的。

现在使用上面创建的 `sa` 来运行一个 Pod：
```yaml
# demo-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo
spec:
  serviceAccount: sa-demo
  containers:
    - name: demo
      image: nginx:1.7.9
      ports:
        - containerPort: 80
```
直接创建该 Pod 即可：
```sh
[root@localhost ~]# kubectl apply -f demo-pod.yaml
pod/demo created
[root@localhost ~]# kubectl get pods
NAME   READY   STATUS    RESTARTS   AGE
demo   1/1     Running   0          72s
[root@localhost ~]# kubectl get pod demo -oyaml
apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"Pod","metadata":{"annotations":{},"name":"demo","namespace":"default"},"spec":{"containers":[{"image":"nginx:1.7.9","name":"demo","ports":[{"containerPort":80}]}],"serviceAccount":"sa-demo"}}
  creationTimestamp: "2024-03-02T12:03:00Z"
  name: demo
  namespace: default
  resourceVersion: "17555"
  uid: d51773bc-db44-4fef-871f-70d13c4fb533
spec:
  containers:
  - image: nginx:1.7.9
    imagePullPolicy: IfNotPresent
    name: demo
    ports:
    - containerPort: 80
      protocol: TCP
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: sa-demo-token-69txr
      readOnly: true
    ......
  volumes:
  - name: sa-demo-token-69txr
    secret:
      defaultMode: 420
      secretName: sa-demo-token-69txr
  ......
```
Pod 创建后会自动将指定 `sa` 对应的 `secret` 挂载到容器的`/var/run/secrets/kubernetes.io/serviceaccount` 目录下去，所以现在该目录下面肯定包含对应的 `token` 文件，我们可以查看该值来验证下：
```sh
[root@localhost ~]# kubectl exec -it demo -- ls /run/secrets/kubernetes.io/serviceaccount
ca.crt  namespace  token
[root@localhost ~]# kubectl exec -it demo -- cat /run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI1NiIsImtpZCI6Il81VGI3bDBRX0lwMVUyNFh0YUY1Sld1c1JwbUFEYzRmRFFCamlGbWxLS0UifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6InNhLWRlbW8tdG9rZW4tNjl0eHIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoic2EtZGVtbyIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjBjZmMxMDM3LTZhY2QtNGYwNS04ZmUxLTNiZTg3ZDIxYWExYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OnNhLWRlbW8ifQ.Xco0O5xTHqvLVgwUzfbVCxbDNqKsKcxPO1UccP5zvPKjg18x5Dnnz2yR3pLKUMVbxdiJRJf6w1FLEoGtrvurmc6VRDgNEL0NIxBzHH_sz-XXEMxJAOq_5IUpzO1T2wJqb4nzLBk6TEU2EVUb0g0tRy_rCVs2eMw1xSyFr_J3_iO5XAHGk-Kb5w1iGWNzYAlzm4KoJsZ-3bslHzZ5UsS3uwXnlJnsuVFRnuugzmAOXIDql5WgqEYK4LRQg_lWh6DnVBDToTtZZygxxspUruiSlF86hV0oFyoRd1EE0XpY79tTUW-PnUHppHW2d8mWXMOOv-42aKlX1VUHoaybIh_zHw
```
可以看到 Pod 里通过投射卷所挂载的 `token` 跟 `sa-demo` 对应的 `secret` 包含的 `token` 是模一样的，这个 `token` 是永不过期的，所以即使删除了 Pod 之后重新创建，Pod 里的 `token` 仍然是不变的，因为 `secret` 对象里面的 `token`数据并没有变化。

如果需要在 Pod 中去访问 K8s 集群的资源对象，现在就可以为使用的 `sa` 绑定上相应的权限，然后在 Pod 应用中使用对应的 `token` 去和 APIServer 进行通信就可以了，这个时候的 `token` 就能识别到对应的权限了。

#### >= 1.21 版本 && <= 1.23 版本
接下来基于 `>= 1.21 && <= 1.23` 版本的 K8s 集群进行测试。这里使用 kind 快速创建一个 `v1.22.15` 版本的集群：
```sh
☸ ➜ kind create cluster --name kind122 --image kindest/node:v1.22.15
☸ ➜ kubectl get nodes
NAME                    STATUS  ROLES                   AGE         VERSION
kind122-control-plane   Ready   control-plane,master    115s        v1.22.15
```
同样首先创建一个名为 `sa-demo` 的 ServiceAccount 对象：
```sh
[root@localhost ~]# kubectl create sa sa-demo
serviceaccount/sa-demo created
[root@localhost ~]# kubectl get sa
NAME      SECRETS   AGE
default   1         2m45s
sa-demo   1         11s
[root@localhost ~]# kubectl get secret
NAME                  TYPE                                  DATA   AGE
default-token-mfkt9   kubernetes.io/service-account-token   3      2m56s
sa-demo-token-zdt4p   kubernetes.io/service-account-token   3      21s
```
同样可以看到创建 `sa` 后系统也自动创建了一个对应的 `secret` 对象，和以前版本没什么区别，我们也可以通过下面的命令来获得该 `secret` 对象里面包含的 `token` 值：
```sh
[root@localhost ~]# kubectl get secrets sa-demo-token-zdt4p  -o jsonpath='{.data.token}' | base64 -d
eyJhbGciOiJSUzI1NiIsImtpZCI6InJTUWd0TWhNR2MxUm4zRk1mVmo2VkFDaUNBdE5PSXVfU2RidmJVb3ItVFkifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6InNhLWRlbW8tdG9rZW4temR0NHAiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoic2EtZGVtbyIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjBhNmQxNzBkLTA4MzktNGZjNi1iMzUxLTMxOWE1YzZkMzAxMiIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OnNhLWRlbW8ifQ.Hsd43KUBg8zM5dVFyzn7VmVmPGgZ6bU0RZGUWVJf3JjeXN7EW2S3_unbdgT-pyiV0_6APJlrRB12CTmzTlzOkrxU03NtXinqYXAhKhBYH6CryooXpbnHQ-bBYABP0xS1Dxxd09E_TZFykzI8Un1yvXQryx_TuErZ8JKAiQ6bcuc8w53BII7VkddfpexN4NvB7su1P54QCN7bsBBFrHCtoQlZU4FIlB3Ve4ArDzGLmdTIzOeskXLnBxHcYRwfx0YRKIc2hPUEC4qiQpTnK7kCyQ2rSEQiey80pvTHYAtFFTDoottK7pFGgetN-LknCBXY9nWEKv23i_aa8zH6zzxK-w
```
同样将该 `token` 值拷贝到 jwt.io 网站进行解码。
![](image/2024-03-02-20-34-32.png)

从解码后的值可以看到该 `token` 值里面同样不包含任何过期时间，也说明了创建 `sa` 之后，所对应的 `token` 是永不过期的。同样再次使用上面的 `sa` 来创建一个 Pod，如下所示：
```yaml
# demo-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo
spec:
  serviceAccount: sa-demo
  containers:
    - name: demo
      image: nginx:1.7.9
      ports:
        - containerPort: 80
```
直接创建该 Pod：
```sh
[root@localhost ~]# kubectl apply -f demo-pod.yaml
pod/demo created
[root@localhost ~]# kubectl get pods
NAME   READY   STATUS    RESTARTS   AGE
demo   1/1     Running   0          41s
[root@localhost ~]# kubectl get pod demo -oyaml
apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"Pod","metadata":{"annotations":{},"name":"demo","namespace":"default"},"spec":{"containers":[{"image":"nginx:1.7.9","name":"demo","ports":[{"containerPort":80}]}],"serviceAccount":"sa-demo"}}
  creationTimestamp: "2024-03-02T12:35:21Z"
  name: demo
  namespace: default
  resourceVersion: "1135"
  uid: 0d9847b0-74b5-4ef8-b156-598ef1d20bbe
spec:
  containers:
  - image: nginx:1.7.9
    imagePullPolicy: IfNotPresent
    name: demo
    ports:
    - containerPort: 80
      protocol: TCP
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: kube-api-access-nqcxk
      readOnly: true
    ......
  volumes:
  - name: kube-api-access-nqcxk
    projected:
      defaultMode: 420
      sources:
      - serviceAccountToken:
          expirationSeconds: 3607
          path: token
      - configMap:
          items:
          - key: ca.crt
            path: ca.crt
          name: kube-root-ca.crt
      - downwardAPI:
          items:
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
            path: namespace
    ......
```
当 Pod 创建后查看对应的资源对象，可以看到和之前的版本已经有一个很大的区别了，并不是将上面自动创建的 `secret` 挂载到容器的 `/var/run/secrets/kubernetes.io/serviceaccount` 目录。可以查看下 Pod 中的 `token` 值来和 `secret` 包含的 token 值进行对比：
```sh
[root@localhost ~]# kubectl exec -it demo --  ls /run/secrets/kubernetes.io/serviceaccount
ca.crt  namespace  token
[root@localhost ~]# kubectl exec -it demo -- cat  /run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI1NiIsImtpZCI6InJTUWd0TWhNR2MxUm4zRk1mVmo2VkFDaUNBdE5PSXVfU2RidmJVb3ItVFkifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNzQwOTE4OTIxLCJpYXQiOjE3MDkzODI5MjEsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJkZW1vIiwidWlkIjoiMGQ5ODQ3YjAtNzRiNS00ZWY4LWIxNTYtNTk4ZWYxZDIwYmJlIn0sInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJzYS1kZW1vIiwidWlkIjoiMGE2ZDE3MGQtMDgzOS00ZmM2LWIzNTEtMzE5YTVjNmQzMDEyIn0sIndhcm5hZnRlciI6MTcwOTM4NjUyOH0sIm5iZiI6MTcwOTM4MjkyMSwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OmRlZmF1bHQ6c2EtZGVtbyJ9.TrxAG_EdDAWraEmcvVnkrfrKfPhqiCeiSv0NxeUqVl1mSj2XSrzefyjtO2OgaBHac63sND0-0MPe3DRkQ7jpCr0m_I1W5tZnGsaqCa_-f6IbZKfapLZvxZCT0TcP_YkCCEkHlifRmD9HVibIfIHKP4psTkgWjxZLr841Etr17JjqxKKKxKWv6hdqQDD9PeX-Z0N6QiDwHqqU0B2iS6bolPjhjsTDx4Ey_ww8Bp-AcaSx98qM8q6tJGbA0ZvsJS9wuRZG44wdOthcDYvEr_4Mt12fgqOc29enFNyIO2Dx1fZ6xlC8RJFe_rtfeDl5LftBO5yChmfjLxWoIN3kQUG3pw
```
可以很明显看到现在 Pod 中的 `token` 值和自动创建 `secret` 的 `token` 值不一样了，同样在 jwt.io 解码该 `token` 值。
![](image/2024-03-02-20-42-14.png)

可以看到该 `token` 值解码后的 PAYLOAD 数据中包含了很多不同的数据，其中的 `exp` 字段表示该 `token` 的过期时间，可以看到过期时间是 1 年。

这里可以总结下在 v1.21 到 v1.23 版本的 K8s 集群，当创建 ServiceAccount 对象后，系统仍然会自动创建一个 `secret` 对象，该 `secret` 对象里面包含的 `token` 仍然是永不过期的，但是 Pod 里面并不会使用该 `secret` 的 `token` 值了。

在Kubernetes中，投射卷（projected volume）允许将多个不同来源的数据“投射”到同一个目录下，这三个数据源分别用于不同的目的：
- `serviceAccountToken` 数据源：这个数据源是一个时间限制的服务账户令牌，由 `kubelet` 使用 TokenRequest API 从 `kube-apiserver` 获取。这个令牌是临时的，并且会在 Pod 被删除或者令牌本身的生命周期结束后过期。这个过期机制增加了安全性，因为即使令牌被泄漏，它也只在有限的时间里有效。该令牌是与 Pod 绑定的，并且将其 audience(受众)设置为与 `kube-apiserver` 相匹配，确保令牌只能用于访问 API 服务器。这种机制取代了以前的做法，即通过 Secret 提供不会过期的服务账户令牌。

- `configMap` 数据源：ConfigMap 通常用来存储配置数据，在这种情况下，它存储了证书颁发机构（CA）的数据，用来验证与 `kube-apiserver` 通信的证书，确保 Pod 在与 API 服务器通信时不会被中间人攻击或被引导到错误的服务器。它提供了集群的根证书颁发机构的证书，Pod 可以信任这个证书颁发机构签发的所有证书。

- `downwardAPI` 数据源：downwardAPI 是一种允许 Pod 访问有关其自身或其环境信息的机制。在这种情况下，它用于将 Pod 所在的命名空间暴露给 Pod 内的应用程序。这允许应用程序知道自己在 Kubernetes 集群中的位置，可能对于策略执行、日志记录或其他依赖于知道其所在命名空间的操作很有用。

总结来说，这三个数据源通过投射卷的形式提供了三个关键的功能：安全的服务账户令牌、证书颁发机构数据、以及Pod 的命名空间信息。这些数据源结合使用，提高了 Kubernetes Pod 的安全性、便捷性、以及对集群环境的透明度。

所以当前版本 K8s 集群创建的 Pod 里面包含的 `token` 不是使用 ServiceAccount 自动关联 `secret` 对象里面的 `token` ，而是 `kubelet` 向 TokenRequest API 发送一个请求，申请一个新的 `token` 放在 Pod 的 `/var/run/secrets/kubernetes.io/serviceaccount/token` 里。这个 `token` 会在 1 个小时后由 `kubelet` 重新去申领一个新的 `token`，所以 1 小时之后再次查看这个 `token` 的话会发现 `token` 的内容是变化的，如果删除此 Pod 重新创建的话，则会重新申领 `token`，被删除 Pod 里的 `token` 会立即过期。而且我们还可以手动使用 `kubectl create token <sa>` 命令来请求 ServiceAccount 的 `token`，可以指定有效期等：
```sh
[root@localhost ~]# kubectl create token -h
Request a service account token.

Examples:
  # Request a token to authenticate to the kube-apiserver as the service account "myapp" in the current namespace
  kubectl create token myapp

  # Request a token for a service account in a custom namespace
  kubectl create token myapp --namespace myns

  # Request a token with a custom expiration
  kubectl create token myapp --duration 10m

  # Request a token with a custom audience
  kubectl create token myapp --audience https://example.com

  # Request a token bound to an instance of a Secret object
  kubectl create token myapp --bound-object-kind Secret --bound-object-name mysecret

  # Request a token bound to an instance of a Secret object with a specific UID
  kubectl create token myapp --bound-object-kind Secret --bound-object-name mysecret --bound-object-uid
0d4691ed-659b-4935-a832-355f77ee47cc
...
```

#### >= 1.24 版本
现在再来看下 v1.24 版本以上的 K8s 集群中的 ServiceAccount `token` 是如何工作的。这里使用 kind 快速创建一个 v1.25.3 版本的集群：
```sh
☸ ➜ kind create cluster --name kind125 --image kindest/node:v1.25.3
☸ ➜ kubectl get nodes
NAME                    STATUS  ROLES                   AGE     VERSION
kind125-control-plane   Ready   control-plane,master    115s    v1.25.3
```
同样创建一个名为 `sa-demo` 的 ServiceAccount：
```sh
[root@localhost ~]# kubectl create sa sa-demo
serviceaccount/sa-demo created
[root@localhost ~]# kubectl get sa
NAME      SECRETS   AGE
default   0         5h40m
sa-demo   0         8s
[root@localhost ~]# kubectl get secrets
No resources found in default namespace.
```
可以看到该 ServiceAccount 创建后并没有创建对应的 Secret 对象。同样接下来创建一个如下所示的 Pod：
```yaml
# demo-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo
spec:
  serviceAccount: sa-demo
  containers:
    - name: demo
      image: nginx:1.7.9
      ports:
        - containerPort: 80
```
创建上面的 Pod 后查看详情：
```sh
[root@localhost ~]# kubectl apply -f demo-pod.yaml
pod/demo created
[root@localhost ~]# kubectl get pod
NAME   READY   STATUS    RESTARTS   AGE
demo   1/1     Running   0          38s
[root@localhost ~]# kubectl get pod demo -oyaml
apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"Pod","metadata":{"annotations":{},"name":"demo","namespace":"default"},"spec":{"containers":[{"image":"nginx:1.7.9","name":"demo","ports":[{"containerPort":80}]}],"serviceAccount":"sa-demo"}}
  creationTimestamp: "2024-03-02T13:28:26Z"
  name: demo
  namespace: default
  resourceVersion: "23144"
  uid: 3b7a953e-4441-4b49-a8d0-ed0d9dc7878f
spec:
  containers:
  - image: nginx:1.7.9
    imagePullPolicy: IfNotPresent
    name: demo
    ports:
    - containerPort: 80
      protocol: TCP
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: kube-api-access-k298c
      readOnly: true
  serviceAccount: sa-demo
  serviceAccountName: sa-demo
......
  volumes:
  - name: kube-api-access-k298c
    projected:
      defaultMode: 420
      sources:
      - serviceAccountToken:
          expirationSeconds: 3607
          path: token
      - configMap:
          items:
          - key: ca.crt
            path: ca.crt
          name: kube-root-ca.crt
      - downwardAPI:
          items:
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
            path: namespace
......
```
可以看到创建 Pod 后同样会自动添加一个投射卷到 Pod，此卷包括了访问 Kubernetes API 的令牌，和 `>=1.21` 版本 `&& <=1.23` 版本表现是一致的。同样可以下查看 Pod 中的 `token` 值来进行验证：
```sh
[root@localhost ~]# kubectl exec -it demo -- cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI1NiIsImtpZCI6InptcXlDdVBidXBkSE4wanJCZE1EMTZRcHRaemJrWE5GamR6c2tacENpcjgifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNzQwOTIyMTA2LCJpYXQiOjE3MDkzODYxMDYsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJkZW1vIiwidWlkIjoiM2I3YTk1M2UtNDQ0MS00YjQ5LWE4ZDAtZWQwZDlkYzc4NzhmIn0sInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJzYS1kZW1vIiwidWlkIjoiNjc4YTAyYjEtMDkwMy00MjI3LThlODktOTVjYjExNGQyODY3In0sIndhcm5hZnRlciI6MTcwOTM4OTcxM30sIm5iZiI6MTcwOTM4NjEwNiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OmRlZmF1bHQ6c2EtZGVtbyJ9.B74VmOKR2bK6IgpbbeA4lLf7bI6sNBo_BK0ODQuJwMF-YEsIXEi2-9CU3gz1RlcYXJ1b0uOpkWTpTX_dvNVLspRzYIeNbQkbN2VQ5-nt1gPukoTZtMxQw1XI331t53603Qe_zIO7udf79DMIV7CjbDDo3p4wqOPsgPdFU6Y_NEvpPg7vsaLmw94_AVeSnO79bK8hcWS26X147IKPjuACAf1FWAHDl0yr_-fT4aEVC2hlz3Zts66RgYSQrz25uZDdQZyXm3ByV2FoWitKulznN1r4oobDERPQBcef30qEl_-WdwK9YzRQ_Zzex0vLsKAE5mxnlJfeck-jQF001aUmlw
```
可以把上面输出的 `token` 值拷贝到 jwt.io 里进行解码。
![](image/2024-03-02-21-33-11.png)

从上面的数据可以看到这里的 `token` 的有效期也为 1 年，这个 `token` 在 Pod 里也是每 1 小时会更新一次，如果 Pod 被删除重建，那么会重新申领一个新的 `token`，被删除 Pod 里的 `token` 立即过期。需要注意没有特定的机制使通过 TokenRequest 签发的令牌无效，如果你不再信任为某个 Pod 绑定的 ServiceAccount 令牌，可以删除该 Pod，删除 Pod 将使其绑定的令牌过期。

可以简单总结下不同版本的 K8s 集群下面的 ServiceAccount Token 是如何工作的。
- 1.20（含 1.20）之前的版本，在创建 `sa` 时会自动创建一个 secret，然后会把这个 `secret` 通过投射卷挂载到 pod 里，该 `secret` 里面包含的 `token` 是永久有效的。
- 1.21~1.23 版本，在创建 `sa` 时也会自动创建 `secret`，但是在 pod 里并不会使用 `secret` 里的 `token`，而是由`kubelet` 到 TokenRequest API 去申请一个 `token`，该 `token` 默认有效期为一年，但是 pod 每一个小时会更新一次 `token`。
- 1.24 版本及以上，在创建 `sa` 时不再自动创建 `secret` 了，只保留由 `kubelet` 到 TokenRequest API 去申请`token`。

当然我们仍然可以手动创建 Secret 来保存 ServiceAccount 令牌，例如在你需要一个永不过期的令牌的时候。一旦手动创建一个 Secret 并将其关联到 ServiceAccount，Kubernetes 控制平面就会自动将令牌填充到该 Secret 中。
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-service-account-token
  annotations:
    kubernetes.io/service-account.name: "my-service-account"
type: kubernetes.io/service-account-token
```
定义一个 Secret 的 YAML 文件，确保指定 `type` 为 `kubernetes.io/service-account-token`。在这个 YAML 文件中，`name` 是你为 Secret 选择的名称，`annotations` 字段指定这个 Secret 与哪个 ServiceAccount 相关联。Secret 被创建后，Kubernetes 控制平面会填充 `token` 字段，可以通过运行 `kubectl describe secret my-service-account-token` 来检查它。

```shell
[root@master rbac]# kubectl apply -f secret-sa.yaml
secret/my-service-account-token created
[root@master rbac]# kubectl get secret
NAME                          TYPE                                  DATA   AGE
my-service-account-token      kubernetes.io/service-account-token   3      4s
[root@master rbac]# kubectl describe secret my-service-account-token
Name:         my-service-account-token
Namespace:    default
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: my-service-account
              kubernetes.io/service-account.uid: 9f4cb73e-7079-41a9-af96-216ebfc76e8b

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1099 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IjRMcGFKbEFtZmlKWEtNQ09VZTd4NEN3S0pSN3NCYUZoMkloYlJDU0Z4ZnMifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6Im15LXNlcnZpY2UtYWNjb3VudC10b2tlbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJteS1zZXJ2aWNlLWFjY291bnQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiI5ZjRjYjczZS03MDc5LTQxYTktYWY5Ni0yMTZlYmZjNzZlOGIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6ZGVmYXVsdDpteS1zZXJ2aWNlLWFjY291bnQifQ.pK--xuaIQaUrLYKJlrUDIRDMquCt7v2Dhe3T-A_sFO08dLG_bvfLp662hzZSCsZz-xOxcq7Rkmy2w871sXCYPhvt1o55pz4fx8_wUduCMrpFPIr00U-XsdL5m_ADoWyiIKKybupOt62KqEMfz6-JqfoG2L8rbMRmqKxfoVmTzsnPJ5H5_DOcynRxyPCV4---cVCPcdxZOlYpwep9p_5q1RHEcj6XCK8pI4wAfYKd88_VSSgXfWuZaE1zeJCB4JWeqH3de3dUKNBGULhsL8VSTI76jgiytmJhyc5o7skE3P2sUedvPnk_UfwzZJy27Ib75kLtoHDdzYTeq7rGQh6WEQ
[root@master rbac]#

# token内容如下：
{
  "iss": "kubernetes/serviceaccount",
  "kubernetes.io/serviceaccount/namespace": "default",
  "kubernetes.io/serviceaccount/secret.name": "my-service-account-token",
  "kubernetes.io/serviceaccount/service-account.name": "my-service-account",
  "kubernetes.io/serviceaccount/service-account.uid": "9f4cb73e-7079-41a9-af96-216ebfc76e8b",
  "sub": "system:serviceaccount:default:my-service-account"
}
```

尽管存在手动创建长久 ServiceAccount 令牌的机制，但还是推荐使用 TokenRequest 获得短期的 API 访问令牌。

这里还有一个疑问：`sa` 对应的 `secret` 如何并应用到 pod 的容器中？

### 为 ServiceAccount 分配权限
上面创建了一个只能访问某个命名空间下面的普通用户，前面提到过 `subjects` 下面还有一种类型的主题资源： ServiceAccount ，现在我们来创建一个集群内部的用户只能操作 `kube-system` 命名空间下面的 `pods` 和`deployments`，首先来创建一个 ServiceAccount 对象：
```sh
kubectl create sa cnych-sa -n kube-system
```
当然我们也可以定义成 YAML 文件的形式来创建：
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cnych-sa
  namespace: kube-system
```
然后新建一个 Role 对象：
```yaml
# cnych-sa-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: cnych-sa-role
  namespace: kube-system
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "watch", "list"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
```
可以看到这里定义的角色没有创建、删除、更新 Pod 的权限，待会我们可以重点测试一下，创建该 Role 对象：
```sh
[root@localhost ~]# kubectl apply -f cnych-sa-role.yaml
role.rbac.authorization.k8s.io/cnych-sa-role created
```
然后创建一个 RoleBinding 对象，将上面的 `cnych-sa` 和角色 `cnych-sa-role` 进行绑定：
```yaml
# cnych-sa-rolebinding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cnych-sa-rolebinding
  namespace: kube-system
subjects:
  - kind: ServiceAccount
    name: cnych-sa
    namespace: kube-system
roleRef:
  kind: Role
  name: cnych-sa-role
  apiGroup: rbac.authorization.k8s.io
```
添加这个资源对象：
```sh
[root@localhost ~]# kubectl create -f cnych-sa-rolebinding.yaml
rolebinding.rbac.authorization.k8s.io/cnych-sa-rolebinding created
```
然后怎么去验证这个 ServiceAccount 呢？以前的版本 ServiceAccount 会自动生成一个 Secret 对象和它进行映射，这个 Secret 里面包含一个 `token`，可以利用这个 `token` 去登录 Dashboard，然后就可以在 Dashboard 中来验证我们的功能是否符合预期了，但是现在的版本默认已经不支持这种方式了。

但是我们可以手动创建一个长久有效的 ServiceAccount 令牌，要为 ServiceAccount 创建一个不过期、持久化的API 令牌，需要创建一个类型为 `kubernetes.io/service-account-token` 的 Secret，附带引用 ServiceAccount 的注解。控制平面随后生成一个长久的令牌，并使用生成的令牌数据更新该 Secret，比如这里可以创建一个如下所示的 Secret 资源对象：
```yaml
# cnych-token.yaml
apiVersion: v1
kind: Secret
metadata:
  name: cnych-sec
  namespace: kube-system
  annotations:
    kubernetes.io/service-account.name: cnych-sa
type: kubernetes.io/service-account-token
```
也可以直接用 `kubectl create token cnych-sa --duration 10m -n kube-system` 命令来创建 `token`，此方式可以灵活的指定过期时间等信息。

创建后就可以使用该 Secret 对象包含的 `token` 去登录 Dashboard。
```sh
[root@master rbac]# kubectl get secret cnych-sec -o jsonpath={.data.token} -n kube-system |base64 -d
eyJhbGciOiJSUzI1NiIsImtpZCI6IjRMcGFKbEFtZmlKWEtNQ09VZTd4NEN3S0pSN3NCYUZoMkloYlJDU0Z4ZnMifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJjbnljaC1zZWMiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiY255Y2gtc2EiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJkZWFjZGI4Yy0wYjg2LTQyNTQtOGY2NC0yYTAwZDY3MTgyZTQiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06Y255Y2gtc2EifQ.qfVdH_TS2LaeEIwvklx0vIfcGuaJtP1t7lt6_deRtiBMftJzR-rSEuAPLVGB3cqIG6nCs7Je0qeUGt0SlwImSWHSqnOJm8kmXtFJUSq0EGYVH2rxShhsEQ0Ee4XWnuTHuA922NkTyq05HYKDuODpIKhdJZY8Vybh_ycloiySGaN-f3fbfXlcZsxvDcwrD01O1n2GmMz_pd89F0m1lkFfIrsf99-e4k62wa-QkN1lJl8dSZGBGXpJid-9090iu4gUQwYLZdeUIdxxcNdCC3mWRqL8bIzo4J76wq__PJm0U_vlGaZO3QEVp-NSFq1X_O0xR8SkDvCotvK2xC88SpO8bw
```
使用这里的 `token` 去 Dashboard 页面进行登录：

![](image/2024-03-04-14-58-00.png)
![](image/2024-03-04-14-58-47.png)

可以看到上面的提示信息说现在使用的这个 ServiceAccount 没有权限获取当前命名空间下面的资源对象，这是因为我们登录进来后默认跳转到 `default` 命名空间，切换到 `kube-system` 命名空间下面就可以了（需要手动修改浏览器中的 `url` 地址，因为没有权限获得所有命名空间）：

![](image/2024-03-04-15-02-33.png)

可以看到可以访问 `pod` 列表了，但是也会有一些其他额外的提示：`statefulsets.apps is forbidden: User "system:serviceaccount:kube-system:cnych-sa" cannot list resource "statefulsets" in API group "apps" in the namespace "kube-system"` ，这是因为当前登录用户只被权了访问 `pods` 和 `deployments` 的权限，同样的，访问下 `deployments` 看看可以了吗？

你可以根据自己的需求来对访问用户的权限进行限制，可以自己通过 Role 定义更加细粒度的权限，也可以使用系统内置的一些权限……

## 可以全局访问的 ServiceAccount
刚刚创建的 `cnych-sa` 这个 ServiceAccount 和一个 Role 角色进行绑定的，如果现在创建一个新的 ServiceAccount，需要他操作的权限作用于所有的 `namespace`，这个时候就需要使用到 ClusterRole 和 ClusterRoleBinding 这两种资源对象了。同样，首先新建一个 ServiceAcount 对象：
```yaml
# cnych-sa2.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cnych-sa2
  namespace: kube-system
```
创建该对象：
```sh
[root@master rbac]# kubectl apply -f cnych-sa2.yaml
serviceaccount/cnych-sa2 created
```
然后创建一个 ClusterRoleBinding 对象：
```yaml
# cnych-clusterolebinding.yaml
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cnych-sa2-clusterrolebinding
subjects:
  - kind: ServiceAccount
    name: cnych-sa2
    namespace: kube-system
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
```
这里没有单独新建一个 ClusterRole 对象，而是使用的 `cluster-admin` 这个对象，这是 Kubernetes 集群内置的 ClusterRole 对象，我们可以使用 `kubectl get clusterroles` 和 `kubectl get clusterrolebindings` 查看系统内置的一些集群角色和集群角色绑定，这里使用的 `cluster-admin` 这个集群角色是拥有最高权限的集群角色，所以一般需要谨慎使用该集群角色。

创建上面集群角色绑定资源对象，然后就可以使用 `kubectl create token` 命令来创建一个新的 `token` 去登录 Dashboard：
```sh
[root@master rbac]# kubectl create token cnych-sa2 -n kube-system
eyJhbGciOiJSUzI1NiIsImtpZCI6IjRMcGFKbEFtZmlKWEtNQ09VZTd4NEN3S0pSN3NCYUZoMkloYlJDU0Z4ZnMifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNzA5NTQwMTI5LCJpYXQiOjE3MDk1MzY1MjksImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJjbnljaC1zYTIiLCJ1aWQiOiI4MDA3ZTRkNi1hMjU2LTQxZmUtYmY1ZS04MTA0OGY3ZDQwZjgifX0sIm5iZiI6MTcwOTUzNjUyOSwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmNueWNoLXNhMiJ9.HfUd1teieQSNLOes0BfzYztWj8S-tXLCDKrt66mpLM9mt162faF1ciI7g8F-Jq-3QUVIv3DrkDXY0nVNSj_Tmn7FR62OmkuPe_M0ga2QO2f9sqyHzhrwfftqwRixZ15xUGWAN_C-1BKbO0sefDitZ2x7pJw9FEy7o0KSpf-DNWBeLHlXPMJ1e1P-HnYXfc5Q5Pb24LsYzWn1s5zAnfWsvTASYhs7K-35R_LCvuqKEnKB-rwmryPTHpfNKyUtQmD7a9282eRdFn2pHF-oSoYFnvM0f3PIVMnC1liJdd59LFXy6g--PI425NRIyHyeK_G0QiTRsHznlT9-mFu6u9PYeg
```
可以看到使用该 `token` 登录后没有出现任何权限相关错误了：
![](image/2024-03-04-15-17-18.png)

我们在最开始接触到 RBAC 认证的时候，可能不太熟悉，特别是不知道应该怎么去编写 `rules` 规则，大家可以去分析系统自带的 `clusterroles`、`clusterrolebindings` 这些资源对象的编写方法，怎么分析？还是利用 `kubectl` 的 `get`、`describe`、`-oyaml` 这些操作，所以 `kubectl` 最基本的操作一定要掌握好。