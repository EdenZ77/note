前面我们学习了一些常用的资源对象的使用，但是单纯依靠这些资源对象，还不足以满足我们的日常需求，一个重要的需求就是应用的配置管理、敏感信息的存储和使用（如：密码、Token 等）、安全管控、身份认证等等。
# ConfigMap
对于应用可变配置在 Kubernetes 中是通过ConfigMap 资源对象来实现的，ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时 Pods 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。ConfigMap 将环境配置信息和容器镜像进行解耦，便于应用配置的修改。不过需要注意 ConfigMap 并不提供保密或者加密功能。如果你想存储的数据是机密的，则可以使用 Secret 对象，或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。

应用经常会有从配置文件、命令行参数或者环境变量中读取一些配置信息的需求，这些配置信息肯定不能直接写死到应用程序中，比如一个应用连接 redis 服务，下一次想更换一个地址，还得重新去修改代码，重新制作一个镜像，这肯定是不可取的，而 ConfigMap 就提供了向容器中注入配置信息的能力，不仅可以用来保存单个属性，还可以用来保存整个配置文件，比如配置一个 redis 服务的访问地址，也可以用来保存整个 redis 的配置文件。

值得注意的是 ConfigMap 虽然也是一个 K8s 资源对象，但是和其他 Kubernetes 对象都有一个 spec 属性不同的是，ConfigMap 使用 data 和 binaryData 字段，这些字段能够接收键值对作为其值，data 和 binaryData 字段都是可选的，data 字段设计用来保存 UTF-8 字符串，而 binaryData 则被设计用来保存二进制数据作为 base64 编码的字符串。data 或 binaryData 字段下面的每个键的名称都必须由字母数字字符或者 -、_ 或 . 组成，在 data 下保存的键名不可以与在 binaryData 下出现的键名有重叠。此外从 v1.19 版本开始，我们还可以添加一个 immutable 字段到 ConfigMap 对象中，用于创建不可变更的 ConfigMap。

## 创建
ConfigMap 资源对象使用 key-value 形式的键值对来配置数据，这些数据可以在 Pod 里面使用，如下所示的资源清单：
```yaml
kind: ConfigMap
apiVersion: v1
metadata:
  name: cm-demo
  namespace: default
data:
  data.1: hello
  data.2: world
  config: |
    property.1=value-1
    property.2=value-2
    property.3=value-3
```
其中配置数据在 data 属性下面进行配置，前两个被用来保存单个属性，后面一个被用来保存一个配置片段。

关于yaml使用可以参考阮一峰的文章：[https://www.ruanyifeng.com/blog/2016/07/yaml.html](https://www.ruanyifeng.com/blog/2016/07/yaml.html)，可看“六、字符串”这部分的内容。yaml与js相互转换网址：[https://nodeca.github.io/js-yaml/](https://nodeca.github.io/js-yaml/)

当然同样的可以使用 kubectl create -f xx.yaml 来创建上面的 ConfigMap 对象，但是如果不知道怎么创建 ConfigMap 的话，不要忘记 kubectl 工具是我们最好的帮手，可以使用 kubectl create configmap -h 来查看关于创建 ConfigMap 的帮助信息：
```sh
Examples:
  # Create a new config map named my-config based on folder bar
  kubectl create configmap my-config --from-file=path/to/bar

  # Create a new config map named my-config with specified keys instead of file basenames on disk
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt

  # Create a new config map named my-config with key1=config1 and key2=config2
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2

  # Create a new config map named my-config from the key=value pairs in the file
  kubectl create configmap my-config --from-file=path/to/bar

  # Create a new config map named my-config from an env file
  kubectl create configmap my-config --from-env-file=path/to/foo.env --from-env-file=path/to/bar.env
```
看到可以从一个指定的目录来创建一个 ConfigMap 对象，比如我们有一个 testcm 的目录，该目录下面包含一些配置文件，redis 和 mysql 的连接信息，如下：
```sh
[root@master yamlDir]# ls testcm/
mysql.conf  redis.conf
[root@master yamlDir]# cat testcm/redis.conf
host=127.0.0.1
port=6379
[root@master yamlDir]# cat testcm/mysql.conf
host=127.0.0.1
port=3306
```
然后我们就可以使用 from-file 关键字来创建包含这个目录下面所有配置文件的 ConfigMap：
```sh
[root@master yamlDir]# kubectl create configmap cm-demo1 --from-file=testcm
configmap/cm-demo1 created
```
其中 from-file 参数指定在该目录下面的所有文件都会被用在 ConfigMap 里面创建一个键值对，键的名字就是文件名，值就是文件的内容。创建完成后，同样我们可以使用如下命令来查看 ConfigMap 列表：
```sh
[root@master yamlDir]# kubectl get cm
NAME               DATA   AGE
cm-demo1           2      67s
kube-root-ca.crt   1      9d
```
可以看到已经创建了一个 cm-demo1 的 ConfigMap 对象，然后可以使用 describe 命令查看详细信息：
```sh
[root@master yamlDir]# kubectl describe cm cm-demo1
Name:         cm-demo1
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
mysql.conf:
----
host=127.0.0.1
port=3306

redis.conf:
----
host=127.0.0.1
port=6379


BinaryData
====

Events:  <none>
```
我们可以看到两个 key 是 testcm 目录下面的文件名称，对应的 value 值就是文件内容，这里值得注意的是如果文件里面的配置信息很大的话，describe 的时候可能不会显示对应的值，要查看完整的键值，可以使用如下命令：
```sh
[root@master yamlDir]# kubectl get configmap cm-demo1 -o yaml
apiVersion: v1
data:
  mysql.conf: |
    host=127.0.0.1
    port=3306
  redis.conf: |
    host=127.0.0.1
    port=6379
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-28T10:25:36Z"
  name: cm-demo1
  namespace: default
  resourceVersion: "1108216"
  uid: c4fa38bc-fb9a-4b9d-a6e2-74d65f01d352
```
除了通过文件目录进行创建，我们也可以使用指定的文件进行创建 ConfigMap，同样的，以上面的配置文件为例，我们创建一个 redis 的配置的一个单独 ConfigMap 对象：
```sh
[root@master yamlDir]# kubectl create configmap cm-demo2 --from-file=testcm/redis.conf
configmap/cm-demo2 created
[root@master yamlDir]# kubectl get cm cm-demo2 -oyaml
apiVersion: v1
data:
  redis.conf: |
    host=127.0.0.1
    port=6379
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-29T01:49:30Z"
  name: cm-demo2
  namespace: default
  resourceVersion: "1186002"
  uid: 36b44650-4638-4a93-83c9-40699b6b4965
```
我们可以看到一个关联 redis.conf 文件配置信息的 ConfigMap 对象创建成功了，另外值得注意的是 --from-file 这个参数可以使用多次，比如我们这里使用两次分别指定 redis.conf 和 mysql.conf 文件，就和直接指定整个目录是一样的效果了。

另外，通过帮助文档看到还可以直接使用字符串进行创建，通过 --from-literal 参数传递配置信息，同样的，这个参数可以使用多次，格式如下：
```sh
[root@master yamlDir]# kubectl create configmap cm-demo3 --from-literal=db.host=localhost --from-literal=db.port=3306
configmap/cm-demo3 created
[root@master yamlDir]# kubectl get configmap cm-demo3 -o yaml
apiVersion: v1
data:
  db.host: localhost
  db.port: "3306"
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-29T01:54:16Z"
  name: cm-demo3
  namespace: default
  resourceVersion: "1186403"
  uid: ae9185eb-362c-4716-bf56-7850d64fe57b
```

## 使用
ConfigMap 创建成功了，那么我们应该怎么在 Pod 中来使用呢？我们可以使用四种方式来使用 ConfigMap 配置 Pod 中的容器：
- 容器命令行参数
- 容器的环境变量
- 数据卷挂载
- 编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap

这些不同的方法适用于不同的数据使用方式，对前三个方法，kubelet 会使用 ConfigMap 中的数据在 Pod 中启动容器。第四种方法需要编写代码才能读取 ConfigMap 数据。

首先，我们使用 ConfigMap 来填充我们的环境变量，如下所示的 Pod 资源对象：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: testcm1-pod
spec:
  containers:
    - name: testcm1
      image: busybox
      command: ["/bin/sh", "-c", "env"]
      env:
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: cm-demo3
              key: db.host
        - name: DB_PORT
          valueFrom:
            configMapKeyRef:
              name: cm-demo3
              key: db.port
      envFrom:
        - configMapRef:
            name: cm-demo1
```
这个 Pod 运行后会输出如下所示的信息：
```sh
[root@master yamlDir]# kubectl get pod
NAME          READY   STATUS      RESTARTS   AGE
testcm1-pod   0/1     Completed   0          10s
[root@master yamlDir]# kubectl logs -f testcm1-pod
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT=tcp://10.96.0.1:443
HOSTNAME=testcm1-pod
DB_PORT=3306
SHLVL=1
HOME=/root
mysql.conf=host=127.0.0.1
port=3306

redis.conf=host=127.0.0.1
port=6379

KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_SERVICE_HOST=10.96.0.1
PWD=/
DB_HOST=localhost
```
我们可以看到 DB_HOST 和 DB_PORT 都已经正常输出了，另外的环境变量是因为我们直接把 cm-demo1 给注入进来了，所以把他们的整个键值给输出了，这也是符合预期的。

另外我们也可以使用 ConfigMap 来设置命令行参数，如下Pod:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: testcm2-pod
spec:
  containers:
    - name: testcm2
      image: busybox
      command: ["/bin/sh", "-c", "echo $(DB_HOST) $(DB_PORT)"]
      env:
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: cm-demo3
              key: db.host
        - name: DB_PORT
          valueFrom:
            configMapKeyRef:
              name: cm-demo3
              key: db.port
```
运行这个 Pod 后会输出如下信息：
```sh
[root@master yamlDir]# kubectl logs testcm2-pod
localhost 3306
```
另外一种常见的使用 ConfigMap 方式：通过数据卷使用，在数据卷里面使用 ConfigMap，键就是文件名，键值就是文件内容，如下资源对象所示：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: testcm3-pod
spec:
  volumes:
    - name: config-volume
      configMap:
        name: cm-demo2
  containers:
    - name: testcm3
      image: busybox
      command: ["/bin/sh", "-c", "cat /etc/config/redis.conf"]
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
```
运行这个 Pod ，查看日志：
```sh
[root@master yamlDir]# kubectl logs testcm3-pod
host=127.0.0.1
port=6379
```
当然也可以在 ConfigMap 值被映射的数据卷里去控制路径，如下 Pod 定义：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: testcm4-pod
spec:
  volumes:
    - name: config-volume
      configMap:
        name: cm-demo1
        items:
          - key: mysql.conf
            path: path/to/msyql.conf
  containers:
    - name: testcm4
      image: busybox
      command: ["/bin/sh", "-c", "cat /etc/config/path/to/msyql.conf"]
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
```
运行这个 Pod 的，查看日志：
```sh
[root@master yamlDir]# kubectl logs testcm4-pod
host=127.0.0.1
port=3306
```
另外需要注意的是，当 ConfigMap 以数据卷形式挂载进 Pod 时，这时更新 ConfigMap（或删掉重建ConfigMap），Pod 内挂载的配置信息会热更新。kubelet 组件在周期性同步时检查所挂载的 ConfigMap 是否为最新。这时可以增加一些监测配置文件变更的脚本，然后重新加载对应服务就可以实现应用的热更新。以环境变量方式使用的 ConfigMap 数据不会被自动更新，更新这些数据需要重新启动 Pod。

> 只有通过 Kubernetes API 创建的 Pod 才能使用 ConfigMap，其他方式创建的（比如静态 Pod）不能使用；ConfigMap 文件大小限制为 1MB（ETCD 的要求）。

## 使用 subPath
上面我们介绍了可以将 ConfigMap 以数据卷的形式挂载到容器中去，但是如果原本容器目录下已经有一些文件或者数据，将数据挂载进去后便会覆盖容器目录下的数据，这个时候我们可以指定 volumeMounts.subPath 属性来指定卷内的子路径，而不是其根路径。

比如我们将一个 Nginx 容器的配置放置到一个 ConfigMap 对象中来进行管理：
```yaml
# nginx-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf: |
    user nginx;
    worker_processes 1;

    error_log   /var/log/nginx/error.log warn;
    pid         /var/run/nginx.pid;

    events {
      worker_connections 1024;
    }

    http {
      include       /etc/nginx/mime.types;
      default_type  application/octet-stream;

      log_format main   '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';

      access_log /var/log/nginx/access.log main;

      sendfile            on;
      keepalive_timeout   65;
      include             /etc/nginx/conf.d/*.conf;
    }
```
然后我们将上面的配置文件挂载到容器中去使用，创建如下所示的一个资源对象：
```yaml
# nginx-deploy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: web
          image: nginx:1.7.9
          ports:
            - containerPort: 80
          volumeMounts:
            - name: config
              mountPath: /etc/nginx
      volumes:
        - name: config
          configMap:
            name: nginx-config
            items:
              - key: nginx.conf
                path: nginx.conf
```
按照我们的想法是将 ConfigMap 中的 nginx.conf 挂载到容器的 /etc/nginx 目录下面去，但是该目录下面原本已经有很多文件了，所以用上面的方式会将该目录中的数据覆盖掉，这样就会导致我们的 Nginx 应用启动失败。
```sh
[root@master yamlDir]# kubectl apply -f nginx-config.yaml
configmap/nginx-config created
[root@master yamlDir]# kubectl apply -f nginx-deploy.yaml
deployment.apps/nginx created
[root@master yamlDir]# kubectl get pods -l app=nginx
NAME                     READY   STATUS             RESTARTS      AGE
nginx-5456544546-sw6wg   0/1     CrashLoopBackOff   1 (10s ago)   12s
[root@master yamlDir]# kubectl logs -f nginx-5456544546-sw6wg
2024/02/29 07:57:27 [emerg] 1#0: open() "/etc/nginx/mime.types" failed (2: No such file or directory) in /etc/nginx/nginx.conf:12
nginx: [emerg] open() "/etc/nginx/mime.types" failed (2: No such file or directory) in /etc/nginx/nginx.conf:12
```
我们只需要在容器的 volumeMounts 中通过 subPath 指定下子路径即可：
```yaml
volumeMounts:
  - name: config
    mountPath: /etc/nginx/nginx.conf
    subPath: nginx.conf
```
更新后我们的容器就可以正常启动了：
```sh
[root@master yamlDir]# kubectl get pods -l app=nginx
NAME                     READY   STATUS    RESTARTS   AGE
nginx-7498977d8c-qz7t9   1/1     Running   0          5s
```
关于path、mountPath、subPath的说明：
- 当您使用 subPath 来挂载单个文件时，mountPath 应该精确指向容器内的文件路径，而不是目录。
- path 定义了在挂载的卷目录中文件的位置和名称
- 如果你没有指定 subPath，整个mountPath目录将会被path覆盖。如果你使用 subPath，path会挂载到该目录下的具体文件路径，而不会覆盖整个目录。

除此之外我们还可以使用带有扩展环境变量的 subPath ，该功能在 v1.17 版本已经进行稳定状态了，通过使用subPathExpr 字段可以基于 downward API 环境变量来构造 subPath 目录名，不过需要注意 subPath 和subPathExpr 属性是互斥的。

我们经常有在容器中创建以 Pod 名为路径的目录来保存日志数据，我们就可以使用该特性来实现。比如我们在 Pod 中使用subPathExpr 在 hostPath 卷的 /var/log 中创建目录 pod1 ， hostPath 卷采用来自 downward API 的Pod 名称生成目录名，然后宿主机目录 /var/log/pod1 被挂载到容器的 /logs 中。如下资源对象所示：
```yaml
...
```
当我们创建上面的资源对象后会通过 downward api 获取到 POD_NAME 环境变量的值为 pod1 ，然后通过subPathExpr 会在宿主机的 /var/log 目录下面创建 pod1 子目录，然后和容器中的 /logs 目录进行映射，所以最终日志数据会出现在宿主机的 /var/log/pod1 目录下面。
```sh
...
```

## 不可变更的 ConfigMap
Kubernetes 特性 Immutable Secret 和 ConfigMaps 提供了一种将各个 Secret 和 ConfigMap 设置为不可变更的选项。对于大量使用 ConfigMap 的集群（至少有数万个各不相同的 ConfigMap 给 Pod 挂载）而言，禁止更改ConfigMap 的数据有以下好处：
- 保护应用，使之免受意外更新所带来的负面影响。
- 通过大幅降低 kube-apiserver 的压力提升集群性能，因为系统会关闭对已标记为不可变更的 ConfigMap的 watch 操作。

此功能在 v1.21 版本就已经是稳定的特性了，可以通过 ImmutableEphemeralVolumes 特性门控来控制，我们只需要通过将 immutable 字段设置为 true 即可创建不可变更的 ConfigMap，例如：
```yaml
# immu-cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: immu-cm
data:
  mysql.conf: |-
    host=127.0.0.1
    port=3306
immutable: true
```
一旦某 ConfigMap 被标记为不可变更，则无法逆转这一变化，也无法更改 data 或 binaryData 字段的内容，只能删除并重建 ConfigMap 。因为现有的 Pod 会维护一个已被删除的 ConfigMap 的挂载点，建议重新创建这些 Pods。

当我们修改上面的 ConfigMap 数据内容后，重新更新该对象就会出现如下所示的错误信息：
```sh
☸ ➜ kubectl apply -f immu-cm.yaml
The ConfigMap "immu-cm" is invalid: data: Forbidden: field is immutable when `immutable` is set
```

# Secret
ConfigMap 这个资源对象是 Kubernetes 当中非常重要的一个资源对象，一般情况下 ConfigMap 是用来存储一些非安全的配置信息，如果涉及到一些安全相关的数据的话用 ConfigMap 就非常不妥了，因为 ConfigMap 是明文存储的这时就需要用到另外一个资源对象了： Secret ， Secret 用来保存敏感信息。

创建 Secret 时，你可以使用 Secret 资源的 type 字段，或者与其等价的 kubectl 命令行参数（如果有的话）为其设置类型。 Secret 类型有助于对 Secret 数据进行编程处理。Kubernetes 提供若干种内置的类型，用于一些常见的使用场景。 针对这些类型，Kubernetes 所执行的合法性检查操作以及对其所实施的限制各不相同。

Secret 主要使用的有以下几种类型：
- Opaque：用户定义的任意数据
- kubernetes.io/dockercfg：~/.dockercfg 文件的序列化形式
- kubernetes.io/dockerconfigjson：~/.docker/config.json 文件的序列化形式
- kubernetes.io/service-account-token：服务账号令牌
- kubernetes.io/ssh-auth：用于 SSH 身份认证的凭据
- kubernetes.io/basic-auth：用于基本身份认证的凭据
- bootstrap.kubernetes.io/token：启动引导令牌数据
- kubernetes.io/tls: 用于 TLS 客户端或者服务器端的数据

上面是 Secret 对象内置支持的几种类型，通过为 Secret 对象的 type 字段设置一个非空的字符串值，也可以定义并使用自己 Secret 类型，如果 type 值为空字符串，则被视为 Opaque 类型。Kubernetes 并不对类型的名称作任何限制。不过，如果你要使用内置类型之一， 则你必须满足为该类型所定义的所有要求。

需要注意的是默认情况下，Kubernetes Secret 未加密存储在 APIServer 的底层数据存储 etcd 中，任何拥有 API访问权限的人都可以检索或修改 Secret，任何有权访问 etcd 的人也可以。此外，任何有权限在命名空间中创建 Pod 的人都可以使用该访问权限读取该命名空间中的任何 Secret。为了更安全地使用 Secret，我们可以执行以下步骤来加强安全：
- 为 Secret 启用静态加密。
- 以最小特权访问 Secret 并启用或配置 RBAC 规则。
- 限制 Secret 对特定容器的访问。
- 考虑使用外部 Secret 存储驱动。

在后续课程中我们也会陆续接触到这些方案。

## Opaque Secret
Secret 资源包含2个键值对： data 和 stringData，data 字段用来存储 base64 编码的任意数据，提供 stringData 字段是为了方便，它允许 Secret 使用未编码的字符串。 data 和 stringData 的键必须由字母、数字、-，_ 或 . 组成。

比如我们来创建一个用户名为 admin，密码为 admin321 的 Secret 对象，首先我们需要先把用户名和密码做 base64 编码：
```sh
[root@master yamlDir]#  echo -n "admin" | base64
YWRtaW4=
[root@master yamlDir]# echo -n "admin321" | base64
YWRtaW4zMjE=
```
然后我们就可以利用上面编码过后的数据来编写一个 YAML 文件：(secret-demo.yaml)
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: YWRtaW4zMjE=
```
然后我们就可以使用 kubectl 命令来创建，并查看描述
```sh
[root@master yamlDir]# kubectl apply -f secret-demo.yaml
secret/mysecret created
[root@master yamlDir]# kubectl get secret
NAME       TYPE     DATA   AGE
mysecret   Opaque   2      10s
[root@master yamlDir]# kubectl describe secret mysecret
Name:         mysecret
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  Opaque

Data
====
password:  8 bytes
username:  5 bytes
```
可以看到利用 describe 命令查看到的 Data 没有直接显示出来，如果想看 Data 里面的详细信息，同样我们可以输出成 YAML 文件进行查看：
```sh
[root@master yamlDir]# kubectl get secret mysecret -oyaml
apiVersion: v1
data:
  password: YWRtaW4zMjE=
  username: YWRtaW4=
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","data":{"password":"YWRtaW4zMjE=","username":"YWRtaW4="},"kind":"Secret","metadata":{"annotations":{},"name":"mysecret","namespace":"default"},"type":"Opaque"}
  creationTimestamp: "2024-02-29T10:02:27Z"
  name: mysecret
  namespace: default
  resourceVersion: "1228355"
  uid: c42f0208-018b-449e-afa9-523317730cbf
type: Opaque
```
对于某些场景，你可能希望使用 stringData 字段，这字段可以将一个非 base64 编码的字符串直接放入 Secret 中， 当创建或更新该 Secret 时，此字段将被编码。

比如当我们部署应用时，使用 Secret 存储配置文件，你希望在部署过程中，填入部分内容到该配置文件。例如，如果应用程序使用以下配置文件:
```yaml
apiUrl: "https://my.api.com/api/v1"
username: "<user>"
password: "<password>"
```
那就可以使用以下定义将其存储在 Secret 中:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
stringData:
  config.yaml: |
    apiUrl: "https://my.api.com/api/v1"
    username: <user>
    password: <password>
```
比如我们直接创建上面的对象后重新获取对象的话 config.yaml 的值会被编码：
```sh
➜  ~ kubectl get secret mysecret -o yaml
apiVersion: v1
data:
  config.yaml: YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IDx1c2VyPgpwYXNzd29yZDogPHBhc3N3b3JkPgo=
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"Secret","metadata":{"annotations":{},"name":"mysecret","namespace":"default"},"stringData":{"config.yaml":"apiUrl: \"https://my.api.com/api/v1\"\nusername: \u003cuser\u003e\npassword: \u003cpassword\u003e\n"},"type":"Opaque"}
  creationTimestamp: "2021-11-21T10:42:25Z"
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:config.yaml: {}
      f:metadata:
        f:annotations:
          .: {}
          f:kubectl.kubernetes.io/last-applied-configuration: {}
      f:type: {}
    manager: kubectl
    operation: Update
    time: "2021-11-21T10:42:25Z"
  name: mysecret
  namespace: default
  resourceVersion: "857340"
  uid: 5a28d296-5f53-4e4c-92f3-c1d7c952ace2
type: Opaque
```
创建好 Secret对象后，有两种方式来使用它：

- 以环境变量的形式
- 以Volume的形式挂载

### 环境变量
首先我们来测试下环境变量的方式，同样的，使用一个简单的 busybox 镜像来测试下:(secret1-pod.yaml)
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret1-pod
spec:
  containers:
  - name: secret1
    image: busybox
    command: [ "/bin/sh", "-c", "env" ]
    env:
    - name: USERNAME
      valueFrom:
        secretKeyRef:
          name: mysecret
          key: username
    - name: PASSWORD
      valueFrom:
        secretKeyRef:
          name: mysecret
          key: password
```
需要注意的是上面环境变量中定义的 secretKeyRef 字段，和我们前文的 configMapKeyRef 类似，一个是从 Secret 对象中获取，一个是从 ConfigMap 对象中获取，创建上面的Pod并查看Pod日志输出：
```sh
[root@master yamlDir]# kubectl apply -f secret1-pod.yaml
pod/secret1-pod created
[root@master yamlDir]# kubectl logs secret1-pod
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT=tcp://10.96.0.1:443
HOSTNAME=secret1-pod
SHLVL=1
HOME=/root
USERNAME=admin
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_SERVICE_HOST=10.96.0.1
PWD=/
PASSWORD=admin321
```
可以看到有 USERNAME 和 PASSWORD 两个环境变量输出出来。

### Volume 挂载
同样的我们用一个 Pod 来验证下 Volume 挂载，创建一个 Pod 文件：(secret2-pod.yaml)
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret2-pod
spec:
  containers:
  - name: secret2
    image: busybox
    command: ["/bin/sh", "-c", "ls /etc/secrets"]
    volumeMounts:
    - name: secrets
      mountPath: /etc/secrets
  volumes:
  - name: secrets
    secret:
     secretName: mysecret
```
创建Pod并查看输出日志：
```sh
[root@master yamlDir]# kubectl apply -f secret2-pod.yaml
pod/secret2-pod created
[root@master yamlDir]# kubectl logs secret2-pod
password
username
```
可以看到 Secret 把两个 key 挂载成了两个对应的文件。当然如果想要挂载到指定的文件上面，可以使用上一节课的方法：在 secretName 下面添加 items 指定 key 和 path，这个大家可以参考上节课 ConfigMap 中的方法去测试下。

## kubernetes.io/dockerconfigjson



## kubernetes.io/basic-auth

## kubernetes.io/ssh-auth

## kubernetes.io/tls

## kubernetes.io/service-account-token

# Secret vs ConfigMap
## 相同点


## 不同点