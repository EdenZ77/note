# 数组与切片的创建

在 Go 语言中，数组和切片是两种常用的数据结构。它们有不同的用途和特性。

## 数组

数组是一种固定长度的序列，存储相同类型的数据。

### 创建数组的方式

1. **直接声明并初始化：**

   ```go
   var arr [5]int
   ```

   这将创建一个长度为 5 的 `int` 类型的数组，所有元素的默认值为 0。

2. **声明并赋初值：**

   ```go
   arr := [5]int{1, 2, 3, 4, 5}
   ```

   这将创建一个长度为 5 的 `int` 类型的数组，并赋初值。

3. **使用省略号让编译器推断数组长度：**

   ```go
   arr := [...]int{1, 2, 3, 4, 5}
   ```

   编译器将根据提供的元素数量自动确定数组的长度。

4. **部分初始化：**

   ```go
   arr := [5]int{1, 2}
   ```

   这将创建一个长度为 5 的 `int` 类型的数组，其中前两个元素被赋值为 1 和 2，其余元素为 0。

## 切片

切片是一种动态数组，可以改变长度。切片不存储任何数据，它只是对底层数组的引用。

### 创建切片的方式

1. **基于数组创建切片：**

   ```go
   arr := [5]int{1, 2, 3, 4, 5}
   slice := arr[1:4] // 创建一个切片，包含 arr 的第 1 到第 3 个元素
   ```

2. **使用 `make` 函数：**

   ```go
   slice := make([]int, 5) // 创建一个长度、容量均为 5 的 int 类型切片，初始值为 0
   ```

   你也可以指定切片的容量：

   ```go
   slice := make([]int, 5, 10) // 创建一个长度为 5，容量为 10 的切片
   ```

3. **直接声明并初始化：**

   ```go
   slice := []int{1, 2, 3, 4, 5} // 创建一个包含 5 个元素的切片
   ```

4. **使用 `append` 函数：**

   ```go
   var slice []int
   slice = append(slice, 1, 2, 3) // 向切片添加元素
   ```

# 切片深入解读

> 参考资料：https://qcrao.com/post/dive-into-go-slice/

## 截取

截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置。

基于已有 slice 创建新 slice 对象，被称为 `reslice`。新 slice 和老 slice 共用底层数组，新老 slice 对底层数组的更改都会影响到彼此。基于数组创建的新 slice 对象也是同样的效果：对数组或 slice 元素作的更改都会影响到彼此。

值得注意的是，新老 slice 或者新 slice 老数组互相影响的前提是两者共用底层数组，如果因为执行 `append` 操作使得新 slice 底层数组扩容，移动到了新的位置，两者就不会相互影响了。所以，`问题的关键在于两者是否会共用底层数组`。

截取操作采用如下方式：

```golang
 data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
 slice := data[2:4:6] // data[low, high, max]
```

对 `data` 使用3个索引值，截取出新的 `slice`。这里 `data` 可以是数组或者 `slice`。`low` 是最低索引值，这里是闭区间，也就是说第一个元素是 `data` 位于 `low` 索引处的元素；而 `high` 和 `max` 则是开区间，表示最后一个元素只能是索引 `high-1` 处的元素，而最大容量则只能是索引 `max-1` 处的元素。

```golang
max >= high >= low
```

当 `high == low` 时，新 `slice` 为空。

还有一点，`high` 和 `max` 必须在老数组或者老 `slice` 的容量（`cap`）范围内。

来看一个例子，来自雨痕大佬《Go学习笔记》第四版，P43页，参考资料里有开源书籍地址。这里我会进行扩展，并会作详细说明：

## slice 和数组的区别在哪

slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。

数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 `[3]int` 和 `[4]int` 就是不同的类型。

而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。

## append 到底做了什么

先来看看 `append` 函数的原型：

```golang
func append(slice []Type, elems ...Type) []Type
```

append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 `...` 传入 slice，直接追加一个切片。

```golang
slice = append(slice, elem1, elem2)
slice = append(slice, anotherSlice...)
```

`append`函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。

```golang
append(slice, elem1, elem2)
append(slice, anotherSlice...)
```

所以上面的用法是错的，不能编译通过。

使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 `len-1` 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。

这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 `slice` 的容量是留了一定的 `buffer` 的。否则，每次添加元素的时候，都会发生迁移，成本太高。

新 slice 预留的 `buffer` 大小是有一定规律的。网上大多数的文章都是这样描述的：

> 当原 slice 容量小于 `1024` 的时候，新 slice 容量变成原来的 `2` 倍；原 slice 容量超过 `1024`，新 slice 容量变成原来的`1.25`倍。

我在这里先说结论：以上描述是错误的。

为了说明上面的规律是错误的，我写了一小段玩具代码：









