# 不同平台的Go汇编

> GPT4.0

.go源码被编译为Plan 9汇编时，针对不同的平台生成的汇编是不同的。不同的硬件平台有不同的指令集架构，这意味着同样的高层次代码在不同的目标平台上需要生成不同的汇编代码。Go编译器在编译过程中会根据目标平台生成适合该平台的汇编代码。

## 具体差异

1. **指令集架构**：
   - 不同的CPU架构（如x86-64、ARM等）有各自独特的指令集。
   - Go编译器需要根据目标平台生成相应的汇编指令，以确保生成的二进制代码能够在该平台上正确执行。

2. **寄存器使用**：
   - 不同的架构有不同数量和用途的寄存器。例如，x86-64架构有通用寄存器（如RAX、RBX等），而ARM架构则有R0-R15等寄存器。
   - 编译器需要根据目标平台的寄存器规范生成相应的汇编代码。

3. **调用约定**：
   - 不同平台可能有不同的函数调用约定（Calling Convention），这影响参数传递和返回值的处理方式。
   - Go编译器会遵循目标平台的调用约定生成相应的汇编代码，以确保函数调用和返回的正确性。

## 编译过程中的平台特异性处理

Go编译器在编译过程中，通过多个阶段处理平台特异性的问题。以下是一些关键点：

1. **前端处理**：
   - 编译器前端负责解析Go源码并生成抽象语法树（AST）。
   - 这部分通常是平台无关的。

2. **中间表示（IR）生成**：
   - 编译器将AST转换为平台无关的中间表示（如SSA）。
   - 在这个阶段，编译器进行一些平台无关的优化。

3. **平台特异性优化和代码生成**：
   - 在生成目标平台的汇编代码时，编译器需要考虑平台特异性。
   - Go编译器的SSA后端有针对不同平台的代码生成器，这些生成器负责将SSA中间表示转换为特定平台的汇编代码。

## 示例：x86-64 vs ARM 汇编

假设有以下简单的Go代码：

```go
package main

func Add(x, y int) int {
    return x + y
}
```

编译器会根据目标平台生成不同的汇编代码。

### x86-64 汇编

```asm
TEXT ·Add(SB), NOSPLIT, $0-16
    MOVQ x+0(FP), AX
    MOVQ y+8(FP), CX
    ADDQ CX, AX
    MOVQ AX, ret+16(FP)
    RET
```

### ARM 汇编

```asm
TEXT ·Add(SB), NOSPLIT, $0-16
    MOVD x+0(FP), R0
    MOVD y+8(FP), R1
    ADD R1, R0, R0
    MOVD R0, ret+16(FP)
    RET
```

在这个例子中，可以看到以下差异：

- **指令不同**：x86-64使用`MOVQ`和`ADDQ`指令，而ARM使用`MOVD`和`ADD`指令。
- **寄存器不同**：x86-64使用`AX`、`CX`寄存器，而ARM使用`R0`、`R1`寄存器。



# 深入Go的底层，带你走近一群有追求的人 

> 参考资料：https://qcrao.com/post/dive-into-go-asm/

## 什么是plan9汇编

我们知道，CPU是只认二进制指令的，也就是一串的0101；人类无法记住这些二进制码，于是发明了汇编语言。汇编语言实际上是二进制指令的文本形式，它与指令可以一一对应。

每一种CPU指令都是不一样的，因此对应的汇编语言也就不一样。人类写完汇编语言后，把它转换成二进制码，就可以被机器执行了。转换的动作由编译器完成。

Go汇编语言实际上来源于plan9汇编语言，而plan9汇编语言最初来源于Go语言作者之一的Ken Thompson为plan9系统所写的C语言编译器输出的汇编伪代码。

理解Go的汇编语言，哪怕只是一点点，都能对Go的运行机制有更深入的理解。比如我们以前讲的defer，如果从Go源码编译后的汇编代码来看，就能深刻地掌握它的底层原理。再比如，很多文章都会分析Go的函数参数传递都是值传递，如果把汇编代码秀出来，很容易就能得出结论。

## 汇编角度看函数调用及返回过程

假设我们有一个这样年幼无知的例子，求两个int的和，Go源码如下：

```go
package main

func main() {
	_ = add(3,5)
}

func add(a, b int) int {
	return a+b
}
```

使用如下命令得到汇编代码：

```
go tool compile -S main.go
```

`go tool compile`命令用于调用Go语言提供的底层命令工具，其中`-S`参数表示输出汇编格式。

我们现在只关心add函数的汇编代码：

```assembly
"".add STEXT nosplit size=19 args=0x18 locals=0x0
        0x0000 00000 (main.go:7)        TEXT    "".add(SB), NOSPLIT, $0-24
        0x0000 00000 (main.go:7)        FUNCDATA        $0, gclocals·54241e171da8af6ae173d69da0236748(SB)
        0x0000 00000 (main.go:7)        FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (main.go:7)        MOVQ    "".b+16(SP), AX
        0x0005 00005 (main.go:7)        MOVQ    "".a+8(SP), CX
        0x000a 00010 (main.go:8)        ADDQ    CX, AX
        0x000d 00013 (main.go:8)        MOVQ    AX, "".~r2+24(SP)
        0x0012 00018 (main.go:8)        RET
```

看不懂没关系，我目前也不是全部都懂，但是对于理解一个函数调用的整体过程而言，足够了。

```assembly
0x0000 00000 (main.go:7)        TEXT    "".add(SB), NOSPLIT, $0-24
```

这一行表示定义`add`这个函数，最后的数字`$0-24`，其中`0`表示函数栈帧大小为0；`24`表示参数及返回值的大小：参数是2个int型变量，返回值是1个int型变量，共24字节。

再看中间这四行：

```assembly
        0x0000 00000 (main.go:7)        MOVQ    "".b+16(SP), AX
        0x0005 00005 (main.go:7)        MOVQ    "".a+8(SP), CX
        0x000a 00010 (main.go:8)        ADDQ    CX, AX
        0x000d 00013 (main.go:8)        MOVQ    AX, "".~r2+24(SP)
```

代码片段中的第1行，将第2个参数`b`搬到`AX`寄存器；第2行将1个参数`a`搬到寄存器`CX`；第3行将`a`和`b`相加，相加的结果搬到`AX`；最后一行，将结果搬到返回参数的地址，这段汇编代码非常简单，来看一下函数调用者和被调者的栈帧图：

(SP)指栈顶，b+16(SP)表示参数1的位置，从SP往上增加16个字节，注意，前面的b仅表示一个标号；同样，a+8(SP)表示实参0；~r2+24(SP)则表示返回值的位置。

具体可以看下面的图：







