参考资料

> [https://www.cyub.vip/2022/08/20/Golang%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/](https://www.cyub.vip/2022/08/20/Golang调度机制浅析/)
>
> 刘丹冰：https://www.yuque.com/aceld/golang/srxd6d#d8bb8540
>
> 腾讯技术工程：https://zhuanlan.zhihu.com/p/586236582

# 总体概览

GMP模型概览图：

<img src="image/gmp.png" alt="img" style="zoom:80%;" />



1. Go 调度器的核心思想是：**尽可能复用线程 M**，避免频繁的线程创建和销毁；利用多核并行能力，限制同时运行（不包含阻塞）的 M 线程数等于 CPU 的核数； **Work Stealing 任务窃取机制**，M 可以从其他 M 绑定的 P 的运行队列偷取 G 执行；**Hand Off 交接机制**，为了提高效率，M 阻塞时，会将 M 上 P 的运行队列交给其他 M 执行。
2. 由于数据局部性，新创建的 G 优先放入本地队列，当本地队列已满（默认容量 = 256），调度器会：从本地队列中随机抽取一半的 G（约 128 个），与新创建的 G 一起放入全局队列，被转移的 G 在全局队列中的顺序是随机的。在调度循环中优先执行本地队列中的 G（无锁操作，高效），每执行 61 次本地调度后，会尝试从全局队列获取 G（通过计数器 `schedtick`实现）。高频本地调度（61 次）保证数据局部性，但定期访问全局队列（1/61）防止全局队列中的 G 饥饿。

# Goroutine调度器的GMP模型的设计思想

## GMP模型

Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。

P 的数量：

- 由启动时环境变量`$GOMAXPROCS`或者是由`runtime`的方法`GOMAXPROCS()`决定。需要注意的是，这个数量控制的是有多少个操作系统线程（物理线程）可以同时运行Go代码，而不是 goroutine 的数量。goroutine 是轻量级的协程，可以有数以万计的 goroutine 存在，但只有不超过`GOMAXPROCS`数量的 goroutine 能同时被调度到操作系统线程上运行。



## 调度器的设计策略

**复用线程(复用M)**：避免频繁的创建、销毁线程，而是对线程的复用。

- work stealing 机制：当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。
- hand off 机制：当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。



## M0 与 G0

`G0`(调度 Goroutine)：

- 定义与作用：`G0`是每个 M（操作系统线程）专属的 goroutine。它不代表用户代码，而是专供调度器本身使用的。
- 创建时机：每当一个 M 被创建时（包括 M0），运行时都会同时为这个 M 创建并绑定一个专属的 `G0`。这个 `G0`与 M 是共生关系，存在于该 M 的整个生命周期。
- 栈：`G0`使用自己的栈空间（大小固定，比普通 Goroutine 栈大得多，如 8KB/64KB vs 2KB，具体实现不同版本有差异）。关键操作运行在 `G0`栈上，包括：
  - 调度工作本身：查找下一个要运行的 G ，执行调度决策。
  - 执行垃圾回收相关的标记、终止等任务 (通过 `systemstack`切换到 `G0`执行)。
  - 处理内存分配 (大对象分配或栈扩容时可能用到 `G0`栈)。
  - 执行 defer 函数。
  - 执行 CGO 调用前的准备和切换栈。
- 全局的 `g0`：`runtime.m0`的 `g0`字段指向它自己的 `G0`。这个 `G0`也是第一个被创建的 `G0`。通常说“全局 `g0`” 就是指 `m0.g0`。

`M0`(初始 M，主线程)：

- 定义与作用：`M0`是 Go 程序启动的第一个（也是最初的）操作系统线程。它是程序执行的起点。
- 创建时机：`M0`不是通过标准调度机制创建的，而是由程序启动过程（通常在汇编代码中 `rt0_xxx.s`）直接建立的。
- 存储位置：`M0`的实例存储在全局变量 `runtime.m0` 中（程序的数据段）。与后续动态创建的 M 不同，`M0`本身及其 `g0`栈都是在编译/初始化时就分配好的，不在堆上。普通 M 通常通过 `runtime.newm`创建，并在堆上分配。
- 职责：
  - 初始化：负责在运行时环境完全建立起来之前执行最初始的配置工作（例如设置 `GOMAXPROCS`初始值，初始化内存管理等）。
  - 启动第一个 G：在运行时环境准备好之后，`M0`（使用它的 `G0`）会创建并调度第一个真正的用户 Goroutine，这个 G 就是运行 `runtime.main`函数的 G，它是整个程序的入口（它会调用用户的 `main.main`）。可以说，程序进入 `main()`之前的所有工作（从 main 函数角度来看）都是在 `M0`上或者由其协调完成的。
  - 后续行为：一旦第一个用户 G (`runtime.main`) 开始运行，`M0`在调度行为上就与其他动态创建的工作线程 M 没有本质区别了。它会进入自己的调度循环（使用其 `G0`），寻找可运行的 G 来执行。它也会参与 work stealing（工作窃取），也可能会被阻塞在系统调用上（然后解绑其 P）。

需要强调的是：

- `G0`最重要的作用是提供了一个独占的、安全的、大栈的上下文给 Go 运行时调度器和系统任务在对应的 M 上执行，避免与用户 G 的栈冲突。不仅仅是“负责调度”那么简单，GC 等关键操作也依赖它。
- `M0`的 `G0`栈也是预先静态分配的，符合其作为“启动设施”的角色。
- 虽然 `M0`启动了第一个用户 G (`runtime.main`)，但它很快就成为了一个普通的工作线程。程序运行过程中，所有 M（包括 M0）上的用户代码（`main.main`或任何其他的 `go func()`）最终都是在普通 G 上运行的，而不是在 `G0`上运行。普通的 G 运行在操作系统线程（M）提供的用户栈空间上（这个栈开始时通常很小，如 2KB，可增长）。


# Go调度器调度场景过程全解析

## (1)场景1：G1创建G2

P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用`go func()`创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。

<img src="image/image-20240723212408849.png" alt="image-20240723212408849" style="zoom:40%;" />

## (2)场景2：G1执行完毕

G1 运行完成后(函数：`goexit`)，M 上运行的 goroutine 切换为 G0，G0 负责调度时协程的切换（函数：`schedule`）。从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2 (函数：`execute`)。实现了线程 M1 的复用。

<img src="image/1650776536644-c6fba007-d952-4a22-8939-ca1a898a5c3c.png" alt="27-gmp场景2.png" style="zoom:40%;" />

## (3)场景3：G2开辟过多的G

假设每个 P 的本地队列只能存 4 个 G。G2 要创建了 6 个 G，前 4 个 G（G3, G4, G5, G6）已经加入 P1 的本地队列，P1本地队列满了。

<img src="image/1650776549767-57ceac17-5504-46ac-af56-0dba59359e8b.png" alt="28-gmp场景3.png" style="zoom:30%;" />

## (4)场景4：G2本地满再创建G7

G2 在创建 G7 的时候，发现 P1 的本地队列已满，需要执行负载均衡（把 P1 中本地队列中前一半的 G，还有新创建G转移到全局队列）

<img src="image/1650776570176-d9d5abd4-3a48-461c-a43c-6ef504c4038f.png" alt="29-gmp场景4.png" style="zoom:30%;" />

## (5)场景5：G2本地未满创建G8

G2 创建 G8 时，P1 的本地队列未满，所以 G8 会被加入到 P1 的本地队列。

<img src="image/1650776584395-dfb9c26b-b0a8-4c17-b46e-649302df87d5.png" alt="30-gmp场景5.png" style="zoom:30%;" />

G8 加入到 P1 点本地队列的原因还是因为 P1 此时在与 M1 绑定，而 G2 此时是 M1 在执行。所以 G2 创建的新的 G 会优先放置到自己的 M 绑定的 P 上。

## (6)场景6：唤醒正在休眠的M

规定：在创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行。

<img src="image/1650776600276-58bdcec4-00e6-4f24-89c8-e4f01fd1d9fb.png" alt="31-gmp场景6.png" style="zoom:60%;" />

假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程。

## (7)场景7：被唤醒的M2从全局队列取批量G

M2 尝试从全局队列(简称“GQ”)取一批 G 放到 P2 的本地队列（函数：`findrunnable()`）。M2 从全局队列取的 G 数量符合下面的公式：

```go
n =  min(len(GQ) / GOMAXPROCS +  1,  cap(LQ) / 2 )
```

至少从全局队列取 1 个 G，但每次不要从全局队列移动太多的 G 到 P 本地队列，给其他 P 留点。这是从全局队列到 P本地队列的负载均衡。

<img src="image/1650776688586-9207de08-5203-403f-8857-42942e84dcb1.jpeg" alt="32-gmp场景7.001.jpeg" style="zoom:60%;" />

假定我们场景中一共有 4 个 P（GOMAXPROCS 设置为 4，那么我们允许最多就能用 4 个 P 来供 M 使用）。所以 M2只从能从全局队列取 1 个 G（即G3）移动 P2 本地队列，然后完成从 G0 到 G3 的切换，运行 G3。（因为其他两个 P可以各自从全局 G 队列中获得一个 G，这样可以同时执行 4 个 G）

## (8)场景8：M2从M1中偷取G

假设 G2 一直在 M1 上运行，经过 2 轮后，M2 已经把 G7、G4 从全局队列获取到了 P2 的本地队列并完成运行（这里假设是 M2 把全局队列中的 G 执行完了），全局队列和 P2 的本地队列都空了，如场景8图的左半部分。

<img src="image/1650777780659-cef000df-3d46-4fd5-b0ed-3dc466bf1cd2.png" alt="33-gmp场景8.png" style="zoom:50%;" />

全局队列已经没有 G，那 M 就要执行 work stealing(偷取)：从其他有 G 的 P 偷取一半 G 过来，放到自己的 P 本地队列。P2 从 P1 的本地队列尾部取一半的 G，本例中一半则只有 1 个 G8，放到 P2 的本地队列并执行。

## (9)场景9：自旋线程的最大限制

G1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有goroutine 可以运行，M3 和 M4 处于自旋状态，它们不断寻找 goroutine。

<img src="image/1650777794441-a7ed7fc2-e495-4022-a3b6-581930e5acd0.png" alt="34-gmp场景9.png" style="zoom:50%;" />

为什么要让 M3 和 M4 自旋，自旋本质是在运行，线程在运行却没有执行 G，就变成了浪费 CPU，为什么不销毁现场，来节约 CPU 资源。因为创建和销毁也会浪费 CPU ，我们希望当有新 goroutine 创建时，立刻能有 M 运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费 CPU，所以系统中最多有`GOMAXPROCS`个自旋的线程(当前例子中的`GOMAXPROCS`=4，所以一共 4 个 P)，多余的没事做线程会让他们休眠。

## (10)场景10：G发生系统调用/阻塞

假定当前除了 M3 和 M4 为自旋线程，还有 M5 和 M6 为空闲的线程(没有得到 P 的绑定，注意我们这里最多就只能够存在 4 个 P，所以 P 的数量应该永远是 M>=P，大部分都是 M 在抢占需要运行的 P )，G8 创建了 G9，G8 进行了阻塞的系统调用，M2 和 P2 立即解绑，P2 会执行以下判断：如果 P2 本地队列有 G、全局队列有 G 或有空闲的 M，P2 都会立马唤醒 1 个 M 和它绑定，否则 P2 则会加入到空闲 P 列表，等待 M 来获取可用的 P。本场景中，P2 本地队列有G9，可以和其他空闲的线程 M5 绑定。

<img src="image/1650777810926-ca4030f3-f29a-4211-8722-677b229be440.png" alt="35-gmp场景10.png" style="zoom:60%;" />

当G执行阻塞性系统调用（如磁盘 I/O、未设置非阻塞的 socket 操作）时，操作系统将当前 M（线程）置为休眠状态，等待系统调用完成。

Go 运行时检测到 M 被阻塞，触发 `entersyscall`逻辑：1、解绑 P 和 M：P 从当前 M 剥离（P 的状态变为 `_Psyscall`）。2、P 寻找空闲 M：P 会尝试绑定其他空闲 M（或创建新 M）继续执行队列中的其他 G。

被阻塞的 G 随 M 一起休眠，等待系统调用完成。

系统调用结束后，M 被操作系统唤醒，调用 `exitsyscall`尝试恢复执行：

- 优先绑定原 P：如果原 P 空闲，则重新绑定 M 和 P，G 继续运行。
- 绑定其他 P：如果原 P 已被占用，则会尝试绑定其他空闲 P。
- 加入全局队列：若绑定失败，G 会被放入全局队列（Global Queue），等待被其他 P 调度。



## (11)场景11：G发生系统调用/非阻塞

G8 创建了 G9，假如 G8 进行了非阻塞系统调用（如网络 socket 的非阻塞读写）。

<img src="image/1650777823944-25f0ea1a-3431-457e-b4cf-342654a953b6.png" alt="36-gmp场景11.png" style="zoom:60%;" />

M2 和 P2 会解绑，但 M2 会记住 P2，然后 G8 和 M2 进入系统调用状态。当 G8 和 M2 退出系统调用时，会先尝试获取P2，如果无法获取，则获取空闲的 P，如果依然没有，G8 会被记为可运行状态，并加入到全局队列，M2 因为没有 P 的绑定而变成休眠状态(长时间休眠等待 GC 回收销毁)。

**流程**：

1. G 发起调用：

   Goroutine（G）执行非阻塞系统调用（如 `read(fd, buf, size)`，但 fd 是非阻塞的）。

2. 立即返回结果：

   - 如果数据就绪，系统调用成功返回，G 继续执行。
   - 如果数据未就绪（如 `EAGAIN`错误），系统调用立即返回失败。

3. 调度器介入：

   - G 因调用失败主动让出 CPU，调用 `gopark`将自身挂起，并注册到 NetPoller（Go 的 I/O 多路复用模块，如 epoll/kqueue）。
   - M 和 P 不分离：当前 M 继续执行其他 G（从 P 的本地队列获取）。

4. I/O 就绪后恢复：

   - 当数据就绪时，NetPoller 通知调度器，将 G 标记为可运行状态，放回 P 的本地队列等待执行。



# 面试题

## GOMAXPROCS设置过大

1. 线程（M）数量激增，上下文切换开销剧增

- 原理：`GOMAXPROCS`控制 P 的数量，每个 P 需要一个 M（操作系统线程）绑定才能执行 G。当 P 过多时，Go 运行时会创建大量 M（线程）来绑定这些 P。

- 问题：

  - 线程上下文切换开销：操作系统调度大量线程会消耗 CPU 时间，尤其在 CPU 核心数不足时，线程频繁切换导致有效计算时间减少。
  - 锁竞争加剧：全局资源（如全局 G 队列）的锁竞争加剧，进一步降低性能。


2. 自旋 M（Spinning Threads）浪费 CPU

- 原理：Go 调度器会保持少量自旋 M，以快速响应新创建的 G 。当 `GOMAXPROCS`过大时，自旋 M 的数量可能超过物理核心数。

- 问题：自旋 M 在无任务时仍持续占用 CPU ，导致 CPU 利用率虚高但实际吞吐量下降。


3. 内存占用暴涨

- 原理：每个 P 需要维护本地 G 队列（至少 256 个 G 的槽位）、缓存对象（如 `mcache`）等资源。每个 M（线程）默认占用 2MB 左右的栈内存（Linux 系统）。

- 问题：

  - P 内存开销：P 数量过多时，其元数据和缓存占用的内存显著增加（尤其在 GOMAXPROCS > 1000 时）。
  - M 内存开销：大量线程的栈内存消耗可能达到 GB 级别，甚至触发 OOM。

4. 调度延迟增加（Latency Spike）

- 原理：
  - P 数量过多时，工作窃取（Work Stealing）效率降低，需要扫描更多其他 P 的本地队列才能找到可窃取的 G。
  - 全局 G 队列竞争：所有 P 频繁访问全局队列，锁争用加剧，导致 G 的入队/出队延迟增加。
- 问题：高并发场景下，G 的调度延迟增大，影响实时性要求高的任务。

5. GC 性能下降

- 原理：

  Go 的 GC 需要 **STW（Stop-The-World）** 或 **并发标记**，其执行效率与 P 数量相关：

  - STW 阶段需暂停所有 P，P 越多暂停时间越长（协调开销增大）。
  - 并发标记阶段占用 P 资源，P 过多时标记任务分配的开销增加。

- 问题：GC 停顿时间（GC Pause）可能延长，影响应用响应速度。