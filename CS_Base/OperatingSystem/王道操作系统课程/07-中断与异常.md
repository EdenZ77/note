# 知识总览

![image-20240726061827426](image/image-20240726061827426.png)



# 中断的作用

![image-20240726061855336](image/image-20240726061855336.png)

# 中断的类型

![image-20240726061912205](image/image-20240726061912205.png)



# 内中断的例子

![image-20240726061944603](image/image-20240726061944603.png)

我们结合《Linux环境编程》中信号部分一起学习。硬件检测到了错误并通知内核，由内核发送相应的信号给相关进程。和硬件异常相关的信号见表6-1。

![image-20240726065102567](image/image-20240726065102567.png)

前面所讲的这四种硬件异常，一般是由程序自身引发的，不是由其他进程发送的信号引发的，并且这些异常都比较致命，以至于进程无法继续下去。所以这些信号产生之后，会立刻递送给进程。默认情况下，这四种信号都会使进程终止，并且产生core dump文件以供调试。对于这些信号，进程既不能忽略，也不能阻塞。

《Linux环境编程》中学习的信号指的是内核给进程传递的信号，然后进程根据信号进行相应的处理。而这里学习的信号指的是中断信号，这会让CPU执行处理中断信号的内核程序。而根据CPU获得中断信号的来源分为：CPU内部自己产生和外部传递给CPU。CPU有了中断信号之后呢，就会执行之前指定好的处理中断信号的内核程序。这个内核程序就会给对应的进程发送信号，你看看是不是串联起来了！



**信号是一种软件中断，用来处理异步事件。内核递送这些异步事件到某个进程，告诉进程某个特殊事件发生了。**这些异步事件，可能来自硬件，比如访问了非法的内存地址，或者除以0了；可能来自用户的输入，比如shell终端上用户在键盘上敲击了Ctrl+C；还可能来自另一个进程（一个进程可以使用 `kill` 系统调用向另一个进程发送 `SIGTERM` 信号；一个进程可以使用 `kill` 系统调用向另一个进程发送 `SIGSTOP` 信号，以暂停该进程的执行。），甚至有些来自进程自身（进程可以设置一个定时器，当定时器到期时，内核会发送 `SIGALRM` 信号给该进程）。



![image-20240726062007653](image/image-20240726062007653.png)

该例子就是程序想要执行系统调用，然后主动执行陷入指令。比如，某个进程调用`kill`系统调用向另一个进程发送信号。 

这两类例子都是CPU会产生中断信号，然后执行处理中断信号的内核程序。

# 外中断的例子

![image-20240726062042306](image/image-20240726062042306.png)

这个例子不是CPU自己产生的中断信号，而是外部时钟部件产生的中断信号传递给CPU。

# 中断的分类

![image-20240726062107099](image/image-20240726062107099.png)

这里内中断的分类，其实就是分为主动的系统调用与硬件故障（上面介绍的三种硬件故障）。

外中断的分类倒是没有什么问题。

# 中断机制的基本原理

![image-20240726062135888](image/image-20240726062135888.png)



# 知识回顾

![image-20240726062205665](image/image-20240726062205665.png)