# 信号

信号是一种软件中断，用来处理异步事件。内核递送这些异步事件到某个进程，告诉进程某个特殊事件发生了。这些异步事件，可能来自硬件，比如访问了非法的内存地址，或者除以0了；可能来自用户的输入，比如shell终端上用户在键盘上敲击了Ctrl+C；还可能来自另一个进程，甚至有些来自进程自身。

信号的本质是一种进程间的通信，一个进程向另一个进程发送信号，内核至少传递了信号值这个字段。实际上，通信的内容不止是信号值。

信号机制是Unix家族里一个古老的通信机制。传统的信号机制有一些弊端，更为严重的是，信号处理函数的执行流和正常的执行流同时存在，给编程带来了很多的麻烦和困扰，一不小心就可能掉入陷阱。本章将会介绍信号的方方面面，包括传统信号的弊端，Linux对信号机制的改进，以及信号机制里面的陷阱，希望对读者能有所帮助。

## 信号的完整生命周期

前文提到过，信号的本质是一种进程间的通信。进程之间约定好：如果发生了某件事情T（trigger），就向目标进程（destination process）发送某特定信号X，而目标进程看到X，就意识到T事件发生了，目标进程就会执行相应的动作A（action）。

接下来以配置文件改变为例，来描述整个过程。很多应用都有配置文件，如果配置文件发生改变，需要通知进程重新加载配置。一般而言，程序会默认采用SIGHUP信号来通知目标进程重新加载配置文件。

目标进程首先约定，只要收到SIGHUP，就执行重新加载配置文件的动作。这个行为称为信号的安装（installation），或者信号处理函数的注册。安装好了之后，因为信号是异步事件，不知道何时会发生，所以目标进程依然正常地干自己的事情。某年某月的某一天，管理员突然改变了配置文件，想通知这个目标进程，于是就向目标进程发送了信号。他可能在终端执行了`kill-SIGHUP`命令，也可能调用了C的API，不管怎样，信号产生了。这时候，Linux内核收到了产生的信号，然后就在目标进程的进程描述符里记录了一笔：收到信号SIGHUP一枚。Linux内核会在适当的时机，将信号递送（deliver）给进程。在内核收到信号，但是还没有递送给目标进程的这一段时间里，信号处于挂起状态，被称为挂起（pending）信号，也称为未决信号。内核将信号递送给进程，进程就会暂停当前的控制流，转而去执行信号处理函数。这就是一个信号的完整生命周期。

一个典型的信号会按照上面所述的流程来处理，但是实际情况要复杂得多，还有很多场景需要考虑，比如：

- 目标进程正在执行关键代码，不能被信号中断，需要阻塞某些信号，那么在这期间，信号就不允许被递送到进程，直到目标进程解除阻塞。
- 内核发现同一个信号已经存在，那么它该如何处理这种重复的信号，排队还是丢弃？
- 内核递送信号的时候，发现已有多个不同的信号被挂起，那它应该优先递送哪个信号？
- 对于多线程的进程，如果向该进程发送信号，应该由哪个线程来负责响应？

这些问题，在接下来的章节中会逐一得到解决。

## 信号的产生

作为进程间通信的一种手段，进程之间可以互相发送信号，然而发给进程的信号，通常源于内核，包括：

- 硬件异常。
- 终端相关的信号。
- 软件事件相关的信号。

### 硬件异常

硬件检测到了错误并通知内核，由内核发送相应的信号给相关进程。和硬件异常相关的信号见表6-1。
![](image/2024-05-07-09-47-04.png)


常见的能触发SIGBUS信号的场景有：

- 变量地址未对齐：很多架构访问数据时有对齐的要求。比如int型变量占用4个字节，因此架构要求int变量的地址必须为4字节对齐，否则就会触发SIGBUS信号。
- mmap映射文件：使用mmap将文件映射入内存，如果文件大小被其他进程截短，那么在访问文件大小以外的内存时，会触发SIGBUS信号。

虽然SIGFPE的后缀FPE是浮点异常（Float Point Exception）的含义，但是该异常并不限于浮点运算，常见的算术运算错误也会引发SIGFPE信号。最常见的就是“整数除以0”的例子。

SIGILL的含义是非法指令（illegal instruction）。一般表示进程执行了错误的机器指令。下面来看一段示例代码：

```c
typedef void(*FUNC)(void);
int main(void)
{
    const static unsigned char insn[4] = { 0xff, 0xff, 0xff, 0xff };
    FUNC function = (FUNC) insn;
    function();
}
```

上述代码中，因为函数地址不是合法有效的值，所以触发了SIGILL错误。发生这种错误，一般是函数指针遭到破坏，当执行函数指针指向的函数时，就会触发SIGILL信号。另外也可能是由指令集的演进引起的。比如，很多在新的体系结构中编译出来的可执行程序，在老的机器上可能会无法运行，故而在老机器上运行时，也可能产生SIGILL信号。

SIGSEGV是所有C程序员的噩梦。没经历几个刻骨铭心的段错误，很难成长为合格的C程序员。由于C语言可以直接操作指针，就像时常行走在河边的顽童很难避免湿鞋一样，程序员很难避免段错误，没有经验的程序员更是如此。常见的情况有：

- 访问未初始化的指针或NULL指针指向的地址。
- 进程企图在用户态访问内核部分的地址。
- 进程尝试去修改只读的内存地址。

当然，程序员不会直接去做这种傻事，一般来说是由于程序的错误，导致原本存放的指针被篡改成错乱值，因而在访问指针指向的变量时，触发了SIGSEGV信号。

前面所讲的这四种硬件异常，一般是由程序自身引发的，不是由其他进程发送的信号引发的，并且这些异常都比较致命，以至于进程无法继续下去。所以这些信号产生之后，会立刻递送给进程。默认情况下，这四种信号都会使进程终止，并且产生core dump文件以供调试。对于这些信号，进程既不能忽略，也不能阻塞。

### 终端相关的信号

### 软件事件相关的信号


![](image/2024-05-07-09-47-45.png)


## 信号的默认处理函数

![](image/2024-05-07-09-48-11.png)


![](image/2024-05-07-09-48-26.png)


![](image/2024-05-07-09-48-41.png)


![](image/2024-05-07-09-48-58.png)


![](image/2024-05-07-09-49-12.png)


## 信号的分类

## 传统信号的特点

![](image/2024-05-07-09-49-45.png)


### 信号中断系统调用的重启特性

![](image/2024-05-07-09-50-44.png)


![](image/2024-05-07-09-50-58.png)

![](image/2024-05-07-09-51-11.png)





## 信号的可靠性




## 信号的安装

## 信号的发送


### kill、tkill和tgkill

![](image/2024-05-07-09-52-15.png)


### sigqueue函数

![](image/2024-05-07-09-53-00.png)




## 信号与线程的关系


### 线程之间共享信号处理函数

![](image/2024-05-07-09-53-50.png)


### 线程有独立的阻塞信号掩码

![](image/2024-05-07-09-54-27.png)


### 私有挂起信号和共享挂起信号

![](image/2024-05-07-09-55-01.png)


![](image/2024-05-07-09-55-14.png)


![](image/2024-05-07-09-55-29.png)


## 等待信号

### pause函数

![](image/2024-05-07-09-56-12.png)


### sigwait函数和sigwaitinfo函数

![](image/2024-05-07-09-56-52.png)




## 通过文件描述符来获取信号



## 信号递送的顺序

![](image/2024-05-07-09-57-21.png)


## 异步信号安全

![](image/2024-05-07-09-57-45.png)


![](image/2024-05-07-09-57-58.png)


![](image/2024-05-07-09-58-11.png)


## 总结
Linux的signal机制是一种原始的进程间通信机制，传递的信息有限，很难传递复杂的消息，加上信号处理函数和进程处于两条执行逻辑流，会带来函数的重入问题，因此signal机制不适合作为进程间通信的主要手段。但是信号又不是完全无用的，对于某些不频繁发生的异步事件，还是可以使用signal来通知进程。