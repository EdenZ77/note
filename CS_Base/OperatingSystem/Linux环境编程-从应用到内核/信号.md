# 信号

信号是一种软件中断，用来处理异步事件。内核递送这些异步事件到某个进程，告诉进程某个特殊事件发生了。这些异步事件，可能来自硬件，比如访问了非法的内存地址，或者除以0了；可能来自用户的输入，比如shell终端上用户在键盘上敲击了Ctrl+C；还可能来自另一个进程，甚至有些来自进程自身。

信号的本质是一种进程间的通信，一个进程向另一个进程发送信号，内核至少传递了信号值这个字段。实际上，通信的内容不止是信号值。

信号机制是Unix家族里一个古老的通信机制。传统的信号机制有一些弊端，更为严重的是，信号处理函数的执行流和正常的执行流同时存在，给编程带来了很多的麻烦和困扰，一不小心就可能掉入陷阱。本章将会介绍信号的方方面面，包括传统信号的弊端，Linux对信号机制的改进，以及信号机制里面的陷阱，希望对读者能有所帮助。

## 信号的完整生命周期

前文提到过，信号的本质是一种进程间的通信。进程之间约定好：如果发生了某件事情T（trigger），就向目标进程（destination process）发送某特定信号X，而目标进程看到X，就意识到T事件发生了，目标进程就会执行相应的动作A（action）。

接下来以配置文件改变为例，来描述整个过程。很多应用都有配置文件，如果配置文件发生改变，需要通知进程重新加载配置。一般而言，程序会默认采用SIGHUP信号来通知目标进程重新加载配置文件。

目标进程首先约定，只要收到SIGHUP，就执行重新加载配置文件的动作。这个行为称为信号的安装（installation），或者信号处理函数的注册。安装好了之后，因为信号是异步事件，不知道何时会发生，所以目标进程依然正常地干自己的事情。某年某月的某一天，管理员突然改变了配置文件，想通知这个目标进程，于是就向目标进程发送了信号。他可能在终端执行了`kill-SIGHUP`命令，也可能调用了C的API，不管怎样，信号产生了。这时候，Linux内核收到了产生的信号，然后就在目标进程的进程描述符里记录了一笔：收到信号SIGHUP一枚。Linux内核会在适当的时机，将信号递送（deliver）给进程。在内核收到信号，但是还没有递送给目标进程的这一段时间里，信号处于挂起状态，被称为**挂起（pending）信号**，也称为**未决信号**。内核将信号递送给进程，进程就会暂停当前的控制流，转而去执行信号处理函数。这就是一个信号的完整生命周期。

一个典型的信号会按照上面所述的流程来处理，但是实际情况要复杂得多，还有很多场景需要考虑，比如：

- 目标进程正在执行关键代码，不能被信号中断，需要阻塞某些信号，那么在这期间，信号就不允许被递送到进程，直到目标进程解除阻塞。
- 内核发现同一个信号已经存在，那么它该如何处理这种重复的信号，排队还是丢弃？
- 内核递送信号的时候，发现已有多个不同的信号被挂起，那它应该优先递送哪个信号？
- 对于多线程的进程，如果向该进程发送信号，应该由哪个线程来负责响应？

这些问题，在接下来的章节中会逐一得到解决。

## 信号的产生

作为进程间通信的一种手段，进程之间可以互相发送信号，然而发给进程的信号，通常源于内核，包括：

- 硬件异常。
- 终端相关的信号。
- 软件事件相关的信号。

### 硬件异常

硬件检测到了错误并通知内核，由内核发送相应的信号给相关进程。和硬件异常相关的信号见表6-1。
![](image/2024-05-07-09-47-04.png)


常见的能触发SIGBUS信号的场景有：

- 变量地址未对齐：很多架构访问数据时有对齐的要求。比如int型变量占用4个字节，因此架构要求int变量的地址必须为4字节对齐，否则就会触发SIGBUS信号。
- mmap映射文件：使用mmap将文件映射入内存，如果文件大小被其他进程截短，那么在访问文件大小以外的内存时，会触发SIGBUS信号。

虽然SIGFPE的后缀FPE是浮点异常（Float Point Exception）的含义，但是该异常并不限于浮点运算，常见的算术运算错误也会引发SIGFPE信号。最常见的就是“整数除以0”的例子。

SIGILL的含义是非法指令（illegal instruction）。一般表示进程执行了错误的机器指令。下面来看一段示例代码：

```c
typedef void(*FUNC)(void);
int main(void)
{
    const static unsigned char insn[4] = { 0xff, 0xff, 0xff, 0xff };
    FUNC function = (FUNC) insn;
    function();
}
```

上述代码中，因为函数地址不是合法有效的值，所以触发了SIGILL错误。发生这种错误，一般是函数指针遭到破坏，当执行函数指针指向的函数时，就会触发SIGILL信号。另外也可能是由指令集的演进引起的。比如，很多在新的体系结构中编译出来的可执行程序，在老的机器上可能会无法运行，故而在老机器上运行时，也可能产生SIGILL信号。

SIGSEGV是所有C程序员的噩梦。没经历几个刻骨铭心的段错误，很难成长为合格的C程序员。由于C语言可以直接操作指针，就像时常行走在河边的顽童很难避免湿鞋一样，程序员很难避免段错误，没有经验的程序员更是如此。常见的情况有：

- 访问未初始化的指针或NULL指针指向的地址。
- 进程企图在用户态访问内核部分的地址。
- 进程尝试去修改只读的内存地址。

当然，程序员不会直接去做这种傻事，一般来说是由于程序的错误，导致原本存放的指针被篡改成错乱值，因而在访问指针指向的变量时，触发了SIGSEGV信号。

前面所讲的这四种硬件异常，一般是由程序自身引发的，不是由其他进程发送的信号引发的，并且这些异常都比较致命，以至于进程无法继续下去。所以这些信号产生之后，会立刻递送给进程。默认情况下，这四种信号都会使进程终止，并且产生core dump文件以供调试。对于这些信号，进程既不能忽略，也不能阻塞。

### 终端相关的信号

对于Linux程序员而言，终端操作是免不了的。终端有很多的设置，可以通过执行如下指令来查看：

```shell
root@LVS-OPS-172-22-175-192:~# stty -a
speed 38400 baud; rows 47; columns 147; line = 0;
intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R;
werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc ixany -imaxbel iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc
```

很重要的是，终端定义了如下几种信号生成字符：

- Ctrl+C：产生SIGINT信号。
- Ctrl+\：产生SIGQUIT信号。
- Ctrl+Z：产生SIGTSTP信号。

键入这些信号生成字符，相当于向前台进程组发送了对应的信号。

另一个和终端关系比较密切的信号是SIGHUP信号。很多程序员都遇到过这种问题：使用`ssh`登录到远程的Linux服务器，执行比较耗时的操作（如编译项目代码），却因为网络不稳定，或者需要关机回家，`ssh`连接被断开，最终导致操作中途被放弃而失败。

之所以会如此，是因为一个控制进程在失去其终端之后，内核会负责向其发送一个SIGHUP信号。在登录会话中，`shell`通常是终端的控制进程，控制进程收到SIGHUP信号后，会引发如下的连锁反应。

`shell`收到SIGHUP后会终止，但是在终止之前，会向由`shell`创建的前台进程组和后台进程组发送SIGHUP信号，为了防止处于停止状态的任务接收不到SIGHUP信号，通常会在SIGHUP信号之后，发送SIGCONT信号，唤醒处于停止状态的任务。前台进程组和后台进程组的进程收到SIGHUP信号，默认的行为是终止进程，这也是前面提到的耗时任务会中途失败的原因。

注意，单纯地将命令放入后台执行（通过`&`符号，如下所示），并不能摆脱被SIGHUP信号追杀的命运。

```shell
command &
root@LVS-OPS-172-22-175-192:~# sleep 20000 &
[1] 3908009
root@LVS-OPS-172-22-175-192:~# ps ajxf |grep 3388078
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
3387799 3388078 3388078 3388078 pts/0    3915694 Ss       0   0:00  |   \_ -bash
3388078 3908009 3908009 3388078 pts/0    3915694 S        0   0:00  |   |   \_ sleep 20000
3388078 3915694 3915694 3388078 pts/0    3915694 R+       0   0:00  |   |   \_ ps ajxf
3388078 3915695 3915694 3388078 pts/0    3915694 S+       0   0:00  |   |   \_ grep --color=auto 3388078

```

那么如何让进程在后台稳定地执行而不受终端连接断开的影响呢？可以采用如下方法。

**1.nohup**

可以使用如下方式执行命令：

```shell
nohup command
```

标准输入会重定向到`/dev/null`，标准输出和标准错误会重定向到`nohup.out`，如果无权限写入当前目录下的`nohup.out`，则会写入`home`目录下的`nohup.out`。

**2.setsid**

使用如下方式执行命令：

```shell
setsid command
```

这种方式和`nohup`的原理不太一样。`nohup`仅仅是使启动的进程不再响应SIGHUP信号，但是`setsid`则完全不属于`shell`所在的会话了，并且其父进程也已经不是`shell`而是`init`进程了。

```shell
manu@manu-hacks:~$ nohup sleep 200 &
[1] 11686
nohup: 忽略输入并把输出追加到"nohup.out"
manu@manu-hacks:~$ ps -o cmd,pid,ppid,pgid,sid,etime
CMD                           PID  PPID  PGID   SID     ELAPSED
-bash                       11365 11364 11365 11365       03:59
sleep 200                   11686 11365 11686 11365       00:30
ps -o cmd,pid,ppid,pgid,sid 11750 11365 11750 11365       00:00
manu@manu-hacks:~$ setsid sleep 300 &
[1] 11910
[1]+  已完成               setsid sleep 300
manu@manu-hacks:~$ ps -p 11912 -o cmd,pid,ppid,pgid,sid,etime
CMD                           PID  PPID  PGID   SID     ELAPSED
sleep 300                   11912     1 11912 11912       00:48
```

**3.disown**

很多情况下，启动命令时，忘记了使用`nohup`或`setsid`，可还有办法亡羊补牢？

答案是使用作业控制里面的`disown`，方法如下：

```shell
manu@manu-hacks:~$ sleep 1004 &
[1] 13861  # 这个输出显示了作业的信息。[1] 表示这是第一个作业，13861 是该作业的进程 ID。
manu@manu-hacks:~$ jobs -l # 这个命令用于列出当前 shell 中的作业。-l 选项表示显示作业的 PID 和作业状态。
[1]+ 13861 Running             sleep 1004 &
manu@manu-hacks:~$ disown %1 # 这个命令将作业 %1（即第一个作业）从 shell 的作业控制中分离。这意味着即使退出当前 shell，该作业仍会继续在后台运行。
manu@manu-hacks:~$ jobs -l
manu@manu-hacks:~$ exit # 这个命令用于退出当前 shell 会话。在这种情况下，由于之前使用了 disown 命令分离了作业，即使退出当前 shell，sleep 1004 这个作业仍会继续在后台运行，不受影响。
```

使用`disown`之后，`shell`退出时，就不会向这些进程发送SIGHUP信号了。在另一个终端上，仍然可以看到`sleep 1004`在运行：

```shell
manu@manu-hacks:~$ ps -ef|grep sleep
manu     13861     1  0 12:42 ?        00:00:00 sleep 1004
```

当然，还有其他的方法可以做到这点，如`screen`命名。对这个感兴趣的朋友可以阅读网上的参考资料。

### 软件事件相关的信号

软件事件触发信号产生的情况也比较多：

- 子进程退出，内核可能会向父进程发送SIGCHLD信号。
- 父进程退出，内核可能会给子进程发送信号。
- 定时器到期，给进程发送信号。

我们已熟知子进程退出时会向父进程发送SIGCHLD信号。这点在第4章中已经做了很详细的分析。

与子进程退出向父进程发送信号相反，有时候，进程希望父进程退出时向自己发送信号，从而可以得知父进程的退出事件。Linux也提供了这种机制。

每一个进程的进程描述符`task_struct`中都存在如下成员变量：

```c
int pdeath_signal;  /*  The signal sent when the parent dies  */
```

如果父进程退出，子进程希望收到通知，那么子进程可以通过执行如下代码来做到：

```c
prctl(PR_SET_PDEATHSIG, sig);
```

父进程退出时，会遍历其子进程，发现有子进程很关心自己的退出，就会向该子进程发送子进程希望收到的信号。

很多定时器相关的函数，背后都牵扯到信号，具体见表6-2（表6-2　定时器相关的信号）。


![](image/2024-05-07-09-47-45.png)

## 信号的默认处理函数

从上一节可以看出，信号产生的源头有很多。那么内核将信号递送给进程后，进程会执行什么操作呢？

很多信号尤其是传统的信号，都会有默认的信号处理方式。如果我们不改变信号的处理函数，那么收到信号之后，就会执行默认的操作。

信号的默认操作有以下几种：

- 显式地忽略信号：即内核将会丢弃该信号，信号不会对目标进程产生任何影响。
- 终止进程：很多信号的默认处理是终止进程，即将进程杀死。
- 生成核心转储文件并终止进程：进程被杀死，并且产生核心转储文件。核心转储文件记录了进程死亡现场的信息。用户可以使用核心转储文件来调试，分析进程死亡的原因。
- 停止进程：停止进程不同于终止进程，终止进程是进程已经死亡，但是停止进程仅仅是使进程暂停，将进程的状态设置成TASK_STOPPED，一旦收到恢复执行的信号，进程还可以继续执行。
- 恢复进程的执行：和停止进程相对应，某些信号可以使进程恢复执行。

这5种行为的简单标记如下：

- ignore
- terminate
- core
- stop
- continue

事实上，根据信号的默认操作，可以将传统信号分成5派，具体见表6-3到表6-7。

**表6-3　ignore派的信号**

`SIGCHLD` 信号是属于子进程状态改变的信号类别。当子进程改变状态时，内核会向父进程发送 `SIGCHLD` 信号，以通知父进程子进程的状态变化，父进程可以通过捕获这个信号来处理子进程的状态改变。通常情况下，父进程会调用 `wait()` 或 `waitpid()` 等系统调用来获取子进程的退出状态，以避免僵尸进程的产生。

![](image/2024-05-07-09-48-11.png)

**表6-4　terminate派的信号**

![](image/2024-05-07-09-48-26.png)

**表6-5　core派的信号**

![](image/2024-05-07-09-48-41.png)

**表6-6　stop派的信号**

![](image/2024-05-07-09-48-58.png)

**表6-7　continue派的信号**

![](image/2024-05-07-09-49-12.png)

信号的这些默认行为是非常有用的。比如停止行为和恢复执行。系统可能有一些备份的工作，这些工作优先级并不高，但是却消耗了大量的I/O资源，甚至是CPU资源（比如需要先压缩再备份）。这样的工作一般是在夜深人静，业务稀少的时候进行的。在业务比较繁忙的情况下，如果备份工作还在进行，则可能会影响到业务。这时候停止和恢复就非常有用了。在业务繁忙之前，可以通过SIGSTOP信号将备份进程暂停，在几乎没有什么业务的时候，通过SIGCONT信号使备份进程恢复执行。

很多信号产生核心转储文件也是非常有意义的。一般而言，程序出错才会导致SIGSEGV、SIGBUS、SIGFPE、SIGILL及SIGABRT等信号的产生。生成的核心转储文件保留了进程死亡的现场，提供了大量的信息供程序员调试、分析错误产生的原因。核心转储文件的作用有点类似于航空中的黑盒子，可以帮助程序员还原事故现场，找到程序漏洞。

很多情况下，默认的信号处理函数，可能并不能满足实际的需要，这时需要修改信号的信号处理函数。信号发生时，不执行默认的信号处理函数，改而执行用户自定义的信号处理函数。为信号指定新的信号处理函数的动作，被称为信号的安装。glibc提供了`signal`函数和`sigaction`函数来完成信号的安装。`signal`出现得比较早，接口也比较简单，`sigaction`则提供了精确的控制。

## 信号的分类

在Linux的`shell`终端，执行`kill -l`，可以看到所有的信号：

```shell
 1) SIGHUP      2) SIGINT         3) SIGQUIT        4) SIGILL          5) SIGTRAP
 6) SIGABRT     7) SIGBUS         8) SIGFPE         9) SIGKILL        10) SIGUSR1
11) SIGSEGV    12) SIGUSR2       13) SIGPIPE       14) SIGALRM        15) SIGTERM
16) SIGSTKFLT  17) SIGCHLD       18) SIGCONT       19) SIGSTOP        20) SIGTSTP
21) SIGTTIN    22) SIGTTOU       23) SIGURG        24) SIGXCPU        25) SIGXFSZ
26) SIGVTALRM  27) SIGPROF       28) SIGWINCH      29) SIGIO          30) SIGPWR
31) SIGSYS      34) SIGRTMIN     35) SIGRTMIN+1   36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5   40) SIGRTMIN+6   41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10  45) SIGRTMIN+11  46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15  50) SIGRTMAX-14  51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10  55) SIGRTMAX-9   56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5   60) SIGRTMAX-4   61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

这些信号可以分成两类：

- 可靠信号。
- 不可靠信号。

信号值在[1，31]之间的所有信号，都被称为不可靠信号；在[SIGRTMIN，SIGRTMAX]之间的信号，被称为可靠信号。

不可靠信号是从传统的Unix继承而来的。早期Unix系统信号的机制并不完备，在实践过程中暴露了很多弊端，因此把这些早期出现的信号值在[1，31]之间的信号称之为不可靠信号。所谓不可靠，指的是发送的信号，内核不一定能递送给目标进程，信号可能会丢失。

随着时间的流逝，人们意识到原有的信号机制存在弊端。但是[1，31]之间的信号存在已久，在很多应用中被广泛使用，出于兼容性的考虑，不能改变这些信号的行为模式，所以只能新增信号。新增的信号就是我们今天看到的在[SIGRTMIN，SIGRTMAX]范围内的信号，它们被称为可靠信号。

对信号有了初步了解后，知道`signal`和`sigaction`函数接口的读者可能会产生误解，认为用`signal`函数安装、用`kill`函数（或者`tkill`函数）发送的信号，就是不可靠信号；用`sigaction`函数安装、用`sigqueue`函数发送的信号，就是可靠信号。这种理解是错误的。信号的可靠与否，完全取决于信号的值，而与采用哪种方式安装或发送无关。

说了这么多，不可靠信号和可靠信号的根本差异到底在哪里？根本差异在于收到信号后，内核有不同的处理方式。

对于不可靠信号，内核用位图来记录该信号是否处于挂起状态。如果收到某不可靠信号，内核发现已经存在该信号处于未决状态，就会简单地丢弃该信号。因此发送不可靠信号，信号可能会丢失，即内核递送给目标进程的次数，可能小于信号发送的次数。

对于可靠信号，内核内部有队列来维护，如果收到可靠信号，内核会将信号挂到相应的队列中，因此不会丢失。严格说来，内核也设有上限，挂起信号的个数也不能无限制地增大，因此只能说，在一定范围之内，可靠信号不会被丢弃。

如果细心观察从`kill -l`列出的信号，可以看出，其中少了32号信号和33号信号。这两个信号（SIGCANCEL和SIGSETXID）被NPTL这个线程库征用了，用来实现线程的取消。从内核层来说，32号信号应该是最小的实时信号（SIGRTMIN），但是由于32号和33号被glibc内部征用了，所以glibc将SIGRTMIN设置成了34号信号。

## 传统信号的特点

前文提到过，`signal`是一个古老的机制，早期的信号在使用过程中，暴露出了一些弊端，那么早期的信号机制有什么弊端，表现出了什么样的行为模式呢？今天Linux下的glibc提供的信号函数是否解决了这些弊端，它又表现出了什么样的行为模式呢？下面来一探究竟。

传统的`signal`机制，分为System V风格和BSD风格的`signal`。

glibc提供了`signal`函数来注册用户定义的信号处理函数，代码如下：

```c
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

除此以外，Linux还提供了如下两个接口供我们“考古”，下面来探查一下`signal`机制的演化：

```c
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t sysv_signal(int signum, sighandler_t handler);
sighandler_t bsd_signal(int signum, sighandler_t handler)
```

从接口上看，存在4种signal函数，见表6-8。

![](image/2024-05-07-09-49-45.png)

接下来用实验的方法，测试各种不同的信号机制表现出来的行为模式，帮助大家体会传统信号的特点和弊端，以及学习Linux下glibc提供的`signal`函数的行为特性：

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <errno.h>
#include <sys/syscall.h>
#define MSG "OMG , I catch the signal SIGINT\n"
#define MSG_END "OK,finished process signal SIGINT\n"
int do_heavy_work()
{
    int i ;
    int k;
    srand(time(NULL));
    for(i = 0 ; i < 100000000;i++)
    {
             k = rand()%1234589;
    }
    return 0;
}
void signal_handler(int signo)
{
    write(2,MSG,strlen(MSG));
    do_heavy_work();
    write(2,MSG_END,strlen(MSG_END));
}
int main()
{
    char input[1024] = {0};
#if defined SYSCALL_SIGNAL_API
    if(syscall(SYS_signal ,SIGINT,signal_handler) == -1)
#elif defined SYSV_SIGNAL_API
    if(sysv_signal(SIGINT,signal_handler) == SIGERR)
#elif defined BSD_SIGNAL_API
    if(bsd_signal(SIGINT,signal_handler) == SIGERR)
#else
    if(signal(SIGINT,signal_handler) == SIG_ERR)
#endif
    {
        fprintf(stderr,"signal failed\n");
        return -1;
    }
    printf("input a string:\n");
    if(fgets(input,sizeof(input),stdin)== NULL)
    {
        fprintf(stderr,"fgets failed(%s)\n",strerror(errno));
        return -2;
    }
    else
    {
        printf("you entered:%s",input);
    }
    return 0;
}
```

斜体的地方是这个测试程序的核心，这个函数分别采用了Linux操作系统提供的signal系统调用、System V风格的sysv_signal、BSD风格的bsd_signal，还有glibc提供的标准API signal函数。下面来分别体会它们之间的不同之处。

```shell
gcc -o systemcall_signal -DSYSCALL_SIGNAL_API    signal_comp.c
gcc -o sysv_signal    -DSYSV_SIGNAL_API          signal_comp.c
gcc -o bsd_signal     -DBSD_SIGNAL_API           signal_comp.c
gcc -o glibc_signal                              signal_comp.c
```

这里分别生成了4种风格的测试程序，接下来就可以验证它们的特性了。

因为在x86_64位系统上，glibc的头文件并没有声明signal系统调用，因此，无法使用syscall函数来调用signal系统调用。详情可以参阅bits/syscall.h。不得已，只能在32位机器上做测试，比较四种函数语义上的差别。后面的输出都是在32位机器上的输出，希望不会给大家带来困扰。

### 信号的ONESHOT特性

传统的System V风格的signal，其注册的信号处理函数是一次性的，信号递送给目标进程之后，信号处理函数会变成默认值SIG_DFL。

```shell
manu@manu-hacks:~/code/c/self/signal$ ./sysv_signal
input a string:
hello
you entered:hello
manu@manu-hacks:~/code/c/self/signal$ ./sysv_signal
input a string:
hello^COMG , I catch the signal SIGINT
^C
manu@manu-hacks:~/code/c/self/signal$
```

可以看到第一次实验的时候，输入一个字符串，敲击回车，正常显示了输入的字符串。第二次输入结束之前，按Ctrl+C键，系统会向进程发送SIGINT信号，进程收到信号后，执行了信号处理函数（打印出了OMG，I catch the signal SIGINT），再次向进程发送SIGINT信号，进程就退出了。

可见，在System V风格的信号处理机制中，安装的信号处理函数是一次性的，内核把信号递送出去后，信号处理函数恢复成默认值SIG_DFL。因为SIGINT信号的默认处理是终止进程，所以进程就退出了。

Linux系统调用也是如此，信号处理函数同样是一次性的：

```shell
manu@manu-hacks:signal$ ./systemcall_signal
input a string:
hello
you entered:hello
manu@manu-hacks:signal$ ./systemcall_signal
input a string:
hello^COMG , I catch the signal SIGINT
^C
manu@manu-hacks:signal$
```

对于这种风格，内核中有个很形象的宏来描述这种行为模式，即SA_ONESHOT。

System V风格的`singal`处理机制就像老式的单发手枪，每次射击完之后，都要重新上子弹，即信号处理函数触发之后，要想重复触发，必须再次安装信号处理函数。

对于信号而言，是用标志位来控制信号的ONESHOT行为模式的，这个标志位是：

```c
/*架构相关，对于x86平台*/
#define SA_RESETHAND    0x80000000u
#define SA_ONESHOT SA_RESETHAND
```

当内核递送信号给进程时，如果发现同时满足以下两个条件，则会将信号处理函数恢复成默认函数：

- 信号处理函数不是默认值。
- 信号处理函数的标志位中，SA_ONESHOT标志置位。

这部分控制逻辑，出现于内核的`get_signal_to_deliver`函数中：

```c
int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,
              struct pt_regs *regs, void *cookie)
{
        ...
        if (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */
            continue;
        if (ka->sa.sa_handler != SIG_DFL) {
            /* Run the handler.  */
            *return_ka = *ka;
            if (ka->sa.sa_flags & SA_ONESHOT)
                ka->sa.sa_handler = SIG_DFL;
            break; /* will return non-zero "signr" value */
        }
        ...
}
```

使用strace来追踪`sysv_signal`的执行，可以看到有如下的系统调用：

```c
rt_sigaction(SIGINT, {0x8048756, [], SA_INTERRUPTSA_NODEFER|SA_RESETHAND}, {SIG_DFL, [], 0}, 8) = 0
```

BSD风格的`signal`和glibc的`signal`函数已经不存在ONESHOT的问题了，代码如下所示：

```shell
manu@manu-hacks:signal$ ./bsd_signal
input a string:
hello^COMG , I catch the signal SIGINT
^COK,finished process signal SIGINT
OMG , I catch the signal SIGINT
OK,finished process signal SIGINT
^COMG , I catch the signal SIGINT
OK,finished process signal SIGINT
manu@manu-hacks:signal$ ./glibc_signal
input a string:
hello^COMG , I catch the signal SIGINT
^COK,finished process signal SIGINT
OMG , I catch the signal SIGINT
^COK,finished process signal SIGINT
OMG , I catch the signal SIGINT
OK,finished process signal SIGINT
```

通过`strace`追踪`bsd_signal`和`glibc_signal`执行的系统调用，可以看到，两者调用`rt_sigaction`系统调用时都没有设置SA_ONESHOT的标志位。

```c
rt_sigaction(SIGINT, {0x8048736, [INT], SA_RESTART}, {SIG_DFL, [], 0}, 8) = 0
```



### 信号执行时屏蔽自身的特性

在执行信号处理函数期间，很有可能会收到其他的信号，当然也有可能再次收到正在处理的信号。如果在处理A信号期间再次收到A信号，会发生什么呢？

对于传统的System V信号机制，在信号处理期间，不会屏蔽对应的信号，而这就会引起信号处理函数的重入。这算是传统的System V信号机制的另一个弊端了。BSD信号处理机制修正了这个缺陷。当然了，BSD信号处理机制只是屏蔽了当前信号，并没有屏蔽当前信号以外的其他信号。

来比较下System V和BSD `signal`机制的区别。

System V风格的系统调用：

```c
rt_sigaction(SIGINT, {0x8048756, [], SA_INTERRUPT|SA_NODEFER|SA_RESETHAND}, {SIG_DFL, [], 0}, 8) = 0
```

BSD风格的系统调用：

```c
rt_sigaction(SIGINT, {0x8048736, [INT], SA_RESTART}, {SIG_DFL, [], 0}, 8) = 0
```

在上面的输出中，中括号内的是信号执行期间需要暂时屏蔽的信号。

BSD风格的信号处理机制，在安装信号的时候，会将自身这个信号添加到信号处理函数的屏蔽集合中。如果在执行A信号的信号处理函数期间，再次收到A信号，那么当前的A信号处理流程则不会被新来A信号打断。简单地说，就是不会嵌套了。

System V风格的信号，在其信号处理期间没有屏蔽任何信号，换句话说，执行信号处理函数期间，处理流程可以被任意信号中断，包括正在处理的信号。

从前面的实验可以看出，BSD风格的信号处理函数“OMG，I catch the signal SIGINT”，以及“OK，finished process signal SIGINT”总是成对出现的，不可能连续出现两个“OMG，I catch the signal SIGINT”，原因就是SIGINT信号在信号处理函数执行期间被暂时屏蔽了。

内核是如何做到这一点的？

完整的信号递送流程大致如此：内核首先调用`get_signal_to_deliver`，在挂起的信号集合中选择一个信号，递送给进程，选择完毕后，调用`handler_signal`函数。`handler_signal`函数的作用是为执行信号处理函数做准备。

```c
void handler_signal(int sig, siginfo_t *info, struct k_sigaction *ka,
            struct pt_regs *regs, int stepping)
{
    sigset_t blocked;
    ...
    clear_restore_sigmask();
    sigorsets(&blocked, &current->blocked, &ka->sa.sa_mask);
    if (!(ka->sa.sa_flags & SA_NODEFER))
        sigaddset(&blocked, sig);
    set_current_blocked(&blocked);
    tracehook_signal_handler(sig, info, ka, regs, stepping);
}
```

从上面代码中不难看出，如果信号没有设置SA_NODEFER标志位，正在处理的信号就必须在信号处理程序执行期间被阻塞。

System V风格的`signal`机制为何会出现不屏蔽自身信号的情况？原因就是`sysv_signal函`数，在调用`rt_sigaction`系统调用时加上了SA_NODEFER标志位，如下：

```c
rt_sigaction(SIGINT, {0x8048756, [], SA_INTERRUPT|SA_NODEFER|SA_RESETHAND}, {SIG_DFL, [], 0}, 8) = 0
```



### 信号中断系统调用的重启特性

系统调用在执行期间，很可能会收到信号，此时进程可能不得不从系统调用中返回，去执行信号处理函数。对于执行时间比较久的系统调用（如wait、read等）被信号中断的可能性会大大增加。系统调用被中断后，一般会返回失败，并置错误码为EINTR。

如果程序员希望处理完信号之后，被中断的系统调用能够重启，则需要通过判断errno的值来解决，即如果发现错误码是EINTR，就重新调用系统调用。来看下面的例子：

```shell
manu@manu-hacks:~/code/c/self/signal$ ./sysv_signal
input a string:
^COMG , I catch the signal SIGINT
OK,finished process signal SIGINT
fgets failed(Interrupted system call)
```

通过strace可以看到，`fgets`调用了`read`系统调用，而`read`系统调用因为等待用户输入而陷入长时间的阻塞。在阻塞过程中，收到了一个SIGINT信号，导致`read`系统调用被中断，返回了错误码EINTR。

Linux世界中的很多系统调用都会遭遇这种情景，尤其是`read`、`wait`这种可能比较耗时的系统调用。《Unix系统编程：通信、并发和线程》一书中存在很多类似的例子：

```c
pid_t r_wait(int *stat_loc)
{
    int retval;
    while(((retval = wait(stat_loc)) ==-1 && (errno == EINTR)){
        ;}
    return retval;
}
```

这种封装就是用来应对系统调用被信号中断的场景的。当系统调用被信号中断时，程序并不认为这是一种无法处理的错误，相反，程序完全可以通过重新调用系统调用，来完成其想做的事情。

在System V信号机制下，系统调用如果被信号中断，则会返回-1，并置errno为EINTR，而不会主动重启被信号中断的系统调用。

细细想来，如果所有的系统调用都要判断返回值是否为EINTR，是的话，则重启系统调用，那么程序员就太累了。BSD风格的signal机制提供了另外一种思路，即如果系统调用被信号中断，内核会在信号处理函数结束之后，自动重启系统调用，无须程序员再次调用系统调用。

Linux操作系统提供了一个标志位SA_RESTART来告诉内核，被信号中断后是否要重启系统调用。如果该标志位为1，则表示如果系统调用被信号中断，那么内核会自动重启系统调用。

BSD风格的`signal`函数和`glibc`的函数，毫无意外地都带有该标志位：

```c
rt_sigaction(SIGINT, {0x8048736, [INT], SA_RESTART}, {SIG_DFL, [], 0}, 8) = 0
```

由于BSD风格的`signal`存在这个标志SA_RESTART，因此`fgets`不会像System V的`signal`一样，返回错误码：

```shell
manu@manu-hacks:~/code/c/self/signal$ ./bsd_signal
input a string:
hello^COMG , I catch the signal SIGINT
OK,finished process signal SIGINT
^COMG , I catch the signal SIGINT
OK,finished process signal SIGINT
```

非常不幸的是，并不是所有的系统调用对信号中断都表现出同样的行为。某些系统调用哪怕设置了SA_RESTART的标志位，也绝不会自动重启。

那么问题就来了，在Linux下，如果信号处理函数设置了SA_RESTART，哪些阻塞型的系统调用遭到信号中断后，可以自动重启，哪些系统调用又是死活也无法自动重启的呢？

表6-9列出了设置SA_RESTART标志位后，可以自动重启的阻塞型系统调用。

![](image/2024-05-07-09-50-44.png)

表6-10是设置了SA_RESTART标志位，也不会重启的系统调用。

![](image/2024-05-07-09-50-58.png)

太多了，记不住怎么办？man来帮忙。通过`man 7 signal`就可以获得这些信息。

通过前面三节的测试，可以得到表6-11中的结论。

![](image/2024-05-07-09-51-11.png)

手册明确表示`bsd_signal`没有ONESHOT特性，信号处理函数不会`reset`成默认值，无须重复安装信号处理函数；信号处理函数期间，自身信号会被屏蔽；系统调用被中断，会重启系统调用。这三个特性都是可以保证的，但是glibc下`signal`函数就不一定了，这要取决于操作系统，取决于glibc的版本。这是`signal`函数被人诟病的一个重要原因。简言之，就是其历史负担太重。

通过前面的讨论可以发现，Linux系统会通过一些标志位和屏蔽信号集来完成对某些特性的控制。

- SA_ONESHOT（或SA_RESERTHAND）：将信号处理函数恢复成默认值。
- SA_NODEFER（或SA_NOMASK）：显式地告诉内核，不要将当前处理信号值添加进阻塞信号集。
- SA_RESTART：将中断的系统调用重启，而不是返回错误码EINTR。



## 信号的可靠性

6.4节讲信号的分类时提到过，传统的信号存在信号丢失的问题，因此被称为不可靠信号。为了对传统的不可靠信号有更直观的认识，下面来做一个简单的实验，让事实来说话。我们可以疯狂地向某个进程发送信号，然后通过比较信号发送的次数和信号处理函数执行的次数来验证是否存在信号丢失的问题。

## 信号的安装

前面讲了传统信号的很多弊端，讲了`signal`的兼容性问题，有问题就会有解决方案。对此，Linux提供了新的信号安装方法：`sigaction`函数。和`signal`函数相比，这个函数的优点在于语义明确，可以提供更精确的控制。

先来看一下`sigaction`函数的定义：

```c
#include <signal.h>
int sigaction(int signum, const struct sigaction *act,
                 struct sigaction *oldact);
struct sigaction {
       void     (*sa_handler)(int);
       void     (*sa_sigaction)(int, siginfo_t *, void *);
       sigset_t   sa_mask;
       int       sa_flags;
       void     (*sa_restorer)(void);
};
```

上面给出的`sigaction`结构体的定义并非严格意义上的定义，即结构体必须要有上述的成员变量，但成员变量的具体顺序取决于实现。

顾名思义，`sa_mask`就是信号处理函数执行期间的屏蔽信号集。前文介绍`bsd_signal`的时候曾提到，为SIGINT安装处理函数时，内核会自动将SIGINT添加入屏蔽信号集，在SIGINT信号处理函数执行期间，SIGINT信号不会被递送给进程。但是，也仅仅是SIGINT，如果执行SIGINT信号处理函数期间，需要屏蔽SIGHUP、SIGUSR1等其他信号，那`bsd_signal`函数就爱莫能助了。这个屏蔽其他信号的需求对`sigaction`函数而言，根本就不是问题，只需如下代码即可做到：

```c
struct sigaction sa；
sa.sa_mask = SIGHUP|SIGUSR1|SIGINT;
```

需要特别指出的是，并不是所有的信号都能被屏蔽。对于SIGKILL和SIGSTOP，不可以为它们安装信号处理函数，也不能屏蔽掉这些信号。原因是，系统总要控制某些进程，如果进程可以自行设计所有信号的处理函数，那么操作系统可能无法控制这些进程。换言之，操作系统是终极boss，需要杀死某些进程的时候，要能够做到，SIGKILL和SIGSTOP不能被屏蔽，就是为了防止出现进程无法无天而操作系统徒叹奈何的困境。

SIGKILL和SIGSTOP也不是万能的。如果进程处于TASK_UNINTERRUPTIBLE的状态，进程就不会处理信号。如果进程失控，长期处于该状态，SIGKILL也无法杀死该进程。详情可以回顾第5章。

若通过`sigaction`强行给SIGKILL或SIGSTOP注册信号处理函数，则会返回-1，并置errno为EINVAL。

在`sigaction`函数接口中，比较有意思的是`sa_flags`。`sigaction`函数之所以可以提供更精确的控制，大部分都是该参数的功劳。下面简要介绍一下`sa_flags`的含义，其中很多标志位并不是新面孔，前面已经讨论过了。

（1）SA_NOCLDSTOP

这个标志位只用于SIGCHLD信号。4.7节“等待子进程”中曾经提到过，父进程可以监测子进程的三种事件：

- 子进程终止（即子进程死亡）
- 子进程停止（即子进程暂停）
- 子进程恢复（即子进程从暂停中恢复执行）

其中SA_NOCLDSTOP标志位是用来控制第二种和第三种事件的。即一旦父进程为SIGCHLD信号设置了这个标志位，那么子进程停止和子进程恢复这两件事情，就无须向父进程发送SIGCHLD信号了。

（2）SA_NOCLDWAIT

这个标志只用于SIGCHLD信号，它可控制上面提到的子进程终止时的行为。如果父进程为SIGCHLD设置了SA_NOCLDWAIT标志位，那么子进程退出时，就不会进入僵尸状态，而是直接自行了断。但是子进程还会不会向父进程发送SIGCHLD信号呢？这取决于具体的实现。对于Linux而言，仍然会发送SIGCHLD信号。这点和上面的SA_NOCLDSTOP略有不同。

（3）SA_ONESHOT和SA_RESETHAND这两个标志位的本质是一样的，表示信号处理函数是一次性的，信号递送出去之后，信号处理函数便恢复成默认值SIG_DFL。

（4）SA_NODEFER和SA_NOMASK这两个标志位的作用是一样的，在信号处理函数执行期间，不阻塞当前信号。

（5）SA_RESTART这个标志位表示，如果系统调用被信号中断，则不返回错误，而是自动重启系统调用。

（6）SA_SIGINFO这个标志位表示信号发送者会提供额外的信息。这种情况下，信号处理函数应该为三参数的函数，代码如下：

```c
void handle(int, siginfo_t *, void *);
```

此处重点讲述一下带SA_SIGINFO标志位的信号安装方式。本章引言中提到过，`signal`的本质是一种进程间的通信。一个进程向另外一个进程发送信号，能够传递的信息，不仅仅是`signo`，它还可以发送更多的信息，而接收进程也能获取到发送进程的PID、UID及发送的额外信息。

来看下面的例子：

```c
#include<stdio.h>
#include<stdlib.h>
#include<signal.h>
void sig_handler(int signo,siginfo_t *info,void *context)
{
    printf("\nget signal:%d\n",signo);
    printf("signal number is %d\n",info->si_signo);
    printf("pid=%d\n",info->si_pid);
    printf("sigval = %d\n",info->si_value.sival_int);
}
int main(void)
{
    struct sigaction new_action;
    sigemptyset(&new_action.sa_mask);
    new_action.sa_sigaction = sig_handler;
    new_action.sa_flags |= SA_SIGINFO|SA_RESTART;
    if(sigaction(36,&new_action,NULL)==-1){
        printf("set signal process mode\n");
        exit(1);
    }
    while(1)
        pause();
    printf("Done\n");
    exit(0);
}
```

这个例子比较简单，为36号信号注册了信号处理函数。因为`sa_flags`带上了SA_SIGINFO标志位，所以必须使用三参数的信号处理函数。

```c
void sig_handler(int signo,siginfo_t *info,void *context)
```

本例中的信号处理函数中，`info->si_pid`记录着信号发送者的PID，`info->si_value.sival_int`是信号发送进程时额外发送的int值。发送进程和接收进程约定好，发送者使用`sigqueue`发送信号，同时带上int型的额外信息，接收进程就能获得发送进程的PID及int型的额外信息。

如果调用`sigaction`函数时，`sa_flags`带了SIGINFO标志位，那么进程可以获得哪些信息？6.8.3小节介绍`sigqueue`函数时，会展开讲述。



## 信号的发送

### kill、tkill和tgkill

kill函数的接口定义如下：

```c
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
```

注意，不能望文生义，将`kill`函数的作用理解为杀死进程。`kill`函数的作用是发送信号。`kill`函数不仅可以向特定进程发送信号，也可以向特定进程组发送信号。第一个参数pid的值，决定了`kill`函数的不同含义，具体来讲，可以分成以下几种情况。

- pid＞0：发送信号给进程ID等于pid的进程。
- pid＝0：发送信号给调用进程所在的同一个进程组的每一个进程。
- pid＝-1：有权限向调用进程发送信号的所有进程发出信号，init进程和进程自身除外。
- pid＜-1：向进程组-pid发送信号。

当函数成功时，返回0，失败时，返回-1，并置errno。常见的出错情况见表6-12。

![](image/2024-05-07-09-52-15.png)

有一种情况很有意思，即调用`kill`函数时，第二个参数signo的值为0。众所周知，没有一个信号的值是为0的，这种情况下，`kill`函数其实并不是真的向目标进程或进程组发送信号，而是用来检测目标进程或进程组是否存在。如果kill函数返回-1且errno为ESRCH，则可以断定我们关注的进程或进程组并不存在。

发送信号的典型方法如下：

```c
if(kill(3423,SIGUSR1) == -1)
{
     /*error handler*/
}
```

如何向线程发送信号？Linux提供了`tkill`和`tgkill`两个系统调用来向某个线程发送信号：

```c
int tkill(int tid, int sig);
int tgkill(int tgid, int tid, int sig);
```

这两个都是内核提供的系统调用，glibc并没有提供对这两个系统调用的封装，所以如果想使用这两个函数，需要采用syscall的方式，如下：

```c
ret = syscall(SYS_tkill,tid,sig)
ret = syscall(SYS_tgkill,tgid,tid,sig)
```

等一下，为什么有了`tkill`，还要引入`tgkill`？

实际上，`tkill`是一个过时的接口，并不推荐使用它来向线程发送信号。相比之下，`tgkill`接口更加安全。`tgkill`系统调用的第一个参数`tgid`，为线程组中主线程的线程ID，或者称为进程号。这个参数表面看起来是多余的，其实它能起到保护的作用，防止向错误的线程发送信号。进程ID或线程ID这种资源是由内核负责管理的，进程（或线程）有自己的生命周期，比如向线程ID为1234的线程发送信号时，很可能线程1234早就退出了，而线程ID 1234恰好被内核分配给了另一个不相干的进程。这种情况下，如果直接调用`tkill`，就会将信号发送到不相干的进程上。为了防止出现这种情况，于是内核引入了`tgkill`系统调用，含义是向线程组ID是`tgid`、线程ID为`tid`的线程发送信号。这样，出现误杀的可能就几乎不存在了。

这两个函数都是Linux特有的，存在可移植性的问题。

### raise函数

Linux提供了向进程自身发送信号的接口：`raise`函数，其定义如下：

```c
#include <signal.h>
int raise(int sig);
```

这个接口对于单线程的程序而言，就相当于执行如下语句：

```c
kill(getpid(),sig)
```

这个接口对于多线程的程序而言，就相当于执行如下语句：

```c
pthread_kill(pthread_self(),sig)
```

执行成功的时候，返回0，否则返回非零的值，并置errno。如果`sig`的值是无效的，`raise`函数就将errno置为EINVAL。值得注意的是，信号处理函数执行完毕之后，`raise`才能返回。

### sigqueue函数

在信号发送的方式当中，`sigqueue`算是后起之秀，传统的信号多用`signal/kill`这两个函数搭配，完成信号处理函数的安装和信号的发送。后来因为signal函数的表达力有限，控制不够精准，所以引入了sigaction函数来负责信号的安装，与其对应的是，引入了sigqueue函数来完成实时信号的发送。当然了，sigqueue函数也能发送非实时信号。sigqueue函数的接口定义如下：

```c
#include <signal.h>
int sigqueue(pid_t pid, int sig, const union sigval value);
```

sigqueue函数拥有和kill函数类似的语义，也可以发送空信号（信号0）来检查进程是否存在。和kill函数不同的地方在于，它不能通过将pid指定为负值而向整个进程组发送信号。比较有意思的是函数的第三个入参，它指定了信号的伴随数据（或者称为有效载荷，payload），该参数的数据类型是联合体，定义代码如下：

```c
union sigval {
      int   sival_int;
      void *sival_ptr;
};
```

通过指定sigqueue函数的第三个参数，可以传递一个int值或指针给目标进程。考虑到不同的进程有各自独立的地址空间，传递指针到另一个进程几乎没有任何意义。因此sigqueue函数很少传递指针（sival_ptr），大多是传递整型（sival_int）。



![](image/2024-05-07-09-53-00.png)




## 信号与线程的关系


### 线程之间共享信号处理函数

![](image/2024-05-07-09-53-50.png)


### 线程有独立的阻塞信号掩码

![](image/2024-05-07-09-54-27.png)


### 私有挂起信号和共享挂起信号

![](image/2024-05-07-09-55-01.png)


![](image/2024-05-07-09-55-14.png)


![](image/2024-05-07-09-55-29.png)

## 等待信号

有时候，需要等待某种信号的发生。POSIX中的pause、sigsuspend和sigwait函数提供了三种方法，可以将进程暂时挂起，等待信号来临。

### pause函数

pause函数将调用线程挂起，使进程进入可中断的睡眠状态，直到传递了一个信号为止。这个信号的动作或者是执行用户定义的信号处理函数，或者是终止进程。如果是执行用户自定义的信号处理函数，那么pause会在信号处理函数执行完毕后返回；如果是终止进程，pause函数就不返回了。如果内核发出的信号被忽略，那么进程就不会被唤醒。

pause函数的定义如下：

```c
#include <unistd.h>
int pause (void);
```

比较有意思的是，pause函数如果可以返回，那它总是返回-1，并且errno为EINTR。

如果希望pause函数等待某个特定的信号，就必须确定哪个信号会让pause返回。事实上，pause并不能主动区分使pause返回的信号是不是正在等待的信号，我们必须间接地完成这个任务。

常用的方法是，在期待的特定信号的信号处理函数中，将某变量的值设置为1，待pause返回后，通过查看该变量的值是否为1来判定等待的特定信号是否被捕获，方法如下面的代码所示：

```c
static volatile sig_atomic_t sig_received_flag = 0;
while(sig_received_flag == 0)
    pause();
```

如果只有等待的那个信号的处理函数会将`sig_received_flag`置成1，那么进程就会一直阻塞，直到接收到特定的信号为止。

看起来很美好，可是上面的逻辑是有漏洞的。检查`sig_received_flag==0`和调用`pause`之间存在一个时间窗口，如果在该时间窗口内收到信号，并且信号处理函数将`sig_received_flag`置1，那么主控制流根本就不知道这件事情，进程就会依然阻塞。也就是说，等待的信号已经到来，但是进程错过了。在收到下一个信号之前，pause函数不会返回，进程也就没有机会发现其实在等待的信号早就已经收到了。

因为检查和pause之间存在时间窗口，所以就有了错失信号的情况，如表6-16所示。

![](image/2024-05-07-09-56-12.png)

下面通过另一个例子来描述一下pause的困境。程序执行过程中，关键部分不期望被信号打断，于是临时阻塞信号，关键部分完成之后，就解除信号的阻塞，然后暂停执行直到有信号到达为止：

```c
/*关键代码结束*/
sigprocmask(SIG_SETMASK,&orig_mask,NULL);
/*此处信号可能已经递送给进程了，导致pause无法返回*/
pause();
```

可以看到解除对特定信号的阻塞之后，调用pause之前，信号已经被递送给进程，这个信号已经错失了，pause无法等到这个信号，直到下一个信号递送给进程为止，pause函数都无法返回。这就违背了代码的本意：解除对信号的阻塞并且等待该信号的第一次出现。

要避免这种情况，必须将解除信号阻塞和挂起进程等待信号这两个动作封装成一个原子操作。这就是引入sigsuspend系统调用的原因。

### sigsuspend函数

在pause之前传递信号是Linux早期遇到的一个困境，并没有好办法来解决这个问题。从本质上讲，必须将解除对信号的阻塞和挂起进程以等待信号的形式封装成一个原子操作，才能解决该问题，而sigsuspend函数就是为了解决这个难题而生的。

sigsuspend函数的定义如下：

```c
#include <signal.h>
int sigsuspend(const sigset_t *mask);
```

如果信号终止了进程，那么sigsuspend函数不会返回。如果内核将信号递送给进程，并执行了信号处理函数，那么sigsuspend函数返回-1，并置errno为EINTR。如果mask指针指向的地址不是合法地址，那么sigsuspend函数返回-1，并置errno为EFAULT。

sigsuspend函数用mask指向的掩码来设置进程的阻塞掩码，并将进程挂起，直到进程捕捉到信号为止。一旦从信号处理函数中返回，sigsuspend函数就会把进程的阻塞掩码恢复为调用之前的老的阻塞掩码值。

简单地说，sigsuspend相当于以不可中断的方式执行下面的操作：

```c
sigprocmask(SIG_SETMASK,&mask,&old_mask);
pause();
sigprocmask(SIG_SETMASK,&old_mask,NULL);
```

有了sigsuspend函数，就可以完成上一节pause完成不了的任务了。

```c
static volatile sig_atomic_t sig_received_flag = 0;
sigset_t mask_all, mask_most, mask_old;
int signum = SIGUSR1;
sigfillset(&mask_all);
sigfillset(&mask_most);
sigdelset(&mask_most,signum);
sigprocmask(SIG_SETMASK,&mask_all,&mask_old);
/*不要忘记先判断，因为在sigprocmask阻塞所有信号之前，SIGUSR1可能已经被递送*/
if(sig_received_flag == 0)
    sigsuspend(&mask_most);
sigprocmask(SIG_SETMASK,&mask_old,NULL);
```

假定等待特定信号SIGUSR1，首先要将所有的信号屏蔽掉，如果屏蔽信号之前，已经收到了SIGUSR1，那么sig_received_flag会被设置为1，此时就不需要再调用sigsuspend了，我们已经等到了要等的信号SIGUSR1。如果没收到，则调用sigsuspend，将阻塞掩码设为mask_most，即将所有信号都屏蔽，只有SIGUSR1未被屏蔽。sigsuspend返回时，我们就可以确定，收到了信号SIGUSR1。此时，阻塞掩码也已经恢复成调用sigsuspend之前的mask_all了，然后显式地将阻塞掩码恢复成默认的阻塞掩码mask_old。

等一等，类似于上一节的代码，在判断之后、pause之前，有信号递送，会导致信号错失，那么在上面的代码中，判断sig_received_flag==1之后，调用sigsuspend函数之前，是否会有SIGUSR1被递送给进程，再次导致错失信号一次？答案是否定的，因为我们已经通过setprocmask函数阻塞了所有的信号，因此SIGUSR1没有机会被递送给进程。

上面的代码虽然完成了等待某特定信号的任务，但是它也有副作用，就是在等待特定信号期间，所有的其他信号都不能递送，原因是sigsuspend的mask阻塞了SIGUSR1以外的所有信号，导致其他信号无法正常递送。

下面的代码对这种情况做了改进：

```c
static volatile sig_atomic_t sig_received_flag = 0;
sigset_t mask_blocked, mask_old, mask_unblocked;
int signum = SIGUSR1;
sigprocmask(SIGSETMASK,NULL,&mask_blocked);
sigprocmask(SIGSETMASK,NULL,&mask_unblocked);
sigaddset(&mask_blocked,signum);
sigdelset(&mask_unblocked,signum);
/*将SIGUSR1添加到阻塞掩码中，确保下面判断sig_received_flag和sigsuspend之间不会收到SIGUSR1信号，从而导致SIGUSR1错失*/
sigprocmask(SIG_BLOCK,&mask_blocked,&mask_old);
/*sigsuspend返回，可能是由其他信号引起的，*因此需要再次判断sig_received_flag是否置1*/
while(sig_received_flag == 0)
     sigsuspend(&mask_unblocked);
/*将信号恢复成默认值*/
sigprocmask(SIG_SETMASK,&mask_old,NULL);
```

上面的例子不仅做到了等待特定信号SIGUSR1，而且期间如果有其他信号，也不会影响其他信号的递送。至此等待特定信号的任务算是圆满地解决了。


### sigwait函数和sigwaitinfo函数

![](image/2024-05-07-09-56-52.png)




## 通过文件描述符来获取信号



## 信号递送的顺序

![](image/2024-05-07-09-57-21.png)


## 异步信号安全

![](image/2024-05-07-09-57-45.png)


![](image/2024-05-07-09-57-58.png)


![](image/2024-05-07-09-58-11.png)


## 总结
Linux的signal机制是一种原始的进程间通信机制，传递的信息有限，很难传递复杂的消息，加上信号处理函数和进程处于两条执行逻辑流，会带来函数的重入问题，因此signal机制不适合作为进程间通信的主要手段。但是信号又不是完全无用的，对于某些不频繁发生的异步事件，还是可以使用signal来通知进程。