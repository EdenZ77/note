# 第1章 课程内容及相关说明



# 第2章 进程和线程

## 002.认识进程和线程





## 003.C语言对线程的支持





## 004.C语言编译器的选择





## 005.用C标准库函数创建线程





## 006.并行和并发



# 第3章 数据竞争



## 007.多线程数据竞争的例子



## 008.数据竞争是如何产生的

# 第4章 原子操作和锁

## 009.原子操作和原子变量



## 010.互斥锁



## 011.执行原子操作的机器指令



## 012.用机器指令实现原子操作的例子



## 013.用机器指令实现互斥锁的例子



# 第5章 线程通信及相关问题

## 014.一个线程间通信的例子

## 015.编译优化和指令重排

## 016.原子操作的神奇效应





# 第6章 流水线、乱序执行和缓存

## 017.什么是编排顺序



## 018.流水线



## 019.乱序执行

## 020.指令的执行和引退

## 021.存写缓冲器

## 022.缓存



# 第7章 硬件内存模型

023.多处理器系统和顺序一致性
024.顺序一致的执行
025.特别练习7-1
026.顺序一致性模型的访存次序
027.偏序和全序
028.顺序一致性存在单一全序
029.x86处理器的指令重排
030.x86处理器上的存全序TSO
031.x86的内存屏障指令MFENCE
032.x86-tso的访存次序（一)
033.x86-tso的访存次序（二)
034.x86-tso的访存次序（三）
035.x86-tso的访存次序（四）
036.x86-tso的访存次序（五）
037.x86-tso的访存次序（六）
038.x86访存次序的总结
039.多处理器和缓存一致性
040.MESI协议
041.MESI协议的状态转化
042.arm／power的访存次序（一）
043.arm／power的访存次序（二）
044.arm／power的访存次序（三）
045.arm／power的访存次序（四）
046.如何阻止指令重排
047.避免数据竞争的顺序一致性
048.x86平台上的同步操作指令
049.SC-DRF的实例
050.特别练习7-2



# 第8章 C/C++内存模型

051.C／C++内存模型简介
052.C语言的表达式
053.表达式的例子
054.表达式的功能
055.求值、值计算和副作用
056.前序、后序和序列点
057.特别练习8-1
058.无序和不确定顺序
059.冲突和数据竞争
060.原子操作库
061.一个多线程数据竞争的例子
062.用原子操作解决数据竞争的例子
063.C／C++内存模型的核心思想
064.原子操作的附加属性（同步和访存次序）
065.通过原子操作施加指定的访存次序
066.通过原子操作施加内存同步
067.前发
068.同步操作及其分类
069.原子操作的线程间同步
070.依赖前序
071.线程间前发
072.可见副作用
073.再论前序和前发
074.松散的原子操作
075.原子变量的修改次序
076.原子操作的一致性规则
077.顺序一致性的原子操作
078.实例解析一
079.实例解析二
080.原子变量和C语言的运算符
080.实例解析三
081.实例解析四
082.实例解析五
083.实例解析六
084.对原子操作函数的附加说明
085.C语言对原子类型的支持：存取的顺序一致性语义
086.C语言对原子类型的支持：复合赋值的顺序一致性语义
087.C语言对原子类型的支持：递增和递减的顺序一致性语义
088.C语言对原子类型的支持：不使用标准库函数的线程同步

