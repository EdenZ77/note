# 前言



# 第1章 基本要求和相关说明

## 1.1 配书代码和工具





## 1.2 NASM的下载和安装



## 1.3 NASMIDE的下载和使用





## 1.4 下载和安装VirtualBox





## 1.5 使用FixVhdWr将程序写入虚拟硬盘





## 1.6 本书的代码组织





# 第2章 x64架构的基本执行环境

## 2.1 x64架构的由来



## 2.2 物理地址、有效地址和线性地址



## 2.3 x64架构的工作模式



### 2.3.1 x86处理器的工作模式



### 2.3.2 IA-32e模式及其子模式



## 2.4 x64架构的寄存器



### 2.4.1 x64架构对通用寄存器的扩展

### 2.4.2 x64架构的通用寄存器访问规则





## 2.5 x86处理器的物理地址空间



## 2.6 传统模式的内存访问



### 2.6.1 传统模式下的线性地址和物理地址

### 2.6.2 传统模式下的32位4KB分页技术

### 2.6.3 传统模式下如何利用超过4GB的物理内存



### 2.6.4 传统模式下的32位4MB分页技术



### 2.6.5 传统模式下的32位PAE分页技术



### 2.6.6 传统模式下的32位PAE-4KB分页技术

### 2.6.7 传统模式下的32位PAE-2MB分页技术



## 2.7 IA-32e模式的内存访问



### 2.7.1 x64架构的线性地址空间



### 2.7.2 扩高 (Canonical) 地址

### 2.7.3 扩高地址的特点和处理器检查

### 2.7.4 兼容模式的内存访问

### 2.7.5 64位模式的内存访问

### 2.7.6 x64架构的段寄存器

### 2.7.7 x64架构的代码段描述符

### 2.7.8 x64架构的数据段描述符

### 2.7.9 x64架构的4级和5级分页



## 2.8 x64架构的系统表和系统描述符

2.8.1 x64架构的GDTR

2.8.2 x64架构的IDTR

2.8.3 x64架构的LDT描述符和LDTR

2.8.4 x64架构的TSS描述符和TR

## 2.9 x64架构的标志寄存器和指令指针寄存器



## 2.10 x64架构的寻址方式

2.10.1 x64架构下传统模式的寻址方式

2.10.2 x64架构下IA-32e模式的寻址方式

2.10.3 64位模式的RIP相对寻址方式

2.10.4 64位模式下的指令变化情况

## 2.11 IA-32e模式下的中断和异常处理概述

# 第3章 进入IA-32e模式

## 3.1 如何进入IA-32e模式

## 3.2 本章代码清单

## 3.3 执行主引导程序

3.3.1 NASM的文件包含

3.3.2 主引导程序的说明

3.3.3 用BIOS硬盘扩展读加载内核加载器

3.3.4 通过数据段访问栈中的数据结构

3.3.5 读取内核加载器程序的剩余部分

3.3.6 转入内核加载器执行

## 3.4 执行内核加载器

3.4.1 检测处理器是否支持IA-32e模式

3.4.2 位测试指令BT

3.4.3 获取处理器的商标和地址尺寸



## 3.5 进入保护模式

## 3.6 加载内核程序

## 3.7 为进入IA-32e模式准备4级分页

3.7.1 2MB和1GB页面的4级分页方式

3.7.2 4级头表的格式

3.7.3 页目录指针项的格式

3.7.4 页目录项和页表项的格式

3.7.5 4级头表的创建和初始化

3.7.6 创建指向4级头表自身的4级头表项

3.7.7 准备映射物理内存的低端2MB空间

3.7.8 创建与低端2MB物理内存对应的分页系统表项

3.7.9 将物理内存低端的2MB映射到线性地址空间的高端

3.7.10 为多任务环境准备必要的4级头表项

3.7.11 为多任务环境预分配254个页目录指针表

3.7.12 进程上下文标识PCID

3.7.13 控制寄存器CR3的内容格式

3.7.14 设置控制寄存器CR3并开启物理地址扩展功能

3.7.15 型号专属寄存器IA32_EFER的设置和分页的开启

## 3.8 进入IA-32e的兼容模式执行

## 3.9 进入64位模式的内核执行

## 3.10 让内核工作在线性地址空间的高端

3.10.1 启用GDT和栈区的高端线性地址

3.10.2 使用RIP相对寻址方式计算内核的高端线性地址

3.10.3 让处理器转到内核程序对应的高端位置继续执行

## 3.11 初始化IA-32e模式下的中断系统

3.11.1 IA-32e模式下的中断门和陷阱门

3.11.2 IA-32e模式下的中断处理过程

3.11.3 通用的中断和异常处理策略

3.11.4 通用异常服务例程的工作过程

3.11.5 加载有效地址指令LEA

3.11.6 创建通用异常处理过程的中断门

3.11.7 安装通用异常处理过程的中断门

3.11.8 安装通用中断处理过程的中断门

3.11.9 初始化8259中断控制器

3.11.10 打印64位模式下的第一条信息

## 3.12 本章代码的编译和运行

# 第4章 单处理器环境下的多任务管理和调度

## 4.1 本章代码清单



## 4.2 初始化快速系统调用环境



4.2.1 快速系统调用的原理

4.2.2 为快速系统调用安装段描述符

4.2.3 为快速系统调用准备段选择子

4.2.4 设置快速系统调用的入口点

4.2.5 快速系统调用时的RFLAGS和栈切换



## 4.3 动态内存分配

4.3.1 内核空间的分配策略

4.3.2 内核可用线性地址的获取和更新

4.3.3 立即数在64位模式下的长度限制

4.3.4 计算本次内存分配涉及的线性地址范围

4.3.5 获取与指定线性地址对应的4级头表项的线性地址

4.3.6 页面分配与页映射位串

4.3.7 页映射位串的定义和空闲页的查找

4.3.8 获取与指定线性地址对应的页目录指针项的线性地址

4.3.9 检查与指定线性地址对应的页目录指针项是否存在

4.3.10 分配页目录表并安装与线性地址对应的页目录指针项

4.3.11 安装与指定线性地址对应的页目录项、页表项和页面

## 4.4 创建并安装TSS描述符

4.4.1 LDT和TSS描述符的格式

4.4.2 创建和安装64位的TSS描述符并加载任务寄存器TR

## 4.5 初始化实时时钟中断

## 4.6 创建外壳任务

4.6.1 准备创建外壳任务

4.6.2 为新任务创建任务控制块PCB

4.6.3 为新任务创建4级头表

4.6.4 将指定的线性地址映射到指定的物理页

4.6.5 复制当前活动4级头表的内容给新任务的4级头表

4.6.6 切换到新任务的地址空间并清空4级头表的前半部分

4.6.7 为新任务分配0特权级使用的栈空间

4.6.8 为新任务分配3特权级使用的栈空间

4.6.9 从硬盘上加载用户程序

4.6.10 生成任务标识

4.6.11 将新任务的PCB添加到PCB链表

4.6.12 设置外壳任务的状态

## 4.7 设置任务状态段TSS

## 4.8 转到外壳任务的局部空间执行

## 4.9 快速系统调用的进入和返回

4.9.1 为快速系统调用指定功能号

4.9.2 根据功能号计算内核例程的线性地址

4.9.3 快速系统调用的返回和指令前缀REX

## 4.10 利用实时时钟中断执行任务切换

4.10.1 查找处于就绪状态的任务

4.10.2 任务切换的执行过程

## 4.11 外壳任务的执行过程

4.11.1 通过系统调用获取屏幕上可用的显示行坐标

4.11.2 通过系统调用获取当前时间

4.11.3 在外壳任务中显示当前时间

## 4.12 用户任务的创建和执行

4.12.1 当前任务标识的获取

4.12.2 用户程序例程库的介绍

4.12.3 将64位二进制数转换为十进制字符串

4.12.4 在每轮相加中将结果和加数转换为字符串

4.12.5 字符串的连接和显示

4.12.6 用户任务的终止

## 4.13 本章程序的编译和执行

# 第5章 多处理器和APIC的初始化

## 5.1 多处理器环境概述

## 5.2 同时多线程和INTEL超线程技术

## 5.3 高级可编程中断控制器APIC

5.3.1 中断引脚、中断类型和中断源

5.3.2 本地中断源和本地向量表

5.3.3 APIC的工作模式和APIC ID

5.3.4 组成Local APIC ID的处理器拓扑

5.3.5 Local APIC的地址映射

5.3.6 I/O APIC的地址映射

5.3.7 多处理器的初始化过程和MP规范

5.3.8 高级的配置和电源接口（ACPI）规范

## 5.4 本章代码清单

## 5.5 获取ACPI申领的物理内存地址范围

5.5.1 ACPI的数据结构和表

5.5.2 E820功能调用和内存地址范围结构

5.5.3 查询和保存物理地址映射数据

5.5.4 准备映射ACPI申领的内存

5.5.5 映射ACPI申领的内存

## 5.6 访问ACPI的数据结构和表

5.6.1 根系统描述指针结构

5.6.2 搜索根系统描述指针结构

5.6.3 系统描述表的层次结构和表头格式

5.6.4 扩展的系统描述表XSDT

5.6.5 通过XSDT搜索多APIC描述表MADT

5.6.6 根系统描述表RSDT

5.6.7 通过RSDT搜索多APIC描述表MADT

5.6.8 多APIC描述表MADT的格式

5.6.9 准备遍历中断控制器结构列表

5.6.10 从中断控制器结构内提取处理器和APIC信息

## 5.7 映射APIC地址

## 5.8 测量Local APIC定时器

5.8.1 Local APIC定时器

5.8.2 Local APIC定时器的精度

5.8.3 APIC定时器的本地向量表寄存器及其设置

5.8.4 设置CMOS RTC以测量Local APIC定时器

5.8.5 测量Local APIC定时器在1ms内经历的时钟周期数

## 5.9 使用Local APIC定时器中断切换任务

5.9.1 多处理器系统的虚拟线模式

5.9.2 中断输入引脚LINT0的本地向量表寄存器

5.9.3 设置Local APIC定时器

## 5.10 使用经由I/O APIC的中断执行任务切换

5.10.1 I/O APIC概述

5.10.2 I/O APIC的I/O重定向表寄存器

5.10.3 用I/O APIC投递的中断实施任务切换

## 5.11 逻辑目标模式下的中断目标判别机制

## 5.12 APIC中断的优先级及其相关的寄存器

## 5.13 APIC中断的接受机制

## 5.14 最低优先级模式的中断处理





# 第6章 多处理器环境下的多任务管理和调度

## 6.1 本章代码清单

## 6.2 高速缓存

## 6.3 数据竞争和锁

6.3.1 单处理器环境下的数据竞争

6.3.2 多处理器环境下的数据竞争

6.3.3 原子操作

6.3.4 锁和自旋锁

6.3.5 分支预测和PAUSE指令

6.3.6 多行宏定义

6.3.7 锁在内核例程中的应用

6.3.8 互斥锁的一般原理

## 6.4 内核的初始化

6.4.1 处理器专属存储区（每CPU数据区）

6.4.2 为自举处理器BSP分配专属存储区

6.4.3 处理器专属存储区的访问

## 6.5 多处理器系统的初始化

6.5.1 多处理器系统的初始化协议算法

6.5.2 本章的多处理器多任务调度方案

6.5.3 中断命令寄存器ICR

6.5.4 本章的AP初始化代码简介

6.5.5 将AP初始化代码传送到指定位置

6.5.6 向所有应用处理器广播SIPI消息

## 6.6 应用处理器AP的初始化过程

6.6.1 进入保护模式

6.6.2 进入64位模式

6.6.3 为每个应用处理器创建必要的数据结构

6.6.4 对称多处理器系统的实现

6.6.5 用SWAPGS指令访问专属存储区

6.6.6 开启Local APIC并进入停机待命状态

## 6.7 由自举处理器BSP继续完成剩余的内核初始化工作

6.7.1 等待所有应用处理器完成初始化

6.7.2 创建系统外壳任务并为其指定时间片

6.7.3 广播新任务认领消息并进入预定状态

## 6.8 多处理器多任务的管理和调度

6.8.1 新任务认领中断的处理过程

6.8.2 在任务链表中查找就绪任务

6.8.3 用CMPXCHG指令以无锁方式操作链表节点

6.8.4 为新任务指定时间片

6.8.5 恢复任务的状态并开始执行

6.8.6 时间片到期中断的处理过程

6.8.7 处理器专属存储区的必要性

6.8.8 外壳任务的执行流程

6.8.9 用户任务的执行流程

6.8.10 任务的终止

## 6.9 程序的编译和执行



# 第7章 多处理器环境下的多线程管理和调度

## 7.1 任务（进程）和线程



## 7.2 本章代码清单

## 7.3 本章的任务控制块PCB和线程控制块TCB

## 7.4 任务及其主线程的创建

## 7.5 线程的调度和切换

7.5.1 新线程认领中断的处理过程

7.5.2 查找处于就绪状态的线程

7.5.3 恢复并执行指定的线程

7.5.4 时间片到期中断的处理过程

## 7.6 系统外壳任务及其主线程的执行



## 7.7 将例程创建为线程

7.7.1 将例程创建为线程

7.7.2 创建线程控制块TCB和线程私有的栈

7.7.3 例程返回和结束线程的区别

7.7.4 如何用RET指令结束线程

7.7.5 在栈中构造结束线程的栈帧

7.7.6 将TCB添加到当前任务的TCB链表

## 7.8 线程的执行

7.8.1 动态内存分配

7.8.2 在栈中保存所有缓冲区的线性地址

7.8.3 字符串的生成、连接和打印

## 7.9 线程的结束和任务的终止

## 7.10 程序的编译和执行





# 第8章 数据竞争和互斥锁

## 8.1 本章代码清单

## 8.2 线程的休眠和唤醒

8.2.1 执行线程休眠的系统调用

8.2.2 保存和修改休眠线程的状态

8.2.3 安装系统管理中断

8.2.4 系统管理中断的处理过程

8.2.5 唤醒休眠的线程

## 8.3 数据竞争的实例

8.3.1 在两个同时执行的线程内访问共享数据

8.3.2 线程等待

8.3.3 唤醒处于等待状态的线程

8.3.4 打印两个线程操作之后的共享数据

8.3.5 并发线程的数据竞争过程

## 8.4 使用锁定的原子操作解决数据竞争

## 8.5 使用互斥锁解决数据竞争

8.5.1 互斥锁的创建和初始化

8.5.2 互斥锁的获取（加锁）

8.5.3 唤醒等待互斥锁的线程

8.5.4 互斥锁的释放

8.5.5 使用互斥锁之后的运行效果

## 8.6 互斥锁的应用策略