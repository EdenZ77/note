# 第 5章 [BX]和 loop 指令



## 5.3 在 Debug 中跟踪用 loop 指令实现的循环程序

考虑这样一个问题，计算 `ffff:0006` 单元中的数乘以 3，结果存储在 `dx` 中。

我们分析一下：

1. 运算后的结果是否会超出 `dx` 所能存储的范围？
   `ffff:0006` 单元中的数是一个字节型的数据，范围在 0~255 之间，则用它和 3 相乘结果不会大于 65535，可以在`dx` 中存放下。

2. 用循环累加来实现乘法，用哪个寄存器进行累加？
   将 `ffff:0006` 单元中的数赋值给 `ax`，用 `dx` 进行累加。先设 `(dx)=0`，然后做 3 次 `(dx)=(dx)+(ax)`。

3. `ffff:6` 单元是一个字节单元，`ax` 是一个 16 位寄存器，数据的长度不一样，如何赋值？

   注意，我们说的是“赋值”，就是说，让 `ax` 中的数据的值(数据的大小)和 `ffff:0006`单元中的数据的值(数据的大小)相等。8 位数据`01H`和 16 位数据`0001H`的数据长度不一样，但它们的值是相等的。

   那么我们如何赋值？设`ffff:0006`单元中的数据是`XXH`，若要 `ax` 中的值和 `ffff:0006` 单元中的相等，`ax` 中的数据应为`00XXH`。所以，若实现 `ffff:0006` 单元向 `ax` 赋值，应该令 `(ah)=0,(al)=(ffff6H)`。

想清楚以上的3个问题之后，编写程序如下。程序5.3

```assembly
assume cs:code
code segment
    mov ax,0ffffh
    mov ds,ax
    mov bx,6 ;以上，设置ds:bx 指向ffff:6
    
    mov al,[bx]
    mov ah,0 ;以上，设置(al)=((ds*16)+(bx)),(ah)=0
    
    mov dx,0 ;累加寄存器清0
    
    mov cx,3 ;循环3次
  s:add dx,ax
    loop s ;以上累加计算(ax)*3
    
    mov ax,4c00h
    int 21h ;程序返回

code ends
end
```

注意程序中的第一条指令 `mov ax,0ffffh`。我们知道，大于 `9FFFh` 的十六进制数据`A000H`、`A001H..C000H`、`c001H..FFFEH`、`FFFFH` 等，在书写的时候都是以字母开头的。而在汇编源程序中，数据不能以字母开头，所以要在前面加 0。比如，`9138h` 在汇编源程序中可以直接写为 “9138h”，而 `A000h` 在汇编源程序中要写为 “0A000h”。  