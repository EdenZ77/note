

# 第7章 指令系统



## 机器指令

由第 1 章可知，计算机能解题是由于机器本身存在一种语言，它既能理解人的意图，又能被机器自身识别。机器语言是由一条条语旬构成的，每一条语旬又能准确表达某种语义。例如，它可以命令机器做某种操作，指出参与操作的数或其他信息在什么地方等。计算机就是连续执行每一条机器语旬而实现全自动工作的。人们习惯把每一条机器语言的语旬称为机器指令，而又将全部机器指令的集合称为机器的指令系统。因此机器的指令系统集中反映了机器的功能。

计算机设计者主要研究如何确定机器的指令系统，如何用硬件电路、芯片、设备来实现机器指令系统的功能。计算机的使用者则是依据机器提供的指令系统，使用汇编语言来编制各种程序。计算机使用者根据机器指令系统所描述的机器功能，能很清楚地了解计算机内部寄存器－存储器的结构，以及计算机能直接支持的各种数据类型。  



### 指令的一般格式

指令是由操作码和地址码两部分组成的，其基本格式如图 7.1 所示。

<img src="image/image-20250120100943744.png" alt="image-20250120100943744" style="zoom:50%;" />

1、操作码

操作码用来指明该指令所要完成的操作，如加法、减法、传送、移位、转移等。通常，其位数反映了机器的操作种类，也即机器允许的指令条数，如操作码占 7 位，则该机器最多包含 $2^7$ = 128 条指令。

操作码的长度可以是固定的，也可以是变化的。前者将操作码集中放在指令字的一个字段内，如图 7.1 所示。这种格式便于硬件设计，指令译码时间短，广泛用千字长较长的、大中型计算机和超级小型计算机以及 RISC (Reduced Instruction Set Computer) 中。例如， IBM 370 和 VAX-11系列机，操作码长度均为 8 位。

对于操作码长度不固定的指令，其操作码分散在指令字的不同字段中。这种格式可有效地压缩操作码的平均长度，在字长较短的微型计算机中被广泛采用。例如 PDP-11 、 Intel 8086/80386 等操作码的长度是可变的。

操作码长度不固定会增加指令译码和分析的难度，使控制器的设计复杂。通常采用扩展操作码技术，使操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。图 7.2 是一种扩展操作码的安排示意图。

<img src="image/image-20250120101205985.png" alt="image-20250120101205985" style="zoom:50%;" />

图 7.2 中指令字长为 16 位，其中 4 位为基本操作码字段 OP ，另有 3 个 4 位长的地址字段为Al 、 A心儿。 4 位基本操作码若全部用于三地址指令，则有 16 条。若采用扩展操作码技术，如图7.2 所示，当操作码取 4 位时，三地址指令最多为 15 条；操作码取 8 位时，二地址指令最多为 15条；操作码取 12 位时，一地址指令最多为 15 条；操作码取 16 位时，零地址指令为 16 条。共 61条。可见操作码的位数随地址数的减少而增加。

除了这种安排以外，还有其他多种扩展方法，例如，形成 15 条三地址指令、 12 条二地址指令、 31 条一地址指令和 16 条零地址指令，共 74 条指令，读者可自行安排。  

2、地址码

地址码用来指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址。这里的“地址”可以是主存的地址，也可以是寄存器的地址，甚至可以是 I/0 设备的地址。

下面以主存地址为例，分析指令的地址码字段。  

(1) 四地址指令

这种指令的地址字段有 4 个，其格式如下：

<img src="image/image-20250120101332905.png" alt="image-20250120101332905" style="zoom:50%;" />

其中， OP 为操作码； Al 为第一操作数地址；儿为第二操作数地址；凡为结果地址；儿为下一条指令的地址。

该指令完成 (A1)0P(A2) 一凡的操作。这种指令直观易懂，后续指令地址可以任可直接寻址的地址范围与地址字段的位数有关。如果指令字长为 32 位，操作码占 8 位， 4 个地址字段各占 6 位，则指令操作数的直接寻址范围为 26 = 64 。如果地址字段均指示主存的地址，则完成一条四地址指令，共需访问 4 次存储器（取指令一次，取两个操作数两次，存放结果一次）。

因为程序中大多数指令是按顺序执行的，而程序计数器 PC 既能存放当前欲执行指令的地址，又有计数功能，因此它能自动形成下一条指令的地址。这样，指令字中的第四地址字段儿便可省去，即得三地址指令格式。

(2) 三地址指令

三地址指令中只有 3 个地址，其格式如下：

<img src="image/image-20250120101447817.png" alt="image-20250120101447817" style="zoom:50%;" />

它可完成 ($A_1$) OP ($A_2$) → $A_3$的操作，后续指令的地址隐含在程序计数器 PC 之中。如果指令字长不变，设 OP 仍为 8 位，则 3 个地址字段各占 8 位，故三地址指令操作数的直接寻址范围可达 28 = 256 。同理，若地址字段均为主存地址，则完成一条三地址指令也需访问 4 次存储器。

机器在运行过程中，没有必要将每次运算结果都存入主存，中间结果可以暂时存放在 CPU的寄存器（如 ACC) 中，这样又可省去一个地址字段 A3 ，从而得出二地址指令。

(3) 二地址指令

二地址指令中只含两个地址字段，其格式如下：

<img src="image/image-20250120101857643.png" alt="image-20250120101857643" style="zoom:50%;" />

它可完成 ($A_1$) OP ($A_2$) → $A_1$的操作，即 A] 字段既代表源操作数的地址，又代表存放本次运算结果的地址。有的机器也可以表示 (A1)0P(A2) 一凡的操作，此时凡除了代表源操作数的地址外，还代表中间结果的存放地址。这两种情况完成一条指令仍需访问 4 次存储器。如果使其完成 (A1)0P(A2)---+ACC ，此时，它完成一条指令只需 3 次访存，它的含义是中间结果暂存累加器 ACC 中。在不改变指令字长和操作码的位数前提下，二地址指令操作数的直接寻址范围
为 $2^{12}$ = 4 K 。

如果将一个操作数的地址隐含在运算器的 ACC 中，则指令字中只需给出一个地址码，构成一地址指令。

(4) 一地址指令

一地址指令的地址码字段只有一个，其格式如下：

<img src="image/image-20250120102053128.png" alt="image-20250120102053128" style="zoom:50%;" />

它可完成 (ACC)OP(Al)---+ACC 的操作， ACC 既存放参与运算的操作数，又存放运算的中间结果这样，完成一条一地址指令只需两次访存。在指令字长仍为 32 位、操作码位数仍固定为 8位时，一地址指令操作数的直接寻址范围达 2气即 16 M 。

在指令系统中，还有一种指令可以不设地址字段，即所谓零地址指令。

(5) 零地址指令

零地址指令在指令字中无地址码，例如，空操作 (NOP) 、停机 (HLT) 这类指令只有操作码。而子程序返回 (RET) 、中断返回 (IRET) 这类指令没有地址码，其操作数的地址隐含在堆栈指针SP 中（有关堆栈的概念详见 7.3.2 节）。

通过上述介绍可见，用一些硬件资源（如 PC 、 ACC) 承担指令字中需指明的地址码，可在不改变指令字长的前提下，扩大指令操作数的直接寻址范围。此外，用 PC 、 ACC 等硬件代替指令字中的某些地址字段，还可缩短指令字长，并可减少访存次数。因此，究竟采用什么样的地址格式，必须从机器性能出发综合考虑。

以上讨论的地址格式均以主存地址为例，实际上地址字段也可用来表示寄存器。当 CPU 中含有多个通用寄存器时，对每一个寄存器赋予一个编号，便可指明源操作数和结果存放在哪个寄存器中。地址字段表示寄存器时，也可有三地址、二地址、一地址之分。它们的共同点是，在指令的执行阶段都不必访问存储器，直接访问寄存器，使机器运行速度得到提高（因为寄存器类型的指令只需在取指阶段访问一次存储器）。



### 指令字长

指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数。不同机器的指令字长是不相同的。

早期的计算机指令字长、机器字长和存储字长均相等，因此访问某个存储单元，便可取出一条完整的指令或一个完整的数据。这种机器的指令字长是固定的，控制方式比较简单。随着计算机的发展，存储容量的增大，要求处理的数据类型增多，计算机的指令字长也发生了很大的变化。一台机器的指令系统可以采用位数不相同的指令，即指令字长是可变的，如单字长指令、多字长指令。控制这类指令的电路比较复杂，而且多字长指令要多次访问存储器才能取出一条完整的指令，因此使 CPU 速度下降。为了提高指令的运行速度和节省存储空间，通常尽可能把常用的指令（如数据传送指令、算逻运算指令等）设计成单字长或短字长格式的指令。

例如， PDP-8 指令字长固定取 12 位； NOVA 指令字长固定取 16 位； IBM 370 指令字长可变，可以是 16 位（半个字）、 32 位（一个字）、 48 位（一字半） ;Intel 8086 的指令字长可以为 8 、 16 、 24 、32 、 40 和 48 位六种。通常指令字长取 8 的整数倍。  



## 操作数类型和操作类型

### 操作数类型



### 数据在存储器中的存放方式

通常计算机中的数据存放在存储器或寄存器中，而寄存器的位数便可反映机器字长。一般机器字长可取字节的 1 、 2 、4 、 8 倍，这样便千字符处理。在大、中型机器中字长为 32 位和 64 位，在微型计算机中字长从 4 位、 8 位逐渐发展到目前的 16 位、 32 位和 64 位。

由于不同的机器数据字长不同，每台机器处理的数据字长也不统一，例如奔腾处理器可处理8 （字节）、 16 （字）、 32 （双字）、 64 (四字） ； PowerPC 可处理 8 （字节）、 16 （半字）、 32 （字）、 64 （双字）。因此，为了便于硬件实现，通常要求多字节的数据在存储器的存放方式能满足＂边界对准”的要求，如图 7.3 所示。

图 7.3 中所示的存储器存储字长为 32 位，可按字节、半字、字、双字访问。在对准边界的 32位字长的计算机中（如图 7.3 (a) 所示），半字地址是 2 的整数倍，字地址是 4 的整数倍，双字地址是 8 的整数倍。当所存数据不能满足此要求时，可填充一个至多个空臼字节。而字节的次序有两种，如图 7.4 所示，其中 7.4(a) 表示低字节为低地址，图 7.4(b) 表示高字节为低地址。

在数据不对准边界的计算机中，数据（例如一个字）可能在两个存储单元中，此时需要访问两次存储器，并对高低字节的位置进行调整后才能取得一个字，图 7.3 (b) 的阴影部分即属于这种情况。

<img src="image/image-20250120102414829.png" alt="image-20250120102414829" style="zoom:67%;" />



### 操作类型

不同的机器，操作类型也是不同的，但几乎所有的机器都有以下几类通用的操作。

\1. 数据传送

数据传送包括寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的传送。如从源到目的之间的传送、对存储器读 (LOAD) 和写 (STORE) 、交换源和目的的内容、置 1 、清零、进栈、出栈等。

\2. 算术逻辑操作

这类操作可实现算术运算（加、减、乘胎汇增 l 、减 1 、取负数即求补）和逻辑运算（与、或、非、  异或）。对于低档机而言，一般算术运算只支持最基本的二进制加减、比较、求补等，高档机还能支持浮点运算和十进制运算。

有些机器还具有位操作功能，如位测试（测试指定位的值）、位清除（清除指定位）、位求反
（对指定位求反）等。

3\移位

移位可分为算术移位、逻辑移位和循环移位三种。算术移位和逻辑移位分别可实现对有符号数和无符号数乘以 2飞左移）或整除以 2飞右移）的运算，并且移位操作所需时间远比乘除操作执行时间短，因此，移位操作经常被用来代替简单的乘法和除法运算。

4\转移

在多数情况下，计算机是按顺序执行程序的每条指令的，但有时需要改变这种顺序，此刻可
采用转移类指令来完成。转移指令按其转移特征又可分为无条件转移、条件转移、跳转、过程调
用与返回、陷阱 (Trap) 等几种。

(1) 无条件转移

无条件转移不受任何条件约束，可直接把程序转移到下一条需执行指令的地址。例如 “JMP X",
其功能是将指令地址无条件转至 X 。

(2) 条件转移

条件转移是根据当前指令的执行结果来决定是否需要转移。若条件满足，则转移；若条件不满足，则继续按顺序执行。一般机器都能提供一些条件码，这些条件码是某些操作的结果。例如：零标志位 (Z) ，结果为 O,Z= 1 ；负标志位 (N) ，结果为负， N=l ；溢出标志位 (V) ，结果有溢出，V=l ；进位标志位 (C) ，最高位有进位， C=l ；奇偶标志位 (P) ，结果呈偶数， P=l 等。

例如，指令 “BROX” 表示若结果（有符号数）溢出 (V=l) ，则指令跳转至 X 。例如，指令"BRC Y” 表示若最高位有进位 (C = 1) ，则指令跳转至 Y 。

还有一种条件转移指令， SKP(Skip) ，它暗示其下一条指令将被跳过，从而隐含了转移地址SKP 后的第二条指令。例如：

```
200
.
.
.
205 SKP DZ
206
207
```

这里“SKP DZ” 表示若设备的完成触发器 D 为零，则执行完 205 条指令后，立即跳至第 207条指令，再顺序执行。

(3) 调用与返回

在编写程序时，有些具有特定功能的程序段会被反复使用。为避免重复编写，可将这些程序段设定为独立子程序，当需要执行某子程序时，只需用子程序调用指令即可。此外，计算机系统还提供了通用子程序，如申请资源、读写文件、控制外设等。需要时均可由用户直接调用，不必重新编写。

通常调用指令包括过程调用、系统调用和子程序调用。它可实现从一个程序转移到另一个程序的操作。

调用指令 (CALL) 一般与返回指令 (RETURN) 配合使用。 CALL 用千从当前的程序位置转至子程序的入口； RETURN 用于子程序执行完后重新返回到原程序的断点。图 7.5 示意了调用(CALL) 和返回 (RETURN) 指令在程序执行中的流程。  

<img src="image/image-20250120102736134.png" alt="image-20250120102736134" style="zoom:50%;" />

图 7.5 (a) 示意了主程序和子程序在主存所占空间。主程序从 2000 地址单元开始，并在2100 处有一个调用指令，当执行到 2100 处指令时， CPU 停止下一条顺序号为 2101 的指令，而转2400 执行 SUBl 子程序。在 SUBl 中又有两次 (2500 和 2560 处）调用子程序 SUB2 。每一次都将 SUBl 挂起，而执行 SUB2 。子程序末尾的 RETURN 指令可使 CPU 返回调用点。

图 7.5(b) 示意了主程序 ---+SUBl一 SUB2---+SUB1---+SUB2---+SUB 1---+主程序的执行流程。需要注意以下几点。

- 子程序可在多处被调用。
- 子程序调用可出现在子程序中，即允许子程序嵌套。
- 每个 CALL 指令都对应一条 RETURN 指令。  

由于可以在许多处调用子程序，因此， CPU 必须记住返回地址，使子程序能准确返回。返回地址可存放在以下 3 处。

- 寄存器内。机器内设有专用寄存器，专门用于存放返回地址。
- 子程序的入口地址内。
- 栈顶内。现代计算机都设有堆栈，执行 RETURN 指令后，便可自动从栈顶内取出应返回的地址。  

(4) 陷阱 (Trap) 与陷阱指令

陷阱其实是一种意外事故的中断。例如，机器在运行中，可能会出现电源电压不稳定、存储器校验出差错、输入输出设备出现了故障、用户使用未被定义的指令、除数出现为 0 、运算结果溢出以及特权指令等种种意外事件，致使计算机不能正常工作。此刻必须及时采取措施，否则将影响整个系统的正常运行。因此，一旦出现意外故障，计算机就发出陷阱信号，暂停当前程序的执行，转入故障处理程序进行相应的故障处理。

计算机的陷阱指令一般不提供给用户直接使用，而作为隐指令（即指令系统中不提供的指令），在出现意外故障时，由 CPU 自动产生并执行。也有的机器设置供用户使用的陷阱指令或＂访管”指令，利用它完成系统调用和程序请求。例如， IBM PC (Intel 8086) 的软中断 INT TYPE(TYPE 是 8 位常数，表示中断类型），其实就是直接提供给用户使用的陷阱指令，用来完成系统调用。  

\5. 输入输出

对于 I/0 单独编址的计算机而言，通常设有输入输出指令，它完成从外设中的寄存器读入一个数据到 CPU 的寄存器内，或将数据从 CPU 的寄存器输出至某外设的寄存器中。

\6. 其他

其他包括等待指令、停机指令、空操作指令、开中断指令、关中断指令、置条件码指令等。为了适应计算机的信息管理、数据处理及办公自动化等领域的应用，有的计算机还设有非数值处理指令。如字符串传送、字符串比较、字符串查询及字符串转换等。

在多用户、多任务的计算机系统中，还设有特权指令，这类指令只能用于操作系统或其他系统软件，用户是不能使用的。

在有些大型或巨型机中，还设有向量指令，可对整个向量或矩阵进行求和、求积运算。在多处理器系统中还配有专门的多处理机指令。  



## 寻址方式

寻址方式是指确定本条指令的数据地址以及下一条将要执行的指令地址的方法，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。

寻址方式分为指令寻址和数据寻址两大类。  

### 指令寻址

指令寻址比较简单，它分为顺序寻址和跳跃寻址两种。

顺序寻址可通过程序计数器 PC 加 1 ，自动形成下一条指令的地址；跳跃寻址则通过转移类指令实现。图 7.6 示意了指令寻址过程。

<img src="image/image-20250120103505121.png" alt="image-20250120103505121" style="zoom:67%;" />

如果程序的首地址为 0 ，只要先将 0 送至程序计数器 PC 中，启动机器运行后，程序便按 0, 1,2,3,7,8,9, …顺序执行。其中第 1 、 2 、 3 号指令地址均由 PC 自动形成。因第 3 号地址指令为"JMP 7" ，故执行完第 3 号指令后，便无条件将 7 送至 PC ，因此，此刻指令地址跳过 4 、 5 、 6 三条，直接执行第 7 条指令，接着又顺序执行第 8 条、第 9 条等指令。

关千跳跃寻址的转移地址形成方式，将在 7.3.2 节的直接寻址和相对寻址中做介绍。



### 数据寻址

数据寻址方式种类较多，在指令字中必须设一字段来指明属千哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，故把它称为形式地址，记作 A。操作数的真实地址称为有效地址，记作 EA ，它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如图 7.7 所示。

<img src="image/image-20250120103600142.png" alt="image-20250120103600142" style="zoom:50%;" />

为了便于分析研究各类寻址方式，假设指令字长、存储字长、机器字长均相同。

1、立即寻址

立即寻址的特点是操作数本身设在指令字内，即形式地址 A 不是操作数的地址，而是操作数本身，又称之为立即数。数据是采用补码形式存放的，如图 7.8 所示，图中“#”表示立即寻址特征标记。

<img src="image/image-20250120103632496.png" alt="image-20250120103632496" style="zoom:50%;" />

可见，它的优点在于只要取出指令，便可立即获得操作数，这种指令在执行阶段不必再访问存储器。显然 A 的位数限制了这类指令所能表述的立即数的范围。

2、直接寻址

直接寻址的特点是，指令字中的形式地址 A 就是操作数的真实地址 EA ，即

```
EA=A
```

图 7.9 示意了直接寻址。

<img src="image/image-20250120103746505.png" alt="image-20250120103746505" style="zoom:50%;" />

它的优点是寻找操作数比较简单，也不需要专门计算操作数的地址，在指令执行阶段对主存只访问一次。它的缺点在千 A 的位数限制了操作数的寻址范围，而且必须修改 A 的值，才能修改操作数的地址。

3、隐含寻址

隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。例如，一地址格式的加法指令只给出一个操作数的地址，另一个操作数隐含在累加器ACC 中，这样累加器 ACC 成了另一个数的地址。图 7.10 示意了隐含寻址。

又如 IBM PC (Intel 8086) 中的乘法指令，被乘数隐含在寄存器 AX(16 位）或寄存器 AL(8位）中，可见 AX （或 AL) 就是被乘数的地址。又如字符串传送指令 MOVS ，其源操作数的地址隐含在 SI 寄存器中（即操作数在 SI 指明的存储单元中），目的操作数的地址隐含在 DI 寄存器中。

由于隐含寻址在指令字中少了一个地址，因此，这种寻址方式的指令有利于缩短指令字长。

4、间接寻址

倘若指令字中的形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址，也就是说，有效地址是由形式地址间接提供的，即为间接寻址，即 EA= (A) ，如图 7.11所示。  

<img src="image/image-20250120103857619.png" alt="image-20250120103857619" style="zoom:67%;" />

图 7.ll(a) 为一次间接寻址，即 A 地址单元的内容 EA 是操作数的有效地址；图 7.ll(b) 为两次间接寻址，即 A 地址单元的内容 Al 还不是有效地址，而由 Al 所指单元的内容 EA 才是有效地址。

这种寻址方式与直接寻址相比，它扩大了操作数的寻址范围，因为 A 的位数通常小于指令字长，而存储字长可与指令字长相等。若设指令字长和存储字长均为 16 位， A 为 8 位，显然直接寻址范围为 28 ，一次间接寻址的寻址范围可达 216 。当多次间接寻址时，可用存储字的首位来标志间接寻址是否结束。如图 7.ll(b) 中，当存储字首位为 “1” 时，标明还需继续访存寻址；当存储字首位为 “0” 时，标明该存储字即为 EA 。由此可见，存储字首位不能作为 EA 的组成部分，因此，它的寻址范围为 $2^{15}$。

间接寻址的第二个优点在千它便于编制程序。例如，用间接寻址可以很方便地完成子程序返回，图 7.12 示意了用于子程序返回的间址过程。

图中表示两次调用子程序，只要在调用前先将返回地址存入子程序最末条指令的形式地址A 的存储单元内，便可准确返回到原程序断点。例如，第一次调用前，使[ A] = 81 ，第二次调用前，使 [A]= 202 。这样，当第一次子程序执行到最末条指令 “JMP @A”( ＠为间址特征位），便可无条件转至 81 号单元。同理，第二次执行完子程序后，便可返回到 202 号单元。

<img src="image/image-20250120104002475.png" alt="image-20250120104002475" style="zoom:50%;" />

间接寻址的缺点在千指令的执行阶段需要访存两次（一次间接寻址）或多次（多次间接寻址），致使指令执行时间延长。

5、寄存器寻址

在寄存器寻址的指令字中，地址码字段直接指出了寄存器的编号，即 EA=R, ，如图 7.13 所示。其操作数在由 R, 所指的寄存器内。由于操作数不在主存中，故寄存器寻址在指令执行阶段无须访存，减少了执行时间。由于地址字段只需指明寄存器编号（计算机中寄存器数有限），故指令字较短，节省了存储空间，因此寄存器寻址在计算机中得到广泛应用。

6、寄存器间接寻址

图 7.14 示意了寄存器间接寻址过程。  

<img src="image/image-20250120104152554.png" alt="image-20250120104152554" style="zoom:50%;" />

图中 R，中的内容不是操作数，而是操作数所在主存单元的地址号，即有效地址 EA= (R;) 。与寄存器寻址相比，指令的执行阶段还需访问主存。与图 7.ll(a) 相比，因有效地址不是存放在存储单元中，而是存放在寄存器中，故称其为寄存器间接寻址，它比间接寻址少访存一次。

7、基址寻址

基址寻址需设有基址寄存器 BR ，其操作数的有效地址 EA 等千指令字中的形式地址与基址寄存器中的内容（称为基地址）相加，即

```
EA=A+(BR)
```

图 7.15 示意了基址寻址过程。

<img src="image/image-20250120104249732.png" alt="image-20250120104249732" style="zoom:50%;" />

基址寄存器可采用隐式的和显式的两种。所谓隐式，是在计算机内专门设有一个基址寄存器 BR ，使用时用户不必明显指出该基址寄存器，只需由指令的寻址特征位反映出基址寻址即可。显式是在一组通用寄存器里，由用户明确指出哪个寄存器用作基址寄存器，存放基地址。例如，IBM 370 计算机中设有 16 个通用寄存器，用户可任意选中某个寄存器作为基址寄存器。对应图7.15 (a) 为隐式基址寻址，图 7.15 (h) 为显式基址寻址。

基址寻址可以扩大操作数的寻址范围，因基址寄存器的位数可以大于形式地址 A 的位数。当主存容量较大时，若采用直接寻址，因受 A 的位数限制，无法对主存所有单元进行访问，但采用基址寻址便可实现对主存空间的更大范围寻访。例如，将主存空间分为若干段，每段首地址存于基址寄存器中，段内的位移量由指令字中形式地址 A 指出，这样操作数的有效地址就等于基址寄存器内容与段内位移量之和，只要对基址寄存器的内容做修改，便可访问主存的任一单元。

基址寻址在多道程序中极为有用。用户可不必考虑自己的程序存千主存的哪一空间区域，完全可由操作系统或管理程序根据主存的使用状况，赋予基址寄存器内一个初始值（即基地址），便可将用户程序的逻辑地址转化为主存的物理地址（实际地址），把用户程序安置于主存的某一空间区域。例如，对千一个具有多个寄存器的机器来说，用户只需指出哪一个寄存器作为基址寄存器即可，至千这个基址寄存器应赋予何值，完全由操作系统或管理程序根据主存空间状况来确定。在程序执行过程中，用户不知道自己的程序在主存的哪个空间，用户也不可修改基址寄存器的内容，以确保系统安全可靠地运行。  

8、变址寻址

变址寻址与基址寻址极为相似。其有效地址 EA 等于指令字中的形式地址 A 与变址寄存器IX 的内容相加之和，即

```
EA=A+(IX)
```

显然只要变址寄存器位数足够，也可扩大操作数的寻址范围，其寻址过程如图 7.16 所示。

<img src="image/image-20250120110217882.png" alt="image-20250120110217882" style="zoom:50%;" />

图 7.16(a) 、（ b) 与图 7.15 (a) 、（ b) 相比，显见变址寻址与基址寻址的有效地址形成过程极为相似。由千两者的应用场合不同，因此从本质来认识，它们还是有较大的区别。基址寻址主要用千为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值是不可变的，而指令字中的 A 是可变的。在变址寻址中，变址寄存器的内容是由用户设定的，在程序执行过程中其值可变，而指令字中的 A 是不可变的。变址寻址主要用于处理数组问题，在数组处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX 的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。例如，某数组有 N 个数存放在以 D 为首地址的主存一段空间内。如果求 N 个数的平均值，则用直接寻址方式很容易完成程序的编制。表 7.1 列出了用直接寻址求 N 个数平均值的程序。

<img src="image/image-20250120110332477.png" alt="image-20250120110332477" style="zoom:50%;" />

显然，当 N= 100 时，该程序用了 102 条指令，除数据外，共占用 102 个存储单元存放指令。而且随 N 的增加，程序所用的指令数也增加（共 N+2 条）。

若用变址寻址，则只要改变变址寄存器的内容，而保持指令 “ADD X,D" (X 为变址寄存器， D为形式地址）不变，便可依次完成 N 个数相加。用变址寻址编制的程序如表 7.2 所示。

<img src="image/image-20250120110405269.png" alt="image-20250120110405269" style="zoom:50%;" />

该程序仅用了 8 条指令，而且随 N 的增加，指令数不变，指令所占的存储单元大大减少。

有的机器（如 Intel 8086 、 VAX-11) 的变址寻址具有自动变址的功能，即每存取一个数据，根据数据长度（即所占字节数），变址寄存器能自动增量或减量，以便形成下一个数据的地址。

变址寻址还可以与其他寻址方式结合使用。例如，变址寻址可与基址寻址合用，此时有效地址 EA 等千指令字中的形式地址 A 和变址寄存器 IX 的内容 (IX) 及基址寄存器 BR 中的内容(BR) 相加之和，即

```
EA=A+(IX) +(BR)
```

变址寻址还可与间接寻址合用，形成先变址后间址或先间址再变址等寻址方式，读者在使用各类机器时可注意分析。  

9、相对寻址

相对寻址的有效地址是将程序计数器 PC 的内容（即当前指令的地址）与指令字中的形式地
址 A 相加而成，即

```
EA=(PC)+A
```

图 7.17 示意了相对寻址的过程，由图中可见，操作数的位置与当前指令的位置有一段距离 A 。

相对寻址常被用于转移类指令，转移后的目标地址与当前指令有一段距离，称为相对位移量，它由指令字的形式地址 A 给出，故 A 又称位移量。位移量 A 可正可负，通常用补码表示。倘若位移量为 8 位，则指令的寻址范围在 (PC)+ 127 ~ (PC) -128 之间。

<img src="image/image-20250120110526790.png" alt="image-20250120110526790" style="zoom:50%;" />

相对寻址的最大特点是转移地址不固定，它可随 PC 值的变化而变，因此，无论程序在主存的哪段区域，都可正确运行，对于编写浮动程序特别有利。例如，表 7.2 中有一条转移指令 “BNEM" ，它存于 M+3 单元内，也即

<img src="image/image-20250120110552811.png" alt="image-20250120110552811" style="zoom:50%;" />

显然，随程序首地址改变， M 也改变。如果采用相对寻址，将 “BNE M” 改写为 “BNE * -3"(＊为相对寻址特征），就可使该程序浮动至任一地址空间都能正常运行。因为从第 M+3 条指令转至第 M 条指令，其相对位移量为－ 3 ，故当执行第 M+3 条指令 “BNE * -3” 时，其有效地址为

```
EA= (PC) +(-3) = M +3-3 = M
```

直接指向了转移后的目标地址。

相对寻址也可与间接寻址配合使用。  

例 7.2 设相对寻址的转移指令占 3 个字节，第一字节为操作码，第二、三字节为相对位移量（补码表示），而且数据在存储器中采用以低字节地址为字地址的存放方式。每当 CPU 从存储器取出一个字节时，即自动完成 (PC)+l-+PC 。

(1) 若 PC 当前值为 240 （十进制），要求转移到 290 （十进制），则转移指令的第二、三字节的机器代码是什么？
(2) 若 PC 当前值为 240 （十进制），要求转移到 200 （十进制），则转移指令的第二、三字节的机器代码是什么？

解：（ 1) PC 当前值为 240 ，该指令取出后 PC 值为 243 ，要求转移到 290 ，即相对位移量为290-243 = 47 ，转换成补码为 2FH 。由千数据在存储器中采用以低字节地址为字地址的存放方式，故该转移指令的第二字节为 2FH ，第三字节为 OOH 。

(2) PC 当前值为 240 ，该指令取出后 PC 值为 243 ，要求转移到 200 ，即相对位移量为 200-243 =-43 ，转换成补码为 D5H ，由于数据在存储器中采用以低字节地址为字地址的存放方式，故该转移指令的第二字节为 D5H ，第三字节为 FFH 。

10、堆栈寻址

堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组（称为硬堆栈）来实现，也可利用存的一部分空间作堆栈（称为软堆栈）。堆栈的运行方式为先进后出或先进先出两种，先进后出型堆栈的操作数只能从一个口进行读或写。以软堆栈为例，可用堆栈指针 SP (Stack Point) 指出栈顶地址，也可用 CPU 中一个或两个寄存器作为 SP 。操作数只能从栈顶地址指示的存储单元存或取。可见堆栈寻址也可视为一种隐含寻址，其操作数的地址总被隐含在 SP 中。堆栈寻址
就其本质也可视为寄存器间接寻址，因 SP 可视为寄存器，它存放着操作数的有效地址。图 7.18示意了堆栈寻址过程。  

<img src="image/image-20250120110846214.png" alt="image-20250120110846214" style="zoom:50%;" />

图 7.18 (a) 、（ b) 分别表示进栈 “PUSH A” 和出栈 “POP A” 的过程。

由千 SP 始终指示着栈顶地址，因此不论是执行进栈 (PUSH) ，还是出栈 (POP),SP 的内容都需要发生变化。若栈底地址大于栈顶地址，则每次进栈   $(\text{SP}) - \Delta \rightarrow \text{SP}$；每次出栈$(\text{SP}) + \Delta \rightarrow \text{SP}$ 。 A 取值与主存编址方式有关。若按字编址，则 A 取 1 （如图 7.18 所示） ；若按字节编址，则需根据存储字长是几个字节构成才能确定 A ，例如字长为 16 位，则 A=2 ，字长为 32 位， A ＝ 4 。

例 7.3 一条双字长直接寻址的子程序调用指令，其第一个字为操作码和寻址特征，第二个字为地址码 5000H 。假设 PC 当前值为 2000H, SP 的内容为 0100H ，栈顶内容为 2746H ，存储器按字节编址，而且进栈操作是先执行 (SP) -Li-+SP ，后存入数据。试回答下列几种情况下， PC 、SP 及栈顶内容各为多少？

(1) CALL 指令被读取前。
(2) CALL 指令被执行后。
(3) 子程序返回后。

解：（ 1) CALL 指令被读取前， PC= 2000H, SP= OlOOH ，栈顶内容为 2746H 。

(2) CALL 指令被执行后，由千存储器按字节编址， CALL 指令共占 4 个字节，故程序断点2004H 进栈，此时 SP = (SP) - 2 = OOFEH ，栈顶内容为 2004H, PC 被更新为子程序入口地址 5000H 。

(3) 子程序返回后，程序断点出栈， PC= 2004H, SP 被修改为 0100H ，栈顶内容为 2746H 。

由千当前计算机种类繁多，各类机器的寻址方式均有各自的特点，还有些机器的寻址方式可能本书并未提到，故读者在使用时需自行分析，以利于编程。

从高级语言角度考虑问题，机器指令的寻址方式对用户无关紧要，但一旦采用汇编语言编程，用户只有了解并掌握机器的寻址方式，才能正确编程，否则程序将无法正常运行。如果读者参与机器的指令系统设计，则了解寻址方式对确定机器指令格式是不可缺少的。从另一角度来看，倘若透彻了解了机器指令的寻址方式，将会使读者进一步加深对机器内信息流程及整机工作概念的理解。



## 指令格式举例



## RISC技术

RISC 即精简指令系统计算机 (Reduced Instruction Set Computer) ，与其对应的是 CISC ，即复杂指令系统计算机 (Complex Instruction Set Computer) 。  

### RISC的产生和发展

计算机发展至今，机器的功能越来越强，硬件结构越来越复杂。尤其是随着集成电路技术的发展及计算机应用领域的不断扩大，计算机系统的软件价格相对而言在不断提高。为了节省开销，人们希望已开发的软件能被继承、兼容，这就希望新机种的指令系统和寻址方式一定能包含旧机种所有的指令和寻址方式。通过向上兼容不仅可降低新机种的开发周期和代价，还可吸引更多的新、老用户，于是出现了同类型的系列机。在系列机的发展过程中，致使同一系列计算机指令系统变得越来越复杂，某些机器的指令系统竟可包含几百条指令。例如， DEC 公司的 VAX-11/780 有 16 种寻址方式、 9 种数据格式、 303 条指令。又如， 32 位的 68020 微型计算机指令种数比 6800 多两倍，寻址方式多 11 种，达 18 种之多，指令长度从一个字 (16 位）发展到 16 个字。这类机器被称为复杂指令系统计算机，简称 CISC 。

通常对指令系统的改进都是围绕着缩小与高级语言语义的差异和有利千操作系统的优化而进行的。由千编写编译器的人们的任务是为每一条高级语言的语旬编制一系列的机器指令，如果机器指令能类似于高级语言的语旬，显然编写编译器的任务就变得十分简单了。千是人们产生了用增加复杂指令的办法来缩短与语义的差距。后来又发现，倘若编译器过多依赖复杂指令，同样会出现新的矛盾。例如，对减少机器代码、降低指令执行数以及为提高流水性能而优化生成代码等都是非常不利的。尤其当指令过于复杂时，机器的设计周期会很长，资金耗费会更大。例如， Intel 80386 32 位机器耗资达 1.5 亿美元，开发时间长达三年多，结果正确性还很难保证，维护也很困难。最值得一提的例子是， 1975 年 IBM 公司投资 10 亿美元研制的高速机器 FS 机，最终以“复杂结构不宜构成高速计算机”的结论宣告研制失败。

为了解决这些问题， 20 世纪 70 年代中期，人们开始进一步分析研究 CISC ，发现一个 80-20规律，即典型程序中 80％的语旬仅仅使用处理机中 20％的指令，而且这些指令都是属千简单指令，如取数、加、转移等。这一点告诫人们，付出再大的代价增添复杂指令，也仅有 20％的使用概率，而且当执行频度高的简单指令时，因复杂指令的存在，致使执行速度也无法提高。表 7.3 是HP 公司对 IBM 370 高级语言中指令使用频度的分析结果。 Marathe 在 1978 年对 PDP-11 机在五种不同应用领域中的指令进行混合测试，也得出了类似的结论。  

<img src="image/image-20250120111704545.png" alt="image-20250120111704545" style="zoom: 50%;" />

另一方面，在 20 世纪 70 年代末 80 年代初，计算机的器件已进入 VLSI 时代，复杂的指令系统需要复杂的控制器，这需要占用较多的芯片面积。统计表明，典型的 CISC 计算机中，控制器约占 60％的芯片面积，而且使设计、验证和实现都更加困难。

人们从 80-20 规律中得到启示：能否仅仅用最常用的 20％的简单指令，重新组合不常用的80 ％的指令功能呢？这便引发出 RISC 技术。

1975 年 IBM 公司 John Cocke 提出了精简指令系统的设想， 1982 年美国加州大学伯克利分校的研究人员专门研究了如何有效利用 VLSIC （超大规模集成电路）的有效空间。 RISC 由于设计的指令条数有限，相对而言，它只需用较小的芯片空间便可制作逻辑控制电路，更多的芯片空间可用来增强处理机的性能或使其功能多样化。他们用大部分芯片空间做成寄存器，并且用它们作为暂时数据存储的快速存储区，从而有效地降低了 RISC 机器在调用子程序时所需付出的时间。他们研制的 RISC I （后来又出现 RISC Il) ，采用 VLSI CPU 芯片上的晶体管数量达 44 000 个，线宽为 3 µm ，字长为 32 位，其中有 128 个寄存器（而用户只能见到 32 个），仅有 31 条指令和两种寻址方式，访存指令只有两条，即取数 (LOAD) 和存数 (STORE) 。显然其指令系统极为简单，但它们的功能已超过 VAX-11/780 和 M68000 ，其速度比 VAX-11/780快了 1 倍。

与此同时，美国斯坦福大学 RISC 研究的课题是 MIPS (Micro Processor without InterlockingPipeline Stages) ，即消除流水线各段互锁的微处理器。他们把 IBM 公司对优化编译程序的研究与加州大学伯克利分校对 VLSI 有效空间利用的思想结合在一起，最终的研究成果后来转化为MIPS 公司 RXOOO 的系列产品。 IBM 公司又继其 IBM801 型机、 IBM RT/PC 后，于 1990 年推出了著名的 IBM RS/6000 系列产品。加州大学伯克利分校的研究成果最后发展成 Sun 微系统公司的 RISC 芯片，称为 SPARC (Scalable Processor ARChitecture) 。

到目前为止， RISC 体系结构的芯片可以说已经历了 3 代：第一代以 32 位数据通路为代表，支持 Cache ，软件支持较少，性能与 CISC 体系结构的产品相当，如 RISC I 、 MIPS 、 IBM801 等。第二代产品提高了集成度，增加了对多处理机系统的支持，提高了时钟频率，建立了完善的存储管理体系，软件支持系统也逐渐完善。它们已具有单指令流水线，可同时执行多条指令，每个时钟周期发出一条指令（有关流水线的概念详见 8.3 节）。例如， MIPS 公司的 R3000 处理器，时钟频率为 25 MHz 和 33 MHz ，集成度达 11.5 万个晶体管，字长为 32 位。第三代 RISC 产品为 64 位微处理器，采用了巨型计算机或大型计算机的设计技术 超级流水线 (Superpipelining) 技术和超标量 (Superscalar) 技术，提高了指令级的并行处理能力，每个时钟周期发出 2 条或 3 条指令，使RISC 处理器的整体性能更好。例如， MIPS 公司的 R4000 处理器采用 50 MHz 和 75 MHz 的外部时钟频率，内部流水时钟达 100 MHz 和 150 MHz ，芯片集成度高达 110 万个晶体管，字长 64 位，并有 16 KB 的片内 Cache 。它有 R4000PC 、 R4000SC 和 R4000MC 三种版本，对应不同的时钟频率，分别提供给台式系统、高性能服务器和多处理器环境下使用。表 7.4 列出了 MIPS 公司 R 系列 RISC 处理器的几项指标。

<img src="image/image-20250120111823783.png" alt="image-20250120111823783" style="zoom:50%;" />

自 1983 年开始出现商品化的 RISC 机以来，比较著名的 RISC 机有 IBM 公司的 IBM RT 系列， HP 公司的精密结构计算机 (HPPA) 、 MIPS R3000 、 Motorola M88000 、 Intel 80960 、 INMOSTransputer 、 AMD AM29000 、 Fairchild Clipper 等。其中， Clipper 兼顾了 RISC 和 CISC 两方面的特点，又称为类 RISC 机。在计算机工作站方面， Sun Microsystems 公司千 1987 年推出 SPARC ，速度达7 ~ 10 MIPS 。 1988 年 Apollo 公司推出 Series 10000 个人超级计算机，称为并行精简指令系统多处理机 PRISM (Parallel Reduced Instruction Set Multiprocessor) ，单机系统速度达 15 ~ 25 MIPS, 四处理机则可达 60~ 100 MIPS ，后来 HP 合并了 Apollo 公司，继续发展工作站。

较为著名的第三代 RISC 机的有关性能指标如表 7.5 所示。

<img src="image/image-20250120112010469.png" alt="image-20250120112010469" style="zoom: 67%;" />





### RISC的主要特征

由上分析可知， RISC 技术是用 20％的简单指令的组合来实现不常用的 80％的那些指令功能，但这不意味着 RISC 技术就是简单地精简其指令集。在提高性能方面， RISC 技术还采取了许多有效措施，最有效的方法就是减少指令的执行周期数。

计算机执行程序所需的时间 P 可用下式表述：

```
P = I x C x T
```

其中， I 是高级语言程序编译后在机器上运行的机器指令数； C 为执行每条机器指令所需的平均机器周期； T 是每个机器周期的执行时间。

表 7.6 列出了第二代 RISC 机与 CISC 机的 I 、 C 、 T 统计，其中 I 、 T 为比值， C 为实际周期数。

<img src="image/image-20250120112135074.png" alt="image-20250120112135074" style="zoom:50%;" />

由千 RISC 指令比较简单，用这些简单指令编制出的子程序来代替 CISC 机中比较复杂的指令，因此 RISC 中的 I 比 CISC 多 20% ~40% 。但 RISC 的大多数指令仅用一个机器周期完成， C 的值比 CISC 小得多。而且 RISC 结构简单，完成一个操作所经过的数据通路较短，使 T 值也大大下降。因此总折算结果， RISC 的性能仍优千 CISC 2 ~5 倍。

由千计算机的硬件和软件在逻辑上的等效性，使得指令系统的精简成为可能。曾有人在1956 年就证明，只要用一条“把主存中指定地址的内容同累加器中的内容求差，把结果留在累加器中并存入主存原来地址中”的指令，就可以编出通用程序。又有人提出，只要用一条”条件传送 (CMOVE)” 指令就可以做出一台计算机；并且在 1982 年某大学做出了一台 8 位的 CMOVE 系统结构样机，称为 SIC （单指令计算机）。而且，指令系统所精简的部分可以通过其他部件以及软
件（编译程序）的功能来替代，因此，实现 RISC 技术是完全可能的。

1、RISC 的主要特点

通过对 RISC 各种产品的分析，可归纳出 RISC 机应具有如下一些特点：

1. 选取使用频度较高的一些简单指令以及一些很有用但又不复杂的指令，让复杂指令的功能由频度高的简单指令的组合来实现。
2. 指令长度固定，指令格式种类少，寻址方式种类少。
3. 只有取数／存数 (LOAD/STORE) 指令访间存储器，其余指令的操作都在寄存器内完成。
4. CPU 中有多个通用寄存器。
5. 采用流水线技术，大部分指令在一个时钟周期内完成。采用超标量和超流水线技术，可使每条指令的平均执行时间小于一个时钟周期。
6. 控制器采用组合逻辑控制，不用微程序控制。
7. 采用优化的编译程序。

值得注意的是，商品化的 RISC 机通常不会是纯 RISC 机，故上述这些特点不是所有 RISC 机全部具备的。

相比之下， CISC 的指令系统复杂庞大，各种指令使用频度相差很大；指令字长不固定，指令格式多，寻址方式多；可以访存的指令不受限制； CPU 中设有专用寄存器；绝大多数指令需要多个时钟周期方可执行完毕；采用微程序控制器；难以用优化编译生成高效的目标代码。

表 7.7 列出了一些 RISC 机指令系统的指令条数。

<img src="image/image-20250120112321520.png" alt="image-20250120112321520" style="zoom:50%;" />

下面以 RISC II 为例，着重分析其指令种类和指令格式。

2、RISC II 指令系统举例
(1) 指令种类
RISC II 共有 39 条指令，分为以下 4 类。  







### RISC和CISC的比较

与 CISC 机相比， RISC 机的主要优点可归纳如下：

1、充分利用 VLSI 芯片的面积

CISC 机的控制器大多采用微程序控制（详见第 10 章），其控制存储器在 CPU 芯片内所占的面积为 50％以上（如 Motorola 公司的 MC68020 占 68% ）。而 RISC 机控制器采用组合逻辑控制（详见第 10 章），其硬布线逻辑只占 CPU 芯片面积的 10％左右。可见它可将空出的面积供其他功能部件用，例如用于增加大量的通用寄存器（如 Sun 微系统公司的 SPARC 有 100 多个通用寄存器），或将存储管理部件也集成到 CPU 芯片内（如 MIPS 公司的 R2000/R3000) 。以上两种芯片的集成度分别小千 10 万个和 20 万个晶体管。

随着半导体工艺技术的提高，集成度可达 100 万至几百万个晶体管，此时无论是 CISC 还是RISC 都将多个功能部件集成在一个芯片内。但此时 RISC 已占领了市场，尤其是在工作站领域占有明显的优势。

2、提高计算机运算速度

RISC 机能提高运算速度，主要反映在以下 5 个方面：

1. RISC 机的指令数、寻址方式和指令格式种类较少，而且指令的编码很有规律，因此 RISC的指令译码比 CISC 的指令译码快。
2. RISC 机内通用寄存器多，减少了访存次数，可加快运行速度。
3. RISC 机采用寄存器窗口重叠技术，程序嵌套时不必将寄存器内容保存到存储器中，故又提高了执行速度。
4. RISC 机采用组合逻辑控制，比采用微程序控制的 CISC 机的延迟小，缩短了 CPU 的周期。
5. RISC 机选用精简指令系统，适合于流水线工作，大多数指令在一个时钟周期内完成。

3、便千设计，可降低成本，提高可靠性

RISC 机指令系统简单，故机器设计周期短，如美国加州大学伯克利分校的 RISC I 机从设计到芯片试制成功只用了十几个月，而 Intel 80386 处理器 (CISC) 的开发花了三年半时间。

RISC 机逻辑简单，设计出错可能性小，有错时也容易发现，可靠性高。

4、有效支持高级语言程序

RISC 机靠优化编译来更有效地支持高级语言程序。由千 RISC 指令少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，而且由于 RISC 机的通用寄存器多，可尽量安排寄存器的操作，使编译程序的代码优化效率提高。例如， IBM 的研究人员发现， IBM 801 (RISC 机）产生的代码大小是 IBM S/370(CISC 机）的 90% 。

有些 RISC 机（如 Sun 公司的 SPARC) 采用寄存器窗口重叠技术，使过程间的参数传送加快，且不必保存与恢复现场，能直接支持调用子程序和过程的高级语言程序。表 7.8 列出了一些CISC 与 RISC 微处理器的特征。  

<img src="image/image-20250120112530177.png" alt="image-20250120112530177" style="zoom:50%;" />

此外，从指令系统兼容性看， CISC 大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但 RISC 机简化了指令系统，指令数量少，格式也不同千老机器，因此大多数RISC 机不能与老机器兼容。

PowerPC 是 IBM 、 Apple 、 Motorola 三家公司千 1991 年联合，用 Motorola 的芯片制造经验、Apple 的微型计算机软件支持、 IBM 的体系结构及其世界计算机市场霸主的地位，向长期被 Intel占据的微处理器市场挑战而开发的 RISC 产品。

PowerPC 中的 “PC” 意为 “Powerful Chip" ，其中 “Power“ 基于 20 世纪 80 年代后期， IBM 在其801 小型机的基础上开发的工作站和服务器中的 Power 体系，意为 “Performance Optimization WithEnhanced RISC （性能优化的增强型 RISC)” 。 PowerPC 具有超高的性能、价廉、易仿真 CISC 指令集、可运行大量的现代 CISC 计算机应用软件，即集工作站的卓越性能、 PC 机的低成本及运行众多的软件等优点于一身。此外， PowerPC 扩展性强，可覆盖 PDA （个人数字助理）到多处理、超并行的中大型机，用单芯片提供整个解决方案。

多年来计算机体系结构和组织发展的趋势是增加 CPU 的复杂性，即使用更多的寻址方式及更加专门的寄存器等。 RISC 的出现象征着与这种趋势根本决裂，自然地引起了 RISC 与 CISC 的争端。随着技术不断发展， RISC 与 CISC 还不能说是截然不同的两大体系，很难对它们做出明确的评价。最近几年， RISC 与 CISC 的争端已减少了很多。原因在于这两种技术已逐渐融合。特别是芯片集成度和硬件速度的增加， RISC 系统也越来越复杂。与此同时，在努力挖掘最大性能的过程中， CISC 的设计已集中到和 RISC 相关联的主题上来，例如增加通用寄存器数以及更加强调指令流水线设计，所以更难去评价它们的优越性了。

RISC 技术发展很快，有关 RISC 体系结构、 RISC 流水、 RISC 编译系统、 RISC 、 CISC 和 VLIW(Very Long Instruction Word ，超长指令字）技术的融合等方面的资料不少。读者若想深入了解，可以查阅有关文献。  

# 第8章 CPU的结构和功能



## CPU的结构

### CPU的功能

由第 1 章可知， CPU 实质包括运算器和控制器两大部分，第 6 章讨论了计算机内各种运算及相应的硬件配置，这里重点介绍控制器的功能。

对千冯·诺依曼结构的计算机而言，一旦程序进入存储器后，就可由计算机自动完成取指令和执行指令的任务，控制器就是专用千完成此项工作的，它负责协调并控制计算机各部件执行程序的指令序列，其基本功能是取指令、分析指令和执行指令。

1、取指令

控制器必须具备能自动地从存储器中取出指令的功能。为此，要求控制器能自动形成指令的地址，并能发出取指令的命令，将对应此地址的指令取到控制器中。第一条指令的地址可以人为指定，也可由系统设定。

2、分析指令

分析指令包括两部分内容：其一，分析此指令要完成什么操作，即控制器需发出什么操作命令；其二，分析参与这次操作的操作数地址，即操作数的有效地址。

3、执行指令

执行指令就是根据分析指令产生的＂操作命令”和＂操作数地址”的要求，形成操作控制信号序列（不同的指令有不同的操作控制信号序列），通过对运算器、存储器以及 I/0 设备的操作，执行每条指令。

此外，控制器还必须能控制程序的输入和运算结果的输出（即控制主机与 I/0 设备交换信息）以及对总线的管理，甚至能处理机器运行过程中出现的异常情况（如掉电）和特殊请求（如打印机请求打印一行字符），即处理中断的能力。

总之， CPU 必须具有控制程序的顺序执行（称指令控制）、产生完成每条指令所需的控制命令（称操作控制）、对各种操作加以时间上的控制（称时间控制）、对数据进行算术运算和逻辑运算（数据加工）以及处理中断等功能。  

### CPU结构框图

根据 CPU 的功能不难设想，要取指令，必须有一个寄存器专用于存放当前指令的地址；要分析指令，必须有存放当前指令的寄存器和对指令操作码进行译码的部件；要执行指令，必须有一个能发出各种操作命令序列的控制部件 CU ；要完成算术运算和逻辑运算，必须有存放操作数的寄存器和实现算逻运算的部件 ALU ；为了处理异常情况和特殊请求，还必须有中断系统。可见，CPU 可由四大部分组成，如图 8.1 所示。将图 8.1 细化，又可得图 8.2 。图中 ALU 部件实际上只对 CPU 内部寄存器的数据进行操作，有关 ALU 的内容已在第 6 章中有所介绍。

<img src="image/image-20250120113010797.png" alt="image-20250120113010797" style="zoom:50%;" />



### CPU的寄存器

第 4 章图 4.2 示出了存储器速度、容量和位价的关系，最上层的寄存器速度最快，容量最小，位价最贵，它们通常设在 CPU 内部。 CPU 中的寄存器大致可分两类：一类属于用户可见寄存器，用户可对这类寄存器编程，以及通过优化使 CPU 因使用这类寄存器而减少对主存的访问次数；另一类属于控制和状态寄存器，用户不可对这类寄存器编程，它们被控制部件使用，以控制 CPU的操作，也可被带有特权的操作系统程序使用，从而控制程序的执行。

1、用户可见寄存器

通常 CPU 执行机器语言访问的寄存器为用户可见寄存器，按其特征又可分为以下几类。  

(1) 通用寄存器

通用寄存器可由程序设计者指定许多功能，可用于存放操作数，也可作为满足某种寻址方式所需的寄存器。例如，基址寻址所需的基址寄存器、变址寻址所需的变址寄存器和堆栈寻址所需的栈指针，都可用通用寄存器代替。寄存器间接寻址时还可用通用寄存器存放有效地址的地址。

当然，也有一些机器用专用寄存器作为基址寄存器、变址寄存器或栈指针，这样，在设计指令格式时只需将这类专用寄存器隐含在操作码中，而不必占用指令字中的位。图 7.15 (a) 所示的就是用专用寄存器作为基址寄存器，而图 7.15 (b) 是用通用寄存器作为基址寄存器，所以指令字中必须有 R 字段指出寄存器编号。又如图 7.21 所示的 IBM 360/370 指令格式中，由于用通用寄存器作为变址寄存器和基址寄存器，故在指令字中设有 X 和 B 字段，分别指出作为变址寄存器和基址寄存器的通用寄存器编号。

(2) 数据寄存器

数据寄存器用于存放操作数，其位数应满足多数数据类型的数值范围，有些机器允许使用两个连读的寄存器存放双倍字长的值。还有些机器的数据寄存器只能用于保存数据，不能用于操作数地址的计算。

(3) 地址寄存器

地址寄存器用千存放地址，其本身可以具有通用性，也可用千特殊的寻址方式，如用千基址寻址的段指针（存放基地址）、用于变址寻址的变址寄存器和用于堆栈寻址的栈指针。地址寄存器的位数必须足够长，以满足最大的地址范围。

(4) 条件码寄存器

这类寄存器中存放条件码，它们对用户来说是部分透明的。条件码是 CPU 根据运算结果由硬件设置的位，例如，算术运算会产生正、负、零或溢出等结果。条件码可被测试，作为分支运算的依据。此外，有些条件码也可被设置，例如，对于最高位进位标志 C ，可用指令对它置位和复位。将条件码放到一个或多个寄存器中，就构成了条件码寄存器。

在调用子程序前，必须将所有的用户可见寄存器的内容保存起来，这种保存可由 CPU 自动完成，也可由程序员编程保存，视不同机器进行不同处理。

2、控制和状态寄存器

CPU 中还有一类寄存器用于控制 CPU 的操作或运算。在一些机器里，大部分这类寄存器对用户是透明的。如以下四种寄存器在指令执行过程中起重要作用：

1. MAR ：存储器地址寄存器，用千存放将被访问的存储单元的地址。
2. MDR ：存储器数据寄存器，用于存放欲存入存储器中的数据或最近从存储器中读出的数据。
3. PC ：程序计数器，存放现行指令的地址，通常具有计数功能。当遇到转移类指令时， PC 的值可被修改。
4. IR ：指令寄存器，存放当前欲执行的指令。

通过这 4 个寄存器， CPU 和主存可交换信息。例如，将现行指令地址从 PC 送至 MAR ，启动存储器做读操作，存储器就可将指定地址单元内的指令读至 MDR ，再由 MDR 送至 IR 。

在 CPU 内部必须给 ALU 提供数据，因此 ALU 必须可直接访问 MDR 和用户可见寄存器，ALU 的外围还可以有另一些寄存器，这些寄存器用于 ALU 的输入输出以及用于和 MDR 及用户可见寄存器交换数据（如图 9.4 中的 Y 和 Z 寄存器）。

在 CPU 的控制和状态寄存器中，还有用来存放程序状态字 PSW 的寄存器，该寄存器用来存放条件码和其他状态信息。在具有中断系统的机器中还有中断标记寄存器。

3、举例

不同计算机的 CPU 中，寄存器组织是不一样的，图 8.3 画出了 Z8000 、 8086 和 MC68000 三种计算机的寄存器组织。

<img src="image/image-20250120113447423.png" alt="image-20250120113447423" style="zoom:67%;" />

Zilog Z8000 有 16 个 16 位的通用寄存器，这些寄存器可存放地址、数据，也可作为变址寄存器，其中有两个寄存器被用作栈指针，寄存器可被用作 8 位和 32 位的运算。 Z8000 中有 5 个与程序状态有关的寄存器，一个用于存放状态标记，两个用于程序计数器，两个用千存放偏移量。确定一个地址需要两个寄存器。

Intel 8086 采用不同的寄存器组织，尽管某些寄存器可以通用，但它的每个寄存器大多是专用的。它有 4 个 16 位的数据寄存器，即 AX （累加器）、 BX （基址寄存器）、 EX （计数寄存器）和DX （数据寄存器），也可兼作 8 个 8 位的寄存器 (AH 、 AL 、 BH 、 BL 、 CH 、 CL 、 DH 、 DL) 。另外，还有两个 16 位的指针（栈指针 SP 和基址指针 BP) 和两个变址寄存器（源变址寄存器 SI 和目的变址寄存器 DI) 。在一些指令中，寄存器是隐式使用的，如乘法指令总是用累加器。 8086 还有 4 个段地址寄存器（代码段 CS 、数据段 DS 、堆栈段 SS 和附加段 ES) 以及指令指针 IP （相当于 PC) 和状态标志寄存器 F 。

Motorola MC68000 的寄存器组织介于 Zilog 和 Intel 微处理器之间，它将 32 位寄存器分为 8个数据寄存器 (D。～队）和 9 个地址寄存器 (A。～凡）。数据寄存器主要用于数据运算，当需要变址时，也可作变址寄存器使用。寄存器允许 8 位、 16 位和 32 位的数据运算，这由操作码确定。地址寄存器存放 32 位地址（没有段），其中两个（儿和 A;) 也可用作堆栈指针，分别供用户和操作系统使用。针对当前执行的模式，这两个寄存器在某个时刻只能用一个。此外， MC68000 还有一个 32 位的程序计数器 PC 和一个 16 位的状态寄存器。

与 Zilog 的设计者类似， Motorola 设计的寄存器组织也不含专用寄存器。至千到底什么形式的寄存器组织最好，目前尚无一致的观点，主要由设计者根据需要自行决定。

计算机的设计者们为了给在早期计算机上编写的程序提供向上的兼容性，在新计算机的设计上经常保留原设计的寄存器组织形式。图 8.4 就是 Zilog 80000 和 Intel 80386 的用户可见寄存器组织，它们分别是 Z8000 和 8086 的扩展，它们都采用 32 位寄存器，但又分别保留了原先的些特点。由于受这种限制，因此 32 位处理器在寄存器组织的设计上只有有限的灵活性。

<img src="image/image-20250120113600169.png" alt="image-20250120113600169" style="zoom:50%;" />

### 控制单元和中断系统

控制单元 (CU) 是提供完成计算机全部指令操作的微操作命令序列部件。现代计算机中微操作命令序列的形成方法有两种：一种是组合逻辑设计方法，为硬连线逻辑；另一种是微程序设计方法，为存储逻辑。具体内容详见第 4 篇。

中断系统主要用千处理计算机的各种中断，详细内容在 8.4 节介绍。  



## 指令周期

### 指令周期的基本概念

CPU 每取出并执行一条指令所需的全部时间称为指令周期，也即 CPU 完成一条指令的时间，如图 8.5 所示。图中的取指阶段完成取指令和分析指令的操作，又称取指周期；执行阶段完成执行指令的操作，又称执行周期。在大多数情况下， CPU 就是按”取指—执行—再取指—再执行…＂的顺序自动工作的。

由于各种指令操作功能不同，因此各种指令的指令周期是不相同的。例如，无条件转移指令"JMP X" ，在执行阶段不需要访问主存，而且操作简单，完全可以在取指阶段的后期将转移地址X 送至 PC ，以达到转移的目的。这样， “JMP X” 指令的指令周期就是取指周期。又如一地址格式的加法指令 “ADD X" ，在执行阶段首先要从 X 所指示的存储单元中取出操作数，然后和 ACC的内容相加，结果存千 ACC ，故这种指令的指令周期在取指和执行阶段各访问一次存储器，其指令周期就包括两个存取周期。再如乘法指令，其执行阶段所要完成的操作比加法指令多得多，故
它的执行周期超过了加法指令，如图 8.6 所示。  

<img src="image/image-20250120113702764.png" alt="image-20250120113702764" style="zoom:50%;" />

此外，当遇到间接寻址的指令时，由于指令字中只给出操作数有效地址的地址，因此，为了取出操作数，需先访问一次存储器，取出有效地址，然后再访问存储器，取出操作数，如图 7.ll(a)所示。这样，间接寻址的指令周期就包括取指周期、间址周期和执行周期 3 个阶段，其中间址周期用于取操作数的有效地址，因此间址周期介于取指周期和执行周期之间，如图 8.7 所示。

<img src="image/image-20250120113750726.png" alt="image-20250120113750726" style="zoom:50%;" />

由第 5 章可知，当 CPU 采用中断方式实现主机与I/0 设备交换信息时， CPU 在每条指令执行阶段结束前，都要发中断查询信号，以检测是否有某个 I/0 设备提出中断请求。如果有请求， CPU 则要进入中断响应阶段，又称中断周期。在此阶段， CPU 必须将程序断点保存到存储器中。这样，一个完整的指令周期应包括取指、间址、执行和中断 4 个子周期，如图 8.8 所示。由千间址周期和中断周期不一定包含在每个指令周期内，故图中用菱形框判断。

总之，上述 4 个周期都有 CPU 访存操作，只是访存的目的不同。取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数（当指令为访存指令时），中断周期是为了保存程序断点。这 4 个周期又可称为 CPU 的工作周期，为了区别它们，在 CPU 内可设置 4 个标志触发器，如图 8.9 所示。

<img src="image/image-20250120142436157.png" alt="image-20250120142436157" style="zoom:50%;" />

图 8.9 所示的 FE 、 IND 、 EX 和 INT 分别对应取指、间址、执行和中断 4 个周期，并以 “1” 状态表示有效，它们分别由 1一FE 、 l~IND 、 l~EX 和 l~INT 这 4 个信号控制。

设置 CPU 工作周期标志触发器对设计控制单元十分有利。例如，在取指阶段，只要设置取指周期标志触发器 FE 为 1 ，由它控制取指阶段的各个操作，便获得对任何一条指令的取指命令序列。又如，在间接寻址时，间址次数可由间址周期标志触发器 IND 确定，当它为 “0” 状态时，表示间接寻址结束。再如，对千一些执行周期不访存的指令（如转移指令、寄存器类型指令），同样可以用它们的操作码与取指周期标志触发器的状态相”与“，作为相应微操作的控制条件。这些特点读者在控制单元的设计中可进一步体会。  



### 指令周期的数据流





## 指令流水

### 指令流水原理



### 影响流水线性能的因素



### 流水线性能



### 流水线种的多发技术



### 流水线结构





## 中断系统

### 概述



### 中断请求标记和中断判优逻辑



### 中断服务程序入口地址的寻址



### 中断响应



### 保护现场和恢复现场



### 中断屏蔽技术



