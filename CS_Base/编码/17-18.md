# 17. 自动操作

我们人类的创造能力与勤奋精神常常令我感叹不已，但人类的本性却是相当懒惰的。举个简单而又常见的例子，我们总是不情愿工作。我们对工作的反感是如此的强烈—当然人类也很聪明—以至于情愿花费大量的时间去设计并制造一些设备，哪怕这些设备只能将工作时间缩减几分钟。悠闲地躺在吊床上，看着自己刚发明的新奇工具自动修剪草坪，没有什么事情能比这更让我们快乐的神经为之一动了。

很可惜，我并不打算在本章中介绍自动割草机的设计。在这里我们将学会设计更加先进的机器，目标就是要使加减法的过程自动化，这听起来有些难以置信。但是，本章最终设计出的机器用途将十分广泛，因为它可以解决所有能用加、减法处理的问题，而事实上现实中的很多问题都是可以用加法与减法来解决的。

当然，随着机器变得越来越精密，其复杂程度也越来越高，因此对其构造的某些部分理解起来比较困难。因此如果你略去了某些复杂的细节，这也是在情理之中，没有人会为此责怪你。有时，我们会感到焦躁不安，甚至厌倦，发誓再也不会为了解决一个复杂的数学难题而去求助于某些电子或机械设备。但是请保持耐心，在本章的末尾我们将会设计出一种机器，我们可以称它为计算机(Computer)。

回忆我们曾在第14章讨论过的一个加法器。这个版本的加法器包括一个8位的锁存器，用于对8个开关的输入数据进行迭代求和。下面是其结构图。

从图中可以看出，8位锁存器利用触发器来保存8位数据。使用这个设备时，首先需要按下清零开关使锁存器中的内容全部都变为0，然后通过开关输入第一个数。加法器只是简单地将这个数字和锁存器输出的0进行求和，因此相加的结果与原先输入的数字是一样的。按下相加开关可以把这个数保存在锁存器中，最后会点亮某些灯泡以显示它。现在通过开关输入第二个数，加法器把它与已经存放在锁存器中的第一个数相加。再次按下相加开关，就可以把相加的结果存入锁存器中，并通过灯泡显示这个结果。通过这种方式，可以把一串数相加并显示运行结果。显然，这种设计方案存在一个缺陷：8个灯泡无法显示大于255的数。

<img src="image/image-20241210145304541.png" alt="image-20241210145304541" style="zoom:33%;" />

对于第14章所介绍的这种电路，目前为止只讲到了一种锁存器，它是电平触发(level triggered)的。在电平触发的锁存器中，为了保存数据必须将时钟输入端首先置1，然后回置为0。当时钟输入端为1时，锁存器的数据输入端可以改变，而这些变化将会影响到数据输出。在第14章的后半部分还介绍了边沿触发(edge-triggered)的锁存器，这种锁存器在时钟输入从0跳变为1的瞬间保存数据。边沿触发器在很多方面更加易于使用，因此假定本章用到的所有触发器都是边沿触发的。

用来累加多个数的锁存器称做累加器(accumulator)。在本章的后面将会看到累加器不仅仅做简单的累加，它还充当着锁存器的角色，保存第一个数，并且和下一个数做加法或减法运算。

很显然，上面的加法器存在着一个很大的缺陷：假如要把100个二进制数加起来，你必须端坐于加法器前，并且耐心地输入所有的数并累加起来。但是当你终于完成时，却发现其中有两个数输错了，而你只能重复一遍所有的工作。

但是，也许并非如此。在前一章我们使用了大约500万个继电器构造了一个64 KB的RAM阵列。除此之外，我们还把一个控制面板连接到电路帮助我们工作，闭合它的控制（Takeover，有些书中也称“接管”）端开关后，就可以使用其他开关来控制RAM阵列的读写。下面是64 KB RAM阵列结构图。

如果把这100个二进制数输入到RAM阵列中而不是直接输入到加法器中，一旦需要修改一些数据，我们的工作将会变得容易得多。

<img src="image/image-20241210145356602.png" alt="image-20241210145356602" style="zoom:33%;" />

因此我们所现在面临的挑战就是如何把RAM阵列和累加器连接起来。很显然，RAM阵列的输出信号可以替代加法器的开关。而你也许想不到，用一个16位的计数器（比如我们在14章构造的那种）就可以控制RAM阵列的地址信号。在这个电路中，RAM阵列的数据输入信号和写操作端信号可以省去。修改后的电路结构如下图所示。

<img src="image/image-20241210145422550.png" alt="image-20241210145422550" style="zoom:33%;" />

当然，这并不是迄今发明的最易于使用的计算设备。要使用它，首先要闭合清零开关，这样做的目的是，清除锁存器中的内容并把16位计数器的输出置为0000h，然后闭合RAM控制面板的控制端开关。现在你可以从地址0000h开始输入一组你想要相加的8位数。如果有100个数，那么它们将被存放在0000h～0063h的地址空间中（也应该把RAM阵列中未使用的单元设置为00h）。然后闭合RAM控制面板的控制端开关（这样控制面板就不再控制RAM阵列了），同时断开清零开关。做完了这些，我们可以静静地坐下来，观察灯泡显示运算结果。

让我们来看一下它是怎样工作的：当清零开关第一次断开时，RAM阵列的地址输入是0000h。RAM阵列的该地址中存放的8位数值是加法器的输入数据。加法器的另一个输入数据为00h，因为此时锁存器也已经清零了振荡器提供的时钟信号—一个可以在0,1之间快速切换的信号。清零开关断开后，当时钟信号由0跳变为1时，将有两件事同时发生：锁存器保存加法器的计算结果，同时16位计数器增1，指向RAM阵列的下一个地址单元。清零开关断开之后，时钟信号第一次从0跳变为1时，锁存器就将第一个数值保存下来，同时计数器增加为0001h；当时钟发生第二次跳变时，锁存器保存之前两个数的求和结果，同时计数器增加为0002h；按这种方式往复操作。

要注意的是，这里首先做了一些假设。最主要的一点就是，振荡器要足够慢以使电路的其他部分可以工作。每次时钟振荡的过程中，在加法器输出有效的结果之前，一些继电器必须去触发其他继电器。

这个电路存在的一个缺陷是：我们没有办法使它停下来。在某一个时刻，所有灯泡会停止发光，因为RAM阵列的剩余部分存放的数都是00h。这时，你可以读取二进制的运算结果。但是当计数器达到FFFFh时，它会重新回滚(roll over)到0000h（这就好像汽车的里程表一样），这时自动加法器会再一次把所有的数累加到已经计算出来的结果中去。

这个加法器还存在另一个问题：它只能做加法运算，并且只能做8位数的加法。在这个RAM阵列中，不但每一个数要小于255，而且任意个数相加的结果也要小于255。此外，该加法器也不能处理减法运算，尽管可以用2的补数表示负数，但在这种情况下加法器能处理的数字的范围被限制在-128到127之间。要处理更大的数（例如，16位数）的话，一个简单的方法是：把RAM阵列、加法器、锁存器的位宽全都加倍，同时增加8个灯泡。但这些投资在我们看来是不合算的。

当然，这里提到这个问题的原因是最终我们要解决它。但首先来关注另一个问题：如果你不需要把100个数加在一起呢？如果你想做的是用自动加法器把50对数分别相加，得出50个不同的结果呢？或者你需要一种万能机，它可以方便地对两个数，10个数甚至100个数求和，并且所有的计算结果都可以很方便地使用。

先前提到的自动加法器都是用连接在锁存器上的灯泡来显示运行结果的，但是如果你想对50对数分别求和的时候，这就不是一个好的方法了。你可能会想到把运算结果存回到RAM阵列中去，这样的话，就可以在适当的时候用RAM阵列的控制面板来检查运算结果。为了实现这个目的，控制面板上专门设计了灯泡。

这意味着我们可以去掉与锁存器连接的灯泡，取而代之的是把锁存器的输出端连接到RAM阵列的数据输入端，这样就可以把计算结果写回到RAM阵列中去，如下图所示。

<img src="image/image-20241210145801051.png" alt="image-20241210145801051" style="zoom:33%;" />

上图中略去了自动加法器的其他部分，其中包括振荡器和清零开关，这是因为我们不再需要特别标注计数器和锁存器的清零及时钟输入。此外，既然我们现在已经开始利用RAM的数据输入，因此需要一种用来控制RAM写入信号的方法。

现在我们不需要担心电路能否工作，而要把注意力集中到急需解决的问题上来。目前的当务之急是如何配置一个自动加法器，使它不仅仅可以对一组数字做累加运算，还希望它能够自主地确定要累加多少个数字，而且还能记住在RAM中存放了多少个计算结果，这样就可以简化查询工作。

例如，假设我们先要对三个数进行求和，然后对两个数进行求和，最后再对三个数进行求和。想象一下，我们可以把这些数保存在RAM阵列中以0000h开始的一组空间中，这些数存储在RAM阵列中的具体形式如下图所示。

<img src="image/image-20241210145840321.png" alt="image-20241210145840321" style="zoom:33%;" />

本书中将用这样的形式表示一小段存储器。方格表示的是存储器的内容。存储器的每一个字节写在一个方格里。地址标记在方格的左边，并不是每一个地址都需要标记，因为地址是线性的，所以总是可以通过计算确定某个方格对应的地址。方格右边是关于该存储单元内容的注释，这些标记的单元就是我们想要自动加法器保存三个计算结果的位置（尽管这些方格画出来是空的，但是存储单元内并不是空的，它们总是保存着一些东西，就算只是一些随机数，但此时存放的是一些没有用的数）。

或许大家都有一种冲动，想亲自去做十六进制计算，并把结果填到那些小格子中去，但这并不是实验的目的，我们想要自动加法器为我们做这些加法。

我们并不希望自动加法器成为单任务系统—在它的第一个版本中，只是把RAM地址中的内容加到称为累加器的8位锁存器中—实际上我们希望它能做四件事：进行加法操作，首先它要把一个字节从存储器中传送到累加器中，这个操作称为加载(Load)。第二个操作把存储器中的一个字节加(Add)到累加器的内容中去。第三个操作把累加器中的计算结果取出并存放到存储器中。另外我们需要用一个方法令自动加法器停(Halt)下来。

我们借助具体的例子详细介绍这一过程，以上文提到的自动加法器所做的运算为例来说明。

```
(1)把0000h地址处的内容加载到累加器。
(2)把0001h地址处的内容加到累加器中。
(3)把0002h地址处的内容加到累加器中。
(4)把累加器中的内容存储到0003h地址处。
(5)把0004h地址处的内容加载到累加器。
(6)把0005h地址处的内容加到累加器。
(7)把累加器中的内容存储到0006h地址处。
(8)把0007h地址处的内容加载到累加器。
(9)把0008h地址处的内容加到累加器。
(10)把0009h地址处的内容加到累加器。
(11)把累加器中的内容存储到000Ah地址处。
(12)令自动加法器停止工作。
```

这里要注意，同最初的自动加法器一样，存储器中的每一个字节的地址仍然是以0000h为起点线性排列的。最初的加法器只是简单地把存储器指定地址的内容和累加器中的内容相加，在某些情况下需要这样做。但是有时我们需要把存储器中的某个值直接加载到累加器，或者把累加器中的值直接保存到存储器。做完了这些工作，算得上万事俱备只欠东风了，我们还希望自动加法器能方便地停下来，以便于查看RAM阵列中存放的值。

该如何来完成这些工作呢？能不能仅仅简单地向RAM阵列中输入一组数，然后期待自动加法器正确地完成所有工作呢？答案是否定的。对于RAM阵列中的每一个数，我们还需要用一些数字代码来标识加法器要做的每一项工作：加载、相加、保存和终止。

也许存放这些代码的最简单的方法（但肯定不是代价最小的）是把它们存放在一个独立的RAM阵列中。这个RAM应该和第一个RAM同时被访问。但是这个RAM中存放的是不需要求和的数，而是一些数字代码，用来标记自动加法器对第一个RAM中指定地址要做的一种操作。这两个RAM可以分别被标记为“数据”（第一个RAM阵列）和“代码”（第二个RAM阵列）。其结构如下图所示。

<img src="image/image-20241210150016307.png" alt="image-20241210150016307" style="zoom:33%;" />

我们已经清楚地认识到新的自动加法器能够把数据求和的结果写入到第一个RAM阵列（标记为“数据”），而新的RAM阵列（标记为“代码”）则只能通过控制面板写入。

我们需要四个代码来标记新的自动加法器需要做的四个操作，这些代码可以任意指定。如下所示的是一种方案。

<img src="image/image-20241210150041192.png" alt="image-20241210150041192" style="zoom:33%;" />

为了使上面讨论的三组加法得以正常执行，你需要通过控制面板把如下值存入代码RAM阵列。

比较一下该RAM阵列与存放累加数据的RAM阵列中的内容，你会发现，代码RAM阵列中存放的每一个代码都对应着数据RAM中要被加载或者加到累加器中的数，或者对应需要存回到数据RAM中的某个数。以这种方式使用的数字代码常常被称为指令码(instruction code)或操作码(operation code, opcode)。它们指示电路要执行的某种操作。

<img src="image/image-20241210150110990.png" alt="image-20241210150110990" style="zoom:33%;" />

如前所述，最初的自动加法器的8位锁存器的输出要作为数据RAM阵列的输入，这就是Save指令的功能。还需要做另一个改变：以前8位加法器的输出是8位锁存器的输入，但现在为了执行Load指令，数据RAM阵列的输出有时也要作为8位锁存器的输入，这种新的变化需要一个2-1选择器来实现。改进后的自动加法器如下图所示。

图中略去了一些组件，但是仍然清晰地描述了各个组件之间的8位数据通路。16位的计数器为两个RAM阵列提供地址输入。通常，数据RAM阵列的输出传入到8位加法器执行加操作。8位锁存器的输入可以是数据RAM阵列的输出（当执行Load指令时），也可以是加法器的输出（当执行Add指令时），这种情况下就需要2-1选择器。通常，锁存器电路的输出又流回到加法器中，但是当执行Save指令时，它就成为了数据RAM阵列的输入数据。

<img src="image/image-20241210150141723.png" alt="image-20241210150141723" style="zoom:33%;" />

上图缺少的是控制所有这些组件的信号，它们统称为控制信号，包括16位计数器的“时钟”输入和“清零”输入，8位锁存器的“时钟”输入和“清零”输入，数据RAM阵列的“写”(W)输入，2-1选择器的“选择”(S)输入。其中的一些信号很明显是基于代码RAM阵列的输出，例如，如果代码RAM阵列输出是Load指令，那么2-1选择器的“选择”输入必须是0（即选择数据RAM的输出）。只有当操作码是指令Store时，数据RAM阵列的“写”(W)输入必须是1。这些控制信号可以通过逻辑门的各种组合来实现。

利用最少的附加硬件和一些新增的操作码，可以让这个电路从累加器中减去一个数。第1步是向操作码表增加一些代码。

<img src="image/image-20241210150203158.png" alt="image-20241210150203158" style="zoom:33%;" />

对于Add和Subtract的代码，其区别仅在于最低有效位，我们称该位为C0。如果操作码为21h，除了数据RAM阵列的数据传入加法器之前要取反，并且加法器进位输入置1之外，电路所做的操作与执行Add指令所做的操作相同。在这个增加了一个反相器的改进电路中，C0信号可以完成这两项任务。改进后的电路结构图如下。

<img src="image/image-20241210150311760.png" alt="image-20241210150311760" style="zoom: 67%;" />

假设现在要把56h和2Ah相加，然后再从中减去38h，可以按照下图中两个RAM阵列中的代码（操作码）和数据（操作数）完成该运算。

<img src="image/image-20241210150356038.png" alt="image-20241210150356038" style="zoom:33%;" />

Load操作完成之后，累加器中的值更新为56h，加法操作完成后累加器中的值为56h与2Ah的和，即80h。Subtract操作使数据RAM阵列的下一个值(38h)按位取反，得到C7h。当加法器的进位输入置1时，取反得到C7h，然后使其与80h相加：

<img src="image/image-20241210150416449.png" alt="image-20241210150416449" style="zoom:33%;" />

最后的结果是48h。（在十进制中，86加42再减去56等于72）

还有一个一直没有找到合适的解决办法的问题：加法器及连接到它的所有设备的宽度只有8位。以前提出过的一个解决办法是把两个8位加法器（其他的大部分设备也用两个）连在一起，构成一个16位的设备。

但还有代价更小的解决办法，假如你想把两个16位的数相加，比如：

<img src="image/image-20241210150443008.png" alt="image-20241210150443008" style="zoom:33%;" />

这种16位的加法先单独处理最右边的字节（通常称之为低字节）：

<img src="image/image-20241210150506071.png" alt="image-20241210150506071" style="zoom:33%;" />

然后再计算最左边的字节，即高字节的和：

<img src="image/image-20241210150529697.png" alt="image-20241210150529697" style="zoom:33%;" />

得到相同的结果99D7h。因此，如果我们把两个16位的数用这种方式保存在存储器中，就像下面这样：

<img src="image/image-20241210150550911.png" alt="image-20241210150550911" style="zoom:33%;" />

运算结果D7h将被保存到地址0002h，而结果99h将被保存到地址0005h。

当然并非所有的情况都是这样处理，只是上面的例子中用到了这种方法。如果要把76ABh和236Ch这两个16位的数相加该怎么做呢？在这个例子中，对两个数的低字节求和时将会产生一个进位：

<img src="image/image-20241210150614832.png" alt="image-20241210150614832" style="zoom:33%;" />

产生的这个进位必须与两个数的高字节的和再相加：

<img src="image/image-20241210150637577.png" alt="image-20241210150637577" style="zoom: 33%;" />

最后的计算结果为9A17h。

我们能够改进自动加法器的电路，使它可以正确地进行16位数的加法操作吗？答案是肯定的，我们需要做的仅仅是在第一步运算时保存低字节数运算的进位输出，并把它作为下一步高字节数运算的进位输入。如何保存1位呢？1位锁存器就是最好的选择了，该锁存器应该被称为进位锁存器(Carry latch)。

为了使用进位锁存器，还需要另一个操作码，我们称之为“进位加法”(Add with Carry)。当进行8位数加法时，使用的是常规的Add指令。加法器的进位输入是0，它的进位输出将会保存到进位锁存器（尽管它根本不会被用到）。

如果要对两个16位的数进行加法运算，我们仍然使用常规的Add指令对两个低字节数进行加法运算。加法器的进位输入是0，而其进位输出被锁存到进位锁存器中。当把两个高字节数相加时，要使用新的Add with Carry指令。在这种情况下，两个数相加时要用进位锁存器的输出作为加法器的进位输入。因此，如果第一步低字节数的加法运算有进位，则该进位将用于第二步高字节数的加法运算；如果没有进位，则进位锁存器的输出是0。

如果要进行16位数的减法运算，则还需要一个新的指令，称为“借位减法”(Subtract and Borrow)。通常，Subtract指令需要将减数取反并且把加法器的进位输入置1。进位输出通常不是1，因此应该被忽略。但对16位数进行减法运算时，进位输出应该保存在进位锁存器中。在进行第二步的高字节减法运算时，锁存器保存的结果应该作为加法器的进位输入。

在加入了Add with Carry和Subtract and Borrow之后，目前我们已经有了7个操作码，如下表所示。

<img src="image/image-20241210150733853.png" alt="image-20241210150733853" style="zoom:33%;" />

在执行减法或借位减法运算时，送入加法器中的操作数需要进行取反预处理。加法器的进位输出是进位锁存器的数据输入。无论何时，执行加法、减法、进位加法或借位减法中的任一种运算，进位锁存器都是同步的。当执行减法运算，或进位锁存器的数据输入为1且正在执行进位加法或者借位减法运算时，8位加法器的进位输入都是置1的。

需要记住的是，只有当前一次的加法或者进位加法操作使加法器产生进位输出时，Add with Carry指令才会使8位加法器的进位输入置1。因此，只要进行多字节数加法运算，不管实际是否需要，都应该使用Add with Carry指令。为了保证编码的正确，使前面提到16位加法正常进行，可用如下方法。

<img src="image/image-20241210150757145.png" alt="image-20241210150757145" style="zoom:33%;" />

不论操作数是什么，该方法都可以正确执行。

增加了两个新的操作码之后，我们已经极大地扩展了加法器的功能，它不再局限于8位数的加法运算。通过执行进位加法操作，可以对16位数、24位数、32位数、40位数，甚至更多位的数进行加法运算。假如要进行两个32位数7A892BCDh和65A872FFh的加法运算，我们仅需要1条Add指令和3条Add with Carry指令，如下图所示。

<img src="image/image-20241210150823772.png" alt="image-20241210150823772" style="zoom:33%;" />

当然，把这些数依次输入存储器并不是最好的做法。因为你不但要使用开关来输入这些数，而且保存这些数的存储单元的地址也不是连续的。例如，7A892BCDh从最低字节开始，每个字节依次保存在0000h, 0003h, 0006h, 0009h中。而为了得到最后的结果，还需要检查0002h, 0005h, 0008h, 000Bh这几个地址中的数。

除此之外，当前设计的自动加法器不允许在随后的计算中重复使用前面的计算结果。假设我们要对三个8位数求和，然后再从中减去一个8位数并保存结果。这可能需要一条Load指令，两条Add指令，一条Subtract指令以及一条Store指令。但如果想从原来的求和结果（3个8位数的和）中减去另一个数该怎么做呢？这个求和结果已经不能被访问了，每次我们使用它的时候都必须重新计算。

产生上述情况的原因就在于我们构造的自动加法器具有如下的特性：它的代码存储器和数据存储器是同步的、顺序的，并且都从0000h开始寻址。代码存储器中的每一条指令对应数据存储器中相同地址的存储单元。一旦执行了一条Store指令，相应的，就会有一个数被保存到数据存储器中，而这个数将不能重新加载到累加器。

要解决这个难题，需要对自动加法器的设计做一个根本性的且程度极大的修改。这个想法实现起来似乎非常困难，但是很快你就会发现（我希望是这样）改进后的加法器具有更高的灵活性。

现在让我们立刻开始吧，目前已经有了7个操作码，如下所示。

<img src="image/image-20241210150859006.png" alt="image-20241210150859006" style="zoom:33%;" />

每一个操作码在存储器中占1个字节。现在除了Halt操作码外，我希望每一个指令在存储器中仅占据3个字节的空间，其中第一个字节为代码本身，另外的两个字节用来存放1个16位存储器单元地址。对于Load指令来说，后两个字节保存的地址用来指明数据RAM阵列的一个存储单元，该单元存放的是需要被加载到累加器中的字节。对于Add,Subtract, Add with Carry, Subtract with Borrow指令来说，该地址指明的存储单元所保存的是要从累加器中加上或减去的字节。对于Store指令来说，该地址指明的是累加器中的内容将要保存到的存储单元地址。

例如，当前加法器所能进行的最简单的运算就是对两个数求和。为了执行这个操作，需要按下面的方式设置代码RAM阵列和数据RAM阵列。

<img src="image/image-20241210150926531.png" alt="image-20241210150926531" style="zoom:33%;" />

在改进的自动加法器中，每条指令（除了Halt指令）需要3个字节。

<img src="image/image-20241210150945013.png" alt="image-20241210150945013" style="zoom:33%;" />

每一条指令的代码（除了Halt指令）后跟两个字节，用来指明数据RAM阵列中16位的存储地址。这三个地址恰巧是0000h, 0001h和0002h，但它们可以是任何其他可用的地址。

前面讲到了如何用Add或Add with Carry指令来对两个16位数—比如76ABh和232Ch求和。必须把两个数的低字节保存到存储器的0000h和0001h地址，把其高字节保存到0003h和0004h地址，运算的结果分别保存在0002h和0005h。

通过这种变化，我们可以用一种更合理的方式来保存这两个操作数及其运算结果，可能会把它们保存到我们从未用到过的存储区域。

<img src="image/image-20241210151016707.png" alt="image-20241210151016707" style="zoom:33%;" />

这6个存储单元不必像上图中这样全都连在一起，它们可以分散在整个64 KB数据RAM阵列的任意位置。为了把这些地址中的数相加，代码RAM阵列中的指令必须用以下方式设置。

<img src="image/image-20241210151036481.png" alt="image-20241210151036481" style="zoom:33%;" />

可以看到，保存在地址4001h和4003h处的两个低字节数先执行加法，其结果保存在4005h地址处。两个高字节数（分别保存在4000h和4002h处）通过Add with Carry指令相加，其结果保存在地址4004h处。如果去掉Halt指令并向代码RAM中加入更多指令，随后的计算可以通过引用地址很方便地使用原来的那些操作数及其结果。

实现该设计的关键是把代码RAM阵列的数据输出到3个8位锁存器中。每个锁存器保存该3字节指令的一个字节。第一个锁存器保存指令代码本身，第二个锁存器保存地址的高字节，第三个锁存器保存地址的低字节。第二个和第三个锁存器的输出构成了数据RAM阵列的16位地址。

<img src="image/image-20241210151100197.png" alt="image-20241210151100197" style="zoom: 50%;" />

从存储器中取出指令的过程称为取指令(instruction fetch)。在我们设计的加法器中，每一条指令的长度是3个字节。因为每次从存储器取回一个字节，所以取每条指令需要的时间为3个时钟周期。此外，一个完整的指令周期需要4个时钟周期。这些变化必然使得控制信号更加复杂。

机器响应指令码做一系列操作的过程称为执行(execute)指令，但这并不能表明机器是一种有生命的东西，因为它不能自行分析机器代码并决定该做什么。每一种机器码用其唯一的方式触发多种控制信号，从而引发机器执行各种操作。

注意，为了让上面的加法器更加有用，我们牺牲了运算速度。使用同样的振荡器，它的运算速度只有本章提到的第一个加法器的1/4。这验证了一个称为TANSTAAFL的工程准则，它的意思是“天下没有免费的午餐”。通常上帝总是很公平的，你改进了机器的某个方面，则其他方面就会受到损失，有得就有失。

如果不使用继电器构造这个电路的话，很显然，两个64 KB的RAM阵列构成了电路中最主要的部分。事实上早就应该放弃这些部件了，甚至从一开始就应该决定只需要一个1KB的存储器。如果能确定所有的数据都可以存放在0000h～03FFh的地址空间中，那么使用一个小于64 KB的存储器加法器也可以很好地工作。

但是你现在仍然可能不在意使用了2个RAM阵列。事实上，确实不必要在意。前面介绍了两种RAM阵列，一个用来存放指令码，另一个用来存放操作数据—这种设计使得自动加法器的结构非常清晰和易于使用。但现在我们使用3字节长的指令格式，第二个和第三个字节用来指明操作数的存储地址，因此就没有必要再使用两个独立的RAM阵列。操作码和操作数可以存放在同一个RAM阵列。

为了实现这个设计，我们需要一个2-1选择器来确定如何对RAM阵列寻址。通常，和前面的方式相同，我们用一个16位的计数器来计算地址。数据RAM阵列的输出仍然连接到3个锁存器，分别用来保存指令代码及其对应操作数的16位地址，其16位的地址输出是2-1选择器的第二种输入。地址被锁存后，可以通过选择器将其作为RAM阵列的地址输入。















# 18. 从算盘到芯片